[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Training at Sussex",
    "section": "",
    "text": "This is the website for training courses in the programming language R, run by the Methods Teaching Team in the School of Psychology, University of Sussex.\n\n\nAt the moment, our training sessions are only open to members of staff in the School of Psychology at Sussex, or by invitation.\nIf you fit that description, DO X\nIf you do not fit that description but are interested in joining a training course in the future, please register your interest here and we will get in touch when/if there are open sessions available."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "These tutorials are designed to accompany live training sessions, but they also serve as quick-reference guides for all the material covered in those sessions.\n\n\nIn live sessions, it is recommended to open the corresponding tutorial in the Viewer pane in Posit Cloud so that solutions and explanations are easily available. The workbook documents provided for each week will already contain the code to do this.\nHowever, the tutorials can also be easily accessed at any time through this website, so it isn’t necessary to open Posit Cloud to view them - simply use the sidebar to jump to the tutorial you want!\n\n\n\nThe exercises are strongly recommended to build your skills in R. All data and workbooks will be provided on Posit Cloud for completing the exercises.\nSolutions to all exercises are provided in the tutorial as well.\n\n\nSome exercises will be clearly labeled as “Challenges”. These exercises are optional and are meant to go beyond the core tutorial material. However, if you skip them, you will still be able to understand everything that follows; you won’t need to complete them in order to proceed."
  },
  {
    "objectID": "tutorials/tutorial_05.html",
    "href": "tutorials/tutorial_05.html",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "Overview\n\n\n\nThis tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset."
  },
  {
    "objectID": "tutorials/tutorial_05.html#getting-started",
    "href": "tutorials/tutorial_05.html#getting-started",
    "title": "05: Mutate and Summarise",
    "section": "Getting Started",
    "text": "Getting Started\n\nUsing This Tutorial\n\n\nSetting Up\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/tutorial_05.html#mutate",
    "href": "tutorials/tutorial_05.html#mutate",
    "title": "05: Mutate and Summarise",
    "section": "Mutate",
    "text": "Mutate\nThe mutate() function is one of the most essential functions from the dplyr package. Its primary job is to easily and transparently make changes within a dataset - in particular, a tibble.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::mutate(\n    variable_name = instructions_for_creating_the_variable\n  )\n\nvariable_name is the name of the variable that will be added to the dataset by mutate(). This can be any name that follow’s R’s object naming rules. There are two main options for this name:\n\nIf the dataset does not already contain a variable called variable_name, a new variable will be added to the dataset.\nIf the dataset does already contain a variable called variable_name, the new variable will silently1 replace (i.e. overwrite) the existing variable with the same name.\n\n\nUsage\n\n\n\n\n\n\nTip\n\n\n\nAlthough creating or modifying variables will likely be the most frequent way you use mutate(), it has other handy features such as:\n\nDeleting variables\nDeciding where newly created variables appear in the dataset\nDeciding which variables appear in the output, depending on which you’ve used\n\nSee the help documentation for more by running help(mutate) or ?mutate in the Console.\n\n\n\n\n\nComposite Scores\n\nRow-wise magic is good magic. -Hadley Wickham\n\nA very common mutate() task is to create a composite score from multiple variables - for example, an overall anxiety score from a questionnaire with ten items on anxiety. Imagine we wanted to create an overall score that is the mean of the ratings on each of those ten items, for each participant.\nTo do this, we must use a method that ensures that each score is calculated separately for each participant. There are a variety of ways to accomplish this, but a robust and reasonably straightforward way uses the purpose-built function dplyr::rowwise().\n\n\n\n\n\n\nImportant\n\n\n\nThe code below assumes a dataset structured so that each participant has data on a single row only\nIf your data is tidy with observations from the same participants on multiple rows, you will need to reshape your data or adapt the code to suit your data structure.\n\n\n\n1my_tibble |&gt;\n2  dplyr::rowwise() |&gt;\n3  dplyr::mutate(\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) |&gt;\n4  dplyr::ungroup()\n\n\n1\n\nTake the dataset, and then,\n\n2\n\nGroup the dataset by row - and because each row is a participant, by participant. This means that any subsequent calculations will be done for each row separately.\n\n3\n\nCreate the new anxiety_mean variable. The new function c_across() works quite similar to c() - namely, creating a vector of variables to take the mean of. However, it has the advantage of allowing &lt;tidyselect&gt; for choosing the variables, instead of having to type them out one by one.\n\n4\n\nRemove the grouping that was created by rowwise(). Otherwise, all other subsequent operations on this dataset will continue to be performed within each row. (This isn’t typically the desired behaviour for this task, but it can be quite useful in other scenarios!)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor lots more details and examples on rowwise() and rowwise operations with dplyr - including which other scenarios in which a row-wise dataset would be useful - run vignette(\"rowwise\") in the Console.\n\n\n\n\n\n\n\n\nPractice Tasks\n\n\n\n\nWhat would the above code produce without the rowwise()...ungroup() steps (i.e. with only the mutate() command)? Make a prediction, then try it and find out if you were right.\nThe above code is definitely not the only way to obtain the same output. Try producing the the same anxiety_mean variable with the following methods. What are the benefits and drawbacks of each methods? Hint: Use vignette(\"rowwise\") to help if you get stuck.\nUsing a dedicated by-row function, rowMeans()\nUsing the basic structure of mutate() only\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\n\nWe can see what happens without rowwise()...ungroup() just by commenting them out of the pipe. To do this, either type # before each line, or highlight them and press CTRL/CMD + SHIFT + C.\n\n\nmy_tibble |&gt; \n  # dplyr::rowwise() |&gt; \n  dplyr::mutate(\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) # |&gt; don't forget to comment out this pipe or you'll get an error\n  # dplyr::ungroup()\n\nThis code still runs successfully, but the result isn’t what we wanted. Have a look at the anxiety_mean variable: all the values are the same. Instead of calculating the mean for each person, this code instead calculated the overall mean of all of the anxiety variables, and then assigned that single value to the anxiety_mean variable. Not what we wanted in this case - but it could be useful in other scenarios!\n\nIf we wanted to avoid, or didn’t remember, the rowwise()...ungroup() sequence, there are other options to produce the same result, but neither are easier to read or implement.\n\n1. Using rowMeans\nThe base function rowMeans() calculates the mean of each row without any additional jiggery pokery to worry about. The problem is specifying which variables to include, especially because we have ten in this example to work with.\nHowever, rowMeans() is an independent function who doesn’t need no dplyr, and as such does not work the same way, for instance, mean() does, with no straightforward workaround.\n\n## Reasonable but just doesn't work!\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(c(anxiety_1, anxiety_2, anxiety_3..., anxiety_10))\n  )\n\nError in dplyr::mutate(my_tibble, anxiety_mean = rowMeans(c(anxiety_1, : object 'my_tibble' not found\n\n\nThis is because rowMeans() is expecting a whole dataset, not just a subset of columns. You can solve this by select()ing within the rowMeans() function:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(dplyr::select(my_tibble, anxiety_1, anxiety_2...))\n  )\n\n…which has the major issue that if you update the name of your dataset, you must update it in TWO places - at the start of the pipe and inside rowMeans(), along with just being a huge mess.\nAlternatively, you can use dplyr::pick() with &lt;tidyselect&gt; semantics to make this less, well, terrible:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(pick(contains(\"anxiety\")))\n  )\n\n…which didn’t seem fair because we haven’t talked about pick(), and also defeated the purpose of using rowMeans() to avoid having to learn new dplyr functions. So, dplyr wins this one either way.\nIf you’re keen to never have to learn a jot more dplyr than absolutely necessary (I bet you are not having a good time so far!), this Stack Overflow post offers some other, non-dplyr solutions…that also depend on using the magrittr pipe %&gt;%! Sorry.\n2. Use basic mutate()\nThe most straightforward method - although perhaps not the most obvious - is to express the calculation you want as arithmetic using the relevant variables. In this instance, to calculate a mean, we sum the scores together and then divide by the number of scores:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = (anxiety_1 + anxiety_2 + ... + anxiety_10)/10\n  )\n\nThis method, although very transparent, has some critical downsides.\n\nIt’s clunky and prone to error. This style works best for 2-3 variables contributing to the composite. For more variables, we end up with a lot of repetitive typing, which also means increased likelihood of typos, accidental omissions, or other errors - especially with a large number of variables, as we have here.\nIt’s not robust. Imagine that, on review of the anxiety scale, we find that anxiety_9 is a badly worded/unreliable item and decide to drop it from our analysis. We then either have to (remember to) manually update our code both to remove anxiety_9 and to change the denominator from 10 to 9 (not a good time), or debug the resulting error if we don’t remember.\n\nWe do teach this method to UGs specifically to reduce the number of functions they have to learn, but for real-life usage, in most cases, the rowwise() solution is likely preferable.\n\n\n\n\n\n\n\nRecoding and Conditionals\nThere are many functions out there for recoding variables, but the following method, using dplyr::case_when(), is recommended because it is so versatile. It can be used to recode the values from one variable into new one, but it can also combine information across variables to create a new one. It allows a series of if-else statements without having to actually have lots of if-else statements!\nThe generic format of case_when() can be stated as follows:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    new_variable = dplyr::case_when(\n      logical_assertion ~ value,\n      logical_assertion ~ value,\n      .default = value_to_use_for_cases_with_no_matches\n    )\n  )\n\n\nUsage\nWithin case_when(), each line contains a formula, written above as logical_assertion ~ value. This can be read as follows:\n\n“For the cases where logical_assertion returns TRUE, assign value to the new_variable.\n\nThese assertions are evaluated sequentially and the first match determines the value. This means that the assertions must be ordered from most specific to least specific.\n\n\n\n\n\n\nTesting Assertions\n\n\n\n\n\nThe assertions for case_when() are the same as the ones we used previously in filter(). In fact, if you need to test the assertion you are writing to ensure that your code will work as you want, you can try the same assertion in filter() to check whether the cases it returns are only and exactly the once you want to change.\n\n\n\nLet’s look at two examples of how dplyr::case_when() might come in handy.\n\nOne-Variable Input\nWe’ve created our composite anxiety_mean variable previously, and now we may want to change this continuous score into a categorical variable indicating whether or not participants display clinical levels of anxiety. So, we can use case_when() to recode anxiety_mean into a new anxiety_cat variable.\n\n1anxiety_cutoff &lt;- 35\n\n2my_tibble |&gt;\n3  dplyr::mutate(\n4    anxiety_cat = dplyr::case_when(\n5      anxiety_mean &gt;= anxiety_cutoff ~ 1,\n6      anxiety_mean &lt; anxiety_cutoff ~ 0,\n7      .default = NA\n    )\n  )\n\n\n1\n\nCreate a new object, anxiety_cutoff, containing the threshold value for separating clinical from non-clinical anxiety. This one is from REFERENCE.\n\n2\n\nTake the dataset, and then\n\n3\n\nMake a change to it as follows\n\n4\n\nCreate a new variable, anxiety_cat, by applying the following rules\n\n5\n\nFor cases where the value of anxiety_mean is greater than or equal to anxiety_cutoff, assign a value of 1 to anxiety_cat\n\n6\n\nFor cases where the value of anxiety_mean is less than anxiety_cutoff, assign a value of 0 to anxiety_cat\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign NA to anxiety_cat\n\n\n\n\n\n\n\n\n\n\nWhy the new anxiety_cutoff object?\n\n\n\n\n\nIn the code above, the cutoff value is stored in a new object, anxiety_cutoff, which is then used in the subsequent case_when() conditions. Why take this extra step?\nThis is a matter of style, since the output of this code would be entirely identical if I wrote the cutoff value into the case_when() assertions directly (e.g. anxiety_mean &gt;= 35). I have done it this way for a few reasons:\n\nThe threshold value is easy to find, in case I need to remind myself which one I used, and it’s clearly named, so I know what it represents.\nMost importantly, it’s easy to change, in case I need to update it later. I would only have to change the value in the object once, at the beginning of the code chunk, and all of the subsequent code using that object would be similarly updated.\n\nIn short, it makes the code easier to navigate, more resilient to later updates, and more transparent in its meaning.\n\n\n\n\n\nMulti-Variable Input\nWe might also like to create a useful coding variable to help keep track of the number of cases we’ve removed, and for what reasons. We can draw on input from multiple variables to create this single new variable.\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    remove = dplyr::case_when(\n2      distribution == \"Preview\" ~ \"preview\",\n3      info_consent != \"Yes\" ~ \"no_consent\",\n4      age &lt; 18 ~ \"age_young\",\n5      is.na(age) | age &gt; 100 ~ \"age_bad\",\n6      !grepl(\"eng\", tolower(fluent_lang)) ~ \"english_no\",\n7      .default = \"keep\"\n    )\n  )\n\n\n1\n\nTake the dataset my_tibble and make a change to it by a creating a new variable, remove, by applying the following rules\n\n2\n\nFor cases where the distribution variable contains exactly and only “Preview”, assign the value \"preview\". This is a common task for Qualtrics surveys to remove practice runs.\n\n3\n\nFor cases where the info_consent variable does NOT contain exactly and only the value “Yes”, assign the value \"no_consent\". This includes anyone who did not actively consent - both people who chose options OTHER than “Yes” (e.g. “No”), and people who did not respond.\n\n4\n\nFor cases where the numerical value in age is less than 18, assign the value \"age_young\".\n\n5\n\nFor cases where the value is age is NA, or is greater than 100, assign the value \"age_bad\".\n\n6\n\nFor cases where the value in fluent_lang, once converted to lowercase, does NOT contain the letters “engl”, assign the value \"english_no\". This searches open text responses to a question like “What languages do you speak fluently?” for the string “engl”.\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign the value \"keep\".\n\n\n\n\nBecause the first match for each case is the value it is assigned, each case will receive only one value, even if they match multiple criteria. For example, if you had a participant who gave their age as 17 and their fluent languages as Finnish and German, they would be coded as age_young rather than english_no because the assertion about age comes before the assertion about language. (This is sensible behaviour, because being 18 or older is an ethical requirement, whereas speaking English fluently likely isn’t.)\nFrom here, you can easily use this variable to summarise exclusions, and to filter out excluded cases for your final dataset.\n\n1my_tibble |&gt;\n  dplyr::count(remove)\n\n2final_tibble &lt;- my_tibble |&gt;\n  dplyr::filter(remove == \"keep\")\n\n\n1\n\nTake my_tibble and count the number of times each unique value occurs in the remove variable.\n\n2\n\nCreate a new object, final_tibble, by taking my_tibble and then retaining only the cases for which the remove variable has only and exactly the value \"keep\" - effectively dropping all other cases.\n\n\n\n\n\n\n\n\n\n\nRecoding Factors\n\n\n\n\n\nWhat about recoding or relabeling factors? For example, imagine a dataset where gender has been collected as 1, 2, and 3, with 1 corresponding to “Female”, 2 to “Male”, and 3 to “Nonbinary/third gender”. You\n\n\n\n\n\n\n\nAcross Multiple Variables\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Beginner Series live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Beginner Series tasks.\n\n\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    dplyr::across(&lt;tidyselect&gt;, function_to_apply)\n  )"
  },
  {
    "objectID": "tutorials/tutorial_05.html#summarise",
    "href": "tutorials/tutorial_05.html#summarise",
    "title": "05: Mutate and Summarise",
    "section": "Summarise",
    "text": "Summarise\n\nBasic Structure\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\n\n\n\n\nImportant\n\n\n\nYou may notice that the basic structure of summarise looks identical to the basic structure of mutate, above. The difference is that mutate creates or replaces variables within the same dataset, while summarise creates a new summary dataset without changing the original.\n\n\n\nUsage\n\n\n\nGrouped Summaries\n\nmy_tibble |&gt; \n  dplyr::group_by(group) |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\nReady-Made Summaries\n\n\nAcross Multiple Variables\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Beginner Series live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Beginner Series tasks."
  },
  {
    "objectID": "tutorials/tutorial_05.html#footnotes",
    "href": "tutorials/tutorial_05.html#footnotes",
    "title": "05: Mutate and Summarise",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere, “silently” means that R overwrites the existing variable without flagging that it is doing this or asking you if you are sure, so it’s important to be aware of this behaviour (and to know what variables already exist in your dataset).↩︎"
  },
  {
    "objectID": "tutorials/tutorial_01.html",
    "href": "tutorials/tutorial_01.html",
    "title": "Into the {tidyverse}",
    "section": "",
    "text": "Before we jump headfirst data wrangling, we first need to practice a core idea that underlies how many of these functions work.\nMany of the functions and operations we will encounter in R rely on logical assertions. A logical assertion is a statement that can be either true or false (in R, of course, TRUE or FALSE). Let’s look at an example first.\nTo begin, let’s ask R whether 10 is greater than 5:\n\n10 &gt; 5\n\n[1] TRUE\n\n\nR sensibly returns TRUE. Essentially, we are making a claim (10 is greater than 5) and R tells us whether that claim, or assertion, is true or not. Similarly, we can assert that 5 is greater than 10:\n\n5 &gt; 10\n\n[1] FALSE\n\n\nAnd R again, very sensibly, tells us that we’re wrong (FALSE). So far so good!\n\n\nIn the next step, we’re going to meet a foundational piece of the way R works: the vector. Vectors are essentially one-dimensional lists of pieces of information. What this means is that instead of asking R about one number at a time, we could po"
  },
  {
    "objectID": "tutorials/tutorial_01.html#logical-assertions",
    "href": "tutorials/tutorial_01.html#logical-assertions",
    "title": "Into the {tidyverse}",
    "section": "",
    "text": "Before we jump headfirst data wrangling, we first need to practice a core idea that underlies how many of these functions work.\nMany of the functions and operations we will encounter in R rely on logical assertions. A logical assertion is a statement that can be either true or false (in R, of course, TRUE or FALSE). Let’s look at an example first.\nTo begin, let’s ask R whether 10 is greater than 5:\n\n10 &gt; 5\n\n[1] TRUE\n\n\nR sensibly returns TRUE. Essentially, we are making a claim (10 is greater than 5) and R tells us whether that claim, or assertion, is true or not. Similarly, we can assert that 5 is greater than 10:\n\n5 &gt; 10\n\n[1] FALSE\n\n\nAnd R again, very sensibly, tells us that we’re wrong (FALSE). So far so good!\n\n\nIn the next step, we’re going to meet a foundational piece of the way R works: the vector. Vectors are essentially one-dimensional lists of pieces of information. What this means is that instead of asking R about one number at a time, we could po"
  },
  {
    "objectID": "tutorials/tutorial_01.html#the-console",
    "href": "tutorials/tutorial_01.html#the-console",
    "title": "Into the {tidyverse}",
    "section": "The Console",
    "text": "The Console\nThe Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nThat sounds pretty intense, so let’s get a couple of things straight right away. You will, inevitably, make typos and mistakes using R. You will write commands that make sense to you that R doesn’t understand; you will write commands that don’t make sense to you, that R does understand; and you will see all kinds of exciting errors, warning messages, and - once we get to the fun stuff - beautiful plots and results for our studies. So, right now, let’s get over the fear of doing something “wrong” in R. You will do many, many things wrong, just like someone saying their first few words in a new language. Who cares? You’re learning.\n\nTask 1\nType literally any gibberish, words, keysmashes etc. into the Console and press Enter.\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nThis is fun! I'm having fun!\n\nError: &lt;text&gt;:2:6: unexpected symbol\n1: ## Words!\n2: This is\n        ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\nWell, that went about as expected!\nLuckily, R has a very short memory (that is to say, no memory to speak of) and is always ready to do the next thing I ask straightaway, even if it’s nonsense - which is lucky for me, I can assure you.\nIf you haven’t tried this yet, and the cursor in the Console is just blinking balefully at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There are two important things that we are learning here:\n\nTo ask R to do something - that is, to “run” or “execute” the commands you write - you must write them out in the Console and press Enter.\nEventually, inevitably, something that you type WILL produce an error. This is no cause for panic, fear, or alarm, so get it out of the way now!\n\nFrom our gleeful keysmashing above, you will have seen that aslavb;lj aew aljvb, This is fun! I'm having fun!, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\nGlossoRlia\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nWhat I am trying to tackle right away is the idea that R is scary or incomprehensible. R is just a system for doing tasks that computers are great at - sifting through thousands of data points in a second, making systematic changes to huge datasets, creating complex mathematical models, drawing elaborate plots. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But although R can do maths a lot quicker than a human, it can’t design studies, or critically evaluate an argument, or appreciate a well-chosen emoji, or have sudden bursts of inspiration, or use the results it produces to improve society. Ultimately it’s just a tool to help you achieve your goals.\nRight, enough philosophizing. Let’s prove the point by jumping into R and learning about how it works!"
  },
  {
    "objectID": "tutorials/tutorial_01.html#numbers",
    "href": "tutorials/tutorial_01.html#numbers",
    "title": "Into the {tidyverse}",
    "section": "Numbers",
    "text": "Numbers\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\nTask 2\nType any single number in your new code chunk, then run the chunk.\n\n\n\n\n\n\nHint\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random - that's what I did!\n\n3958\n\n[1] 3958\n\n\n\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\nTask 2.1\nTry putting in another number that’s at least 4 digits long, including the commas to separate the thousands and hundreds places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n\n\nNo good there. This is because commas have an important role to play in functions, as we will see later on. For now, we’ve seen that for long numbers, we need to give them to R without any commas. (Full stops to mark decimal places are just fine; try it if you like.)\n\n\n\n\n\n\nNote\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets and commas.\n\n\nNext, let’s try doing some basic maths.\n\n\nTask 2.2\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n40 + 8\n\n[1] 48\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\nTask 2.3\nTry doing each of these things with the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\nNow, let’s say I wanted to have a bunch of different numbers to use for my analysis. In fact, I want every number between 1 and 50. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\nTask 2.4\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\nOne thing to notice here is that the indices I mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\nTask 2.5\nPrint out all the numbers 12 through 58; all of the numbers 23 through 106; and 36.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou may have tried something like this:\n\n12:58\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n[26] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58\n\n23:106\n\n [1]  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41\n[20]  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60\n[39]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79\n[58]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[77]  99 100 101 102 103 104 105 106\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. I’d actually like to have all of those numbers together. To do this, I’m going to use a function called c().\nTo use it, type the name of the function, which includes the brackets. Then, inside the brackets, put the numbers you want to put into a single vector, with different groups separated by commas.\n\nc(12:58, 23:106, 36)\n\n  [1]  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29\n [19]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [37]  48  49  50  51  52  53  54  55  56  57  58  23  24  25  26  27  28  29\n [55]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [73]  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65\n [91]  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83\n[109]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101\n[127] 102 103 104 105 106  36\n\n\n\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects (or concatenates, or combines) all of the numbers into a single series of elements, called a vector.\nActually, this isn’t a new thing; we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see the Vocab box on vectors and elements. When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing.\n\nc(12:58, 23:106, 36)[88]\n\n[1] 63\n\n\nWhat I’ve essentially asked is, “Put all of these numbers into a single vector, and then give me the 88th element in that vector.” As it turns out, the 88th element in that vector of numbers is 63.\n\n\n\n\n\n\nVocab: Vectors and Lists\n\n\n\nA vector is essentially a series of pieces of data, or elements. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nTask 2.6\nTo finish up, create a vector of every whole number between 37 and 86, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37-86) - 7\n\n[1] -56\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\nOrder of Operations\nAs you may remember from school, mathematical expressions are evaluated in a certain order. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly."
  },
  {
    "objectID": "tutorials/tutorial_01.html#characters",
    "href": "tutorials/tutorial_01.html#characters",
    "title": "Into the {tidyverse}",
    "section": "Characters",
    "text": "Characters\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\nTask 3\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\nThe placement of the quotes is very important here - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a very special sequence of letters in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nWhy have we got it here? Essentially, we asked R for the eighth element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a fifth element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do."
  },
  {
    "objectID": "tutorials/tutorial_01.html#logical",
    "href": "tutorials/tutorial_01.html#logical",
    "title": "Into the {tidyverse}",
    "section": "Logical",
    "text": "Logical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\nTask 4\nAsk R whether:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last statement above may have caused you some trouble. If you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use in just a moment. Single = also has an important and specific role to play in function arguments. For now, you just need to know that = is a special operator that doesn’t do what we wanted it to do here, and that “exactly equals” in R is ==.\n\n\n\nTask 4.1\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. It might not seem like it at the moment, but this can be staggeringly useful for selecting and filtering data that meet particular requirements, or checking our data to find problems - we’ll see how later on!"
  },
  {
    "objectID": "tutorials/tutorial_01.html#class-and-coercion",
    "href": "tutorials/tutorial_01.html#class-and-coercion",
    "title": "Into the {tidyverse}",
    "section": "Class and Coercion",
    "text": "Class and Coercion\nWith these simple examples, it may be obvious just by looking that 25 is a number and porcupine is a word. However, this isn’t always so straightforward, and there are some situations - such as data checking/cleaning, or debugging - where I might want to ask R to tell me what type of data a certain thing is. To do this, I can use another function, class(). R will simply print out, as a character, the name of the data type of whatever I put into the brackets.\n\nTask 5\nUse the class() function to get R to print the value \"numeric\".\n::: {.callout-tip collapse=“true”} #### Solution\n\n## Any numeric vector will do\nclass(216907)\n\n[1] \"numeric\"\n\n## You can also use a longer vector of numbers\n## as long as they are all numbers!\nclass(c(4:291, -1, 38.7, 100000000))\n\n[1] \"numeric\"\n\n\n:::\nYou can try the same with vectors containing logical or character data - give it a try!\n\n\nTask 6\nWhat data type does R give you if you combine numbers and characters in c()?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Again, anything will do\n\nclass(c(93, -1905, \"avocado\"))\n\n[1] \"character\"\n\n\n\n\n\nSomething interesting has happened here. Recall that atomic vectors created with c() must all have the same data type. Here, we combined two types of data: numeric and character. We didn’t get an error - instead, without warning or telling us, R quietly converted the entire vector to character type. This forcible conversion is called coersion.\n\n\n\n\n\n\nVocab: Coersion\n\n\n\nCoersion is when a piece of data is forcibly changed from one data type to another. This is sometimes intentional, but it can happen unintentionally (and without any warning or fanfare!), so is a common source of errors.\nCoersion follows a hierarchy; data types on the left can be coerced into the types further along to the right.\nlogical ==&gt; integer ==&gt; double (numeric) ==&gt; character\nAs we saw previously, you can check the data type of a vector with class(), or check if it is a particular type (and so receive a logical vector in response) with the is.*() family of functions. (The * notation refers to a placeholder for many different options, such as is.numeric, is.character, etc.)\nYou can similarly (try to) coerce a vector into a particular data type with the as.*() family of functions.\n\n\nThis explains why our vector from Task 6 was a character vector - since the vector contained at least one character element, everything else in the vector was coerced to the same type. This can cause problems because R can sometimes convert numerial data into characters, even though they still look like numbers.\nEven though we can do mathematical operations on numbers, we can’t do them on characters; it should be clear that asking e.g. what is \"tomato\" - 7 is nonsense. However, this is the case even if all of the data are numerals! For example:\n\n## No problem here; all numbers\nc(2:20, 45) - 7\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 38\n\n## Doesn't work\nc(2:20, \"45\") - 7\n\nError in c(2:20, \"45\") - 7: non-numeric argument to binary operator\n\n\nEven though “45” looks like a number, because it’s in quotes, R thinks that it’s a character, and will refuse to do the calculation, in the same way that it would refuse to do it with “tomato”."
  },
  {
    "objectID": "tutorials/tutorial_01.html#objects",
    "href": "tutorials/tutorial_01.html#objects",
    "title": "Into the {tidyverse}",
    "section": "Objects",
    "text": "Objects\nR is called a “language” for a reason - it is actually a language, or a way of talking to computers to ask it to do things for you. Like any language, learning to “speak” R takes practice and repetition. In this section, we’ll cover the basic “grammar” of R, including some important ideas about how R understands what you ask it to do. However, just like any language you learn, the best way to really understand what each of these things do is to try them out for yourself, make mistakes, and keep using them until they’re familiar.\nIn a similar way that the basic unit of English is the word1, the basic unit of the R programming language is the object. This section will explore the basics of what an object is and some of their key features in R.\n\n\n\n\n\n\nVocab: Objects\n\n\n\nObjects are the basic elements that R is built around - the equivalent of words. An “object” in R is any bit of information that is stored with a particular name. Objects can hold anything, from a single number or word to huge datasets with thousands of data points or complex graphs.\n\n\n\nCreating an Object\nLet’s start by creating a new object. Here we’ll also formally meet a very important piece of R code: the assignment operator &lt;-.\nNote: At the moment your Environment should be empty. As a reminder, Environment is by default the first (leftmost) tab in one of your four main windows in RStudio. If you have a look at it just says, “Environment is empty”, we’re all good! If for some reason it isn’t, click the broom icon to clear everything from your environment before you get started. Managing your Environment is an important skill that we’ll come back to once we’ve got comfortable working with objects.\nFirst, let’s look at the foundational structure of almost everything you will do in R:\nobject &lt;- instructions\nYou can read this code as something like, “The object object is created from (&lt;-) some instructions.” Objects can be named almost anything (although see Naming, below); the object name is just a label so you, the person using R, can find, refer to, and use the information you need. The special operator &lt;-, often called the “assignment operator”, has single job: to assign output to names, or in other words, to create objects. You should always and only use &lt;- to create objects; it’s possible, to also use single equals =, but I strongly advise you not to!\nSo, what about the instructions in this pseudo-code above? These instructions can be very simple: a single number or word, or hundreds of lines of code, or anything in between. They’re simply any value command that produces some output. Whatever output the instructions produce will be “saved”, or assigned, to the name in object.\n\n\n\n\n\n\nNaming in R\n\n\n\nCOMING SOON\n\n\n\n\nTask 7\nUsing the object &lt;- instructions structure, create a new object called current_year that contains (as you might expect) the current year.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year &lt;- 2023\n\n\n\n\nLet’s have a look at that command. On the left side I’ve written the name I want my new object to have, which I’ve called current_year. (I could have called it anything, like the_first_example_of_an_object_InThisSection.so.far or exobjt7sol1 or anything else that follows R’s naming conventions; but it’s a good idea to name your objects something useful, brief, and obvious, so you can remember what they contain.) Then, I’ve written the assignment operator &lt;- to assign whatever comes after it to the object label current_year. Finally, I’ve written instructions for what I want this object to contain: in this case, just the number 2023.\nMake sure you do this yourself in your own document, even if you’ve looked at the solution rather than trying it for yourself first. Once you’ve typed the command, there’s a final, critical step to actually create the object: you have to run the command in order for it to take effect. As a reminder, you can do this by clicking the green ▶️ button in the upper right corner of the code chunk, or by pressing Ctrl/Cmd + Enter when your cursor is blinking on the same line as the code you want to run.\nAssuming your code is valid, you should see the green bar appear along the left-hand side of the code chunk, but you might notice that there’s no printout that appears under the code chunk, as there was previously. In fact, if the code ran successfully, it might look like nothing happened at all! To find out what did happen, have a look again in your Environment pane. You should now see a new section, “Values”, and underneath the name of your new object and what it contains. Success!\n\n\nCalling an Object\nFor any object, from the most simple to the most complex, you can always see what’s in it by calling the object. This simply means that you type the name of the object and run it. R will print out whatever is stored in the object.\n\nTask 8\nCall the current_year object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year\n\n[1] 2023\n\n\n\n\n\nThis output looks just like what we saw earlier in Task 1, when we just asked R to print out a number for us. R tells you that there is one value in the current_year object, which is the number 2023. In essence, the object name current_year is just a label for the number it contains.\n\n\n\n\n\n\nImportant: Creating vs Calling\n\n\n\nThese two actions are the essential basis of everything you will do in R. All of your code will, at base, either create an object, or call an object. (Changing an existing object, as we’ll see shortly, is the exact same procedure as creating one from scratch.)\nWhen you successfully create an object using the assignment operator (&lt;-), the object is created but is not printed out. This is because R always does only and exactly what you ask it to do, and using the assignment operator only tells R to assign something to an object, not to print it out.\nWhen you call an object, the current contents of that object are printed out, but that object is not changed - you only reproduce a copy of its contents for review. To create or change an object, you must use the assignment operator to assign the output to a new (or existing) object name.\n\n\nLet’s make all of this a bit more concrete by seeing how we can use objects effectively.\n\n\n\nUsing Objects\n\nTask 9\nCreate an object called birth_year that contains the year you were born.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbirth_year &lt;- 1988\n\n\n\n\nI have used my own birth year here, but you should replace the number with your own birth year. Again, when you type this command and run the command, it will seem like nothing happens. However, you will be able to see the new object in your Environment.\nNow we have two objects, current_year and birth_year. Since both of these objects contain a number, we can use them as if they were numbers.\n\n\nTask 10\nUsing these two objects, get R to print out your own age in years.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year - birth_year\n\n[1] 35\n\n\nThis line of code subtracts birth_year from current_year. Because these objects contain numbers, R treats them as if they were numbers, and outputs the difference between them.\n\n\n\nWe can also do any other mathematical operations on objects that contain numbers.\n\n\nTask 11\nWrite some mathematical equations using the current_year object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year*5\n\n[1] 10115\n\ncurrent_year+5\n\n[1] 2028\n\ncurrent_year^2 # to the power of 2\n\n[1] 4092529\n\n\n\n\n\nThis is all well and good, but there’s no real benefit to doing this with an object called current_year, rather than just using the number 2023. Instead, we can take advantage of objects by storing multiple pieces of information in a single object.\n\n\nTask 12\nUse the code below as a template to create an ages object, replacing the numbers with the ages of yourself and all your family members, in whatever order you like.\n\nages &lt;- c(35, 29, 64, 89, 2)\n\nAgain, when I run this command, a new object appears in my Environment, called ages. This one looks a bit different than the other two, though. In Environment, I can see that this object contains numbers (“num”); that there are four of them ([1:5]); and that those numbers are 35, 29, 64, 89, and 2. This new object is another vector, as we saw earlier. This particular object is a vector of length 5 - that is, it has five elements in it.\n\n\nTask 13\nAsk R for the class of the ages object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nclass(ages)\n\n[1] \"numeric\"\n\n\n\n\n\nThis might not have been what you expected, but remember, ages (importantly, without quote marks!) is the name of an object. To find out what kind of data it is, R looks at what that object contains, not at the name of the object itself. We already saw that ages contains only numbers; so, R tells us that it’s a numeric vector.\nOne more example to emphasize this point, because it’s often a source of confusion when starting out with R. If we want to ask R the class of the word “ages”, we would need to put it in quotes, and we’d get a different answer:\n\nclass(\"ages\")\n\n[1] \"character\"\n\n\nThe key thing here is that objects have the class of the data they contain, and are not character data; and whenever you want to use an object, you must not use quotation marks. On the other hand, if you want to input character data into R, you must use quotation marks. Otherwise, R will look for an object or function with that name, which will likely produce a “cannot find object” error.\nSo, if the object ages is just a convenient name for a vector of numbers, what happens if we try to do the same maths we did before? For instance, I might want to calculate the birth year of each of my family members, using their ages. To do this, I have to subtract each of their ages from the current year. I could do this one at a time - or all at once using my ages object.\n\n\nTask 14\nCalculate each of your family members’ birth years using your ages object, and save the birth years you’ve just calculated in an object called birth_year.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbirth_year &lt;- current_year - ages\n\n\n\n\nBecause we’ve used the assignment operator, R doesn’t print out the years. Instead, the output of our calculation is saved as the object birth_year. Hmm - didn’t we already have an object called birth_year, though? What happened to it?\n\n\n\n\n\n\nImportant: Overwriting Objects\n\n\n\nYou might notice that we already had an object called birth_year that we created above. R, again, does only and exactly what you ask it to do. Unlike, say, a word processer, that will give you a warning if you try to save two documents in the same folder with the same name, R won’t ask you if you’re sure you want to overwrite an existing object with new information - it will just do it. If you have a look in your Environment, you will see that the previous version of birth_year, containing only your birth year, has been quietly replaced with the new one containing the vector of birth years you just created.\nThis can be a good thing, because you can easily update the information stored in an object with changes, edits, or new information. However, it also means that you can overwrite or replace data when you don’t want to, if you use the same object name.\nThis is why it is so important to keep track of all of the commands and changes you make to your data. If you accidentally replace your dataset with, say, a single word or number with an error in your code, you can easily retrace your steps and avoid redoing work.\nIf you are interested in understanding this process of assigning and replacing the contents of objects better, the aside below explains it in more depth.\n\n\n\n\n\n\nCan you actually change an object?\n\n\n\n\n\nThink of objects as boxes. The names of the objects are only labels, and you can store anything you like inside them. However, unlike in the physical world, objects in R cannot truly change. You can put stuff in and take stuff out, and that’s pretty much it. Unlike boxes, though, when you take stuff out of objects, you only take out a copy of its contents. The original contents of the box remain intact. Of course, you can do whatever you want (within limits) to the stuff once you’ve taken it out of the box, but you are only modifying the copy. The key thing to remember is that unless you put that modified stuff into a box, R will forget about it as soon as it’s done with it. In other words, if you want to “save” any changes you make, you must assign them to an object in order to keep them.\nNow, as you probably know, you can call your boxes (objects) whatever you want (again, within certain limits). This means that that you can call the new box the same as the old one, as we saw with birth_year above. When that happens, R basically takes the label off the old box, pastes it on the new one, and burns the old box. So even though some operations in R may look like they change objects, what’s actually happening is that R copies their content, modifies it, stores the result in a different object, puts the same label on it, and discards the original object. Understanding this mechanism will make things much easier!\nPutting the above into practice, this is how you “change” an R object:\n\n# put 1 into an object (box) called a\na &lt;- 1\n\n# copy the content of a, add 1 to it and store it in an object b\nb &lt;- a + 1\n\n# copy what's inside b and put it in a new object called a\n# discarding (\"overwriting\") the old object a\na &lt;- b\n\n# now see what's inside of a\n# (by copying its content and pasting it in the console)\na\n\n[1] 2\n\n\nOf course, you can just cut out the middleman (creating an object b). So to increment a by another 1, we can do:\n\na &lt;- a + 1\n\na\n\n[1] 3\n\n\n\n\n\n\n\nWe will talk further about using scripts and writing multiple commands below; but first, we’ll need to have a look at a very important type of object in R: the function."
  },
  {
    "objectID": "tutorials/tutorial_01.html#functions",
    "href": "tutorials/tutorial_01.html#functions",
    "title": "Into the {tidyverse}",
    "section": "Functions",
    "text": "Functions\nFunctions are like verbs in the R language - they’re how R does anything. Functions may not look exactly like verbs in the language you speak because they have a different syntax (i.e., a different order and grammar), but they work in a very similar way. In order to use them, you need to learn how to “translate” the command you want to give R into a verb (function) it can understand.\n\nFun with Functions\nIn this section, we’ll go through a step-by-step worked example of puzzling out how to use a function.\nLet’s look at an example of how functions are like verbs, drawing on some basic linguistics. We’ll start with the English command, “Round the number 7.3928 to two decimal places.” If we want R to do this for us, we have to write this command in a way that R can understand. First, we need to know what function corresponds to the English verb “round” - that is, what function will do the same action that we want R to perform. We’re lucky in this case: the function in R is also called round(). (See the box below for more on how to find the function you want.)\nWe know that we’re looking at a function in R because functions always have a name followed by brackets. That is, they always have the general form function_name(). Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.\n\n\nTask 15\nTry running the round() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround()\n\nError in eval(expr, envir, enclos): 0 arguments passed to 'round' which requires 1 or 2 arguments\n\n\n\n\n\nUnsurprisingly, R has given us an error. This is an informative error, though - that is, the error gives of some sort of intelligible clue about what’s gone wrong. Namely, it tells us that round() can’t just work without additional information (i.e. “required arguments”). Imagine, for instance, if you wanted a friend or colleague to round 7.3928 to two decimal places, and in order to ask them to do that, you just shouted “ROUND!” at them. Just like that person would would, R has objected to this, telling you that it needs more information in order to do what you’ve asked it to.\nOur original command, “Round the number 7.3928 to two decimal places”, has two more important pieces of information that we need to tell R: what number we want to round (7.3928) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let’s look at the help documentation.\n\n\n\n\n\n\nHelp Documentation\n\n\n\nHelp documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it’s a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running ?function_name or help(function_name) in the console, or by clicking on the “Help” tab in the Files section of RStudio and using the Find box to search for the function.\n\n\n\nTask 16\nPull up the help documentation for round() in RStudio.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n?round\n\nstarting httpd help server ... done\n\n\n\n\n\nThe first section, “Description”, varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function including in this document, we can see that we have a useful description of round() that tells us that it rounds numbers (yay!) to a certain number of decimal places. That’s exactly what we want, so how do we use it?\nLet’s scroll down to “Usage”, which gives examples of what the function looks like. You can see that the basic structure of this function is round(x, digits = 0). It seems like we need to add some more information in the brackets of our function - but how do we interpret x and digits = 0?\n\n\n\nArguments\nThe information inside a function’s brackets to give it the information it needs to work are called arguments. Each argument in a function is separated by a comma, so we can see from round(x, digits = 0) that the round() function can take two arguments. How many arguments a function has depends on the function; some (like Sys.Date()) don’t need any arguments to run. One of the most useful parts of a function’s help documentation is the “Arguments” section, which tells you what each of the function’s arguments are and how to use them.\nThere are two main types of arguments: named and unnamed arguments. Conveniently, the arguments of round() give us one example of each.\n\nUnnamed Arguments\nThe first argument to round() is simply x. Just like in maths, x is a placeholder for some number or numbers (a “numeric vector”, which should sound familiar now) that you want to pass to the function. This is common notation in many functions: x, often the first argument in a function, is often the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that’s what we should replace with x.\n\n\nNamed Arguments\nThe second argument of round() is a named argument, digits = 0. You can think of named arguments like settings that change the way a function works, often with only certain allowable values. Here we can see that the name of the argument is digits; the name before the = sign tells R which setting we want to change.\nThe help documentation tells us that digits should be an “integer indicating the number of decimal places…to be used.” We can also see in “Usage” that this argument has a default value, digits = 0. That means that if we don’t explicitly include the argument digits when we use the function, by default the round() function will round the number you give it to 0 decimal places. Named arguments frequently, but not always, have a default, and it’s important to check so the function doesn’t quietly do something unexpected.\nDefault values of arguments are really useful, because the default is usually the most frequently used setting. It means you don’t have to specify every single aspect of a function every time you use it, as long as you want the function to work that way! In our case, we actually wanted round() to round to two decimal places, not 0. So, in our command, we should change the setting from the default, 0, to 2.\n\n\n\nUsing Functions\nNow that we know what both of these arguments mean, we can change them to actually translate the English sentence “Round the number 7.3928 to two decimal places” into a command that R can work with. We’ll explicitly write out each argument so we know what they are doing.\n\nTask 17\nUse the round() function to round 7.3928 to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround(7.3928, digits = 2)\n\n[1] 7.39\n\n\n\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\n\nIf you want to, you can achieve the same result by changing the order of the arguments. Because we have written the names of both arguments, R can still do what we want it to do:\n\nround(digits = 2, x = 7.3928)\n\n[1] 7.39\n\n\nWe can also, to some degree, drop the names of the arguments, as long as R can still understand what we’re trying to do:\n\nround(digits = 2, 7.3928)\n\n[1] 7.39\n\n\nHere I left out the x =. R can still understand this because round() only takes two arguments, and we explicitly told it what value belongs to digits, so it assumes the second number must be x.\n\nround(7.3928, 2)\n\n[1] 7.39\n\n\nThis time I dropped both argument names. R can still understand this because when you don’t specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 7.3928 to x and 2 to digits, which is what we wanted.\nAs I’ve become more proficient at writing code, I find that I’m more insistent on naming arguments, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That’s because Future Me hasn’t been staring at this code for the last five hours, and verbose code is much, much easier to read! So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:\n\nround(2, 7.3928)\n\n[1] 2\n\n\nHere, since we didn’t specify, R assumed that 2 was the number we wanted to round. This isn’t what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.\n\n\n\n\nPassing Multiple Values to Arguments\nA last important aspect of using functions is to remember that each argument in a function can only take a single object as input. For example, we saw above that we put the single value 7.3928 into the x argument of round(). But what if we wanted to round more than one number? We don’t want to have to write a new round() command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:\n\nround(7.3928, 2)\n\n[1] 7.39\n\n## ughhhh\nround(59.54, 2)\n\n[1] 59.54\n\n## noooooo :(\nround(0.198, 2)\n\n[1] 0.2\n\n## thanks I hate it\n\nSo what happens if we try to put all of those numbers into round()? We might first try this:\n\nround(7.3928, 59.54, 0.198, 2)\n\nError in eval(expr, envir, enclos): 4 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nOnce again, R tells us that this doesn’t work by throwing an error. R has tried to do what we wanted, but the round() function only allows a max of two arguments, and we’ve given it four. Behind the scenes, R has tried to run round(x = 7.3928, digits = 59.54... and can’t proceed from there because it doesn’t know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first x argument together. If only there was a way to concatenate them together…\nYou may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a single object, and then pass that object to round() as the x argument. We already saw that we can combine any number of things together into a single vector using the c() function.\n\n\nTask 18\nUse c() to create a new object containing the three numbers 7.3928, 59.54, and 0.198, then use round() to round them to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nnumbers &lt;- c(7.3928, 59.54, 0.198)\n\nround(numbers, digits = 2)\n\n[1]  7.39 59.54  0.20\n\n\n\n\n\nPerfect! This time, all three numbers together went into the x argument.\nWe could also simplify this even further by removing the intermediate step of creating the numbers object.\n\n\nTask 19\nUse c() and round() together in a single command to get the same output as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1]  7.39 59.54  0.20\n\n\n\n\n\nHere we can see a good example of a function inside another function. You can stack, or “nest”, functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it’s doing. (In the next tutorial, we’ll introduce a popular alternative to writing nested code: the pipe operator.)\nThat’s looking like some proper R code! Very nicely done.\n\n\n\n\n\n\nHelp Documentation, Revisited\n\n\n\nBefore we leave the round() function altogether, let’s take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the “Details” section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn’t doing what you expect it to, this is a good place to look for an explanation.\nFinally, at the end of the documentation you can find the “Examples” section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the “Run examples” link, which will run the code in the Examples section for you so you can see what the function will do.\n\n\n\n\n\nChoosing Functions\nJust like learning a new language, when you start out in R your “vocabulary” of functions will be small, and you’ll only be able to “speak” a small number of commands from memory. As you work more in R and practice using more functions, your vocabulary will grow. However, if you are trying to do something new or unusual in R, finding the right function that does what you want it to do often takes some work and research. This is just like having to look up a new word or phrase in the dictionary if you don’t know how to say something in the language you’re learning.\nIf you don’t know what function to use, your first step can be to Google it with a search like “function to [whatever you want to do] in R”, which will often put you on the right track! (R’s internal help search is often most useful when you already know the name of the function you want to use.)"
  },
  {
    "objectID": "tutorials/tutorial_01.html#packages",
    "href": "tutorials/tutorial_01.html#packages",
    "title": "Into the {tidyverse}",
    "section": "Packages",
    "text": "Packages\nIn this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nVocabulary: Package\n\n\n\nA package is a bundle of (usually, but not necessarily!) multiple functions. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\n\n\n\nRounding, Revisited\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do2.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\nTask 20\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\n\n\nInstalling Packages\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\nTask 21\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\n\ninstall.packages(\"weights\")\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\nTask 22\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\n\nLoading Packages\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\nTask 23\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\nLoading required package: Hmisc\n\n\nLoading required package: lattice\n\n\nLoading required package: survival\n\n\nLoading required package: Formula\n\n\nLoading required package: ggplot2\n\n\nWarning: package 'ggplot2' was built under R version 4.2.2\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\nTask 24\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1] \"7.39\"  \"59.54\" \".20\"  \n\n\n\n\n\nSuccess!\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1] \"7.39\"  \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type. You can do it either way - it’s up to you!"
  },
  {
    "objectID": "tutorials/tutorial_01.html#footnotes",
    "href": "tutorials/tutorial_01.html#footnotes",
    "title": "Into the {tidyverse}",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs a linguist I have to note, one, words don’t exist, and two, the closest linguistic term for what an object is is probably “lexeme”. “Word” will get you in the right vicinity, though, conceptually. If you’d like to dive down this rabbit hole (rabbit-hole?) this Crash Course video on morphology is a good place to start, but don’t forget to come back and keep working on R!↩︎\nYou may not find any that you’d quite like to use - in that case, of course, you can code something new! Oh, the functions you’ll write…↩︎"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html",
    "href": "tutorials/01_fundRmentals/tutorial_01.html",
    "title": "Into the {tidyverse}",
    "section": "",
    "text": "Before we jump headfirst data wrangling, we first need to practice a core idea that underlies how many of these functions work.\nMany of the functions and operations we will encounter in R rely on logical assertions. A logical assertion is a statement that can be either true or false (in R, of course, TRUE or FALSE). Let’s look at an example first.\nTo begin, let’s ask R whether 10 is greater than 5:\n\n10 &gt; 5\n\n[1] TRUE\n\n\nR sensibly returns TRUE. Essentially, we are making a claim (10 is greater than 5) and R tells us whether that claim, or assertion, is true or not. Similarly, we can assert that 5 is greater than 10:\n\n5 &gt; 10\n\n[1] FALSE\n\n\nAnd R again, very sensibly, tells us that we’re wrong (FALSE). So far so good!\n\n\nIn the next step, we’re going to meet a foundational piece of the way R works: the vector. Vectors are essentially one-dimensional lists of pieces of information. What this means is that instead of asking R about one number at a time, we could po"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#logical-assertions",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#logical-assertions",
    "title": "Into the {tidyverse}",
    "section": "",
    "text": "Before we jump headfirst data wrangling, we first need to practice a core idea that underlies how many of these functions work.\nMany of the functions and operations we will encounter in R rely on logical assertions. A logical assertion is a statement that can be either true or false (in R, of course, TRUE or FALSE). Let’s look at an example first.\nTo begin, let’s ask R whether 10 is greater than 5:\n\n10 &gt; 5\n\n[1] TRUE\n\n\nR sensibly returns TRUE. Essentially, we are making a claim (10 is greater than 5) and R tells us whether that claim, or assertion, is true or not. Similarly, we can assert that 5 is greater than 10:\n\n5 &gt; 10\n\n[1] FALSE\n\n\nAnd R again, very sensibly, tells us that we’re wrong (FALSE). So far so good!\n\n\nIn the next step, we’re going to meet a foundational piece of the way R works: the vector. Vectors are essentially one-dimensional lists of pieces of information. What this means is that instead of asking R about one number at a time, we could po"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#the-console",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#the-console",
    "title": "Into the {tidyverse}",
    "section": "The Console",
    "text": "The Console\nThe Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nThat sounds pretty intense, so let’s get a couple of things straight right away. You will, inevitably, make typos and mistakes using R. You will write commands that make sense to you that R doesn’t understand; you will write commands that don’t make sense to you, that R does understand; and you will see all kinds of exciting errors, warning messages, and - once we get to the fun stuff - beautiful plots and results for our studies. So, right now, let’s get over the fear of doing something “wrong” in R. You will do many, many things wrong, just like someone saying their first few words in a new language. Who cares? You’re learning.\n\nTask 1\nType literally any gibberish, words, keysmashes etc. into the Console and press Enter.\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nThis is fun! I'm having fun!\n\nError: &lt;text&gt;:2:6: unexpected symbol\n1: ## Words!\n2: This is\n        ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\nWell, that went about as expected!\nLuckily, R has a very short memory (that is to say, no memory to speak of) and is always ready to do the next thing I ask straightaway, even if it’s nonsense - which is lucky for me, I can assure you.\nIf you haven’t tried this yet, and the cursor in the Console is just blinking balefully at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There are two important things that we are learning here:\n\nTo ask R to do something - that is, to “run” or “execute” the commands you write - you must write them out in the Console and press Enter.\nEventually, inevitably, something that you type WILL produce an error. This is no cause for panic, fear, or alarm, so get it out of the way now!\n\nFrom our gleeful keysmashing above, you will have seen that aslavb;lj aew aljvb, This is fun! I'm having fun!, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\nGlossoRlia\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nWhat I am trying to tackle right away is the idea that R is scary or incomprehensible. R is just a system for doing tasks that computers are great at - sifting through thousands of data points in a second, making systematic changes to huge datasets, creating complex mathematical models, drawing elaborate plots. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But although R can do maths a lot quicker than a human, it can’t design studies, or critically evaluate an argument, or appreciate a well-chosen emoji, or have sudden bursts of inspiration, or use the results it produces to improve society. Ultimately it’s just a tool to help you achieve your goals.\nRight, enough philosophizing. Let’s prove the point by jumping into R and learning about how it works!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#numbers",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#numbers",
    "title": "Into the {tidyverse}",
    "section": "Numbers",
    "text": "Numbers\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\nTask 2\nType any single number in your new code chunk, then run the chunk.\n\n\n\n\n\n\nHint\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random - that's what I did!\n\n3958\n\n[1] 3958\n\n\n\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\nTask 2.1\nTry putting in another number that’s at least 4 digits long, including the commas to separate the thousands and hundreds places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n\n\nNo good there. This is because commas have an important role to play in functions, as we will see later on. For now, we’ve seen that for long numbers, we need to give them to R without any commas. (Full stops to mark decimal places are just fine; try it if you like.)\n\n\n\n\n\n\nNote\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets and commas.\n\n\nNext, let’s try doing some basic maths.\n\n\nTask 2.2\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n40 + 8\n\n[1] 48\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\nTask 2.3\nTry doing each of these things with the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\nNow, let’s say I wanted to have a bunch of different numbers to use for my analysis. In fact, I want every number between 1 and 50. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\nTask 2.4\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\nOne thing to notice here is that the indices I mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\nTask 2.5\nPrint out all the numbers 12 through 58; all of the numbers 23 through 106; and 36.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou may have tried something like this:\n\n12:58\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n[26] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58\n\n23:106\n\n [1]  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41\n[20]  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60\n[39]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79\n[58]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[77]  99 100 101 102 103 104 105 106\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. I’d actually like to have all of those numbers together. To do this, I’m going to use a function called c().\nTo use it, type the name of the function, which includes the brackets. Then, inside the brackets, put the numbers you want to put into a single vector, with different groups separated by commas.\n\nc(12:58, 23:106, 36)\n\n  [1]  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29\n [19]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [37]  48  49  50  51  52  53  54  55  56  57  58  23  24  25  26  27  28  29\n [55]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [73]  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65\n [91]  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83\n[109]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101\n[127] 102 103 104 105 106  36\n\n\n\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects (or concatenates, or combines) all of the numbers into a single series of elements, called a vector.\nActually, this isn’t a new thing; we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see the Vocab box on vectors and elements. When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing.\n\nc(12:58, 23:106, 36)[88]\n\n[1] 63\n\n\nWhat I’ve essentially asked is, “Put all of these numbers into a single vector, and then give me the 88th element in that vector.” As it turns out, the 88th element in that vector of numbers is 63.\n\n\n\n\n\n\nVocab: Vectors and Lists\n\n\n\nA vector is essentially a series of pieces of data, or elements. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nTask 2.6\nTo finish up, create a vector of every whole number between 37 and 86, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37-86) - 7\n\n[1] -56\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\nOrder of Operations\nAs you may remember from school, mathematical expressions are evaluated in a certain order. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly."
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#characters",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#characters",
    "title": "Into the {tidyverse}",
    "section": "Characters",
    "text": "Characters\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\nTask 3\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\nThe placement of the quotes is very important here - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a very special sequence of letters in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nWhy have we got it here? Essentially, we asked R for the eighth element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a fifth element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do."
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#logical",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#logical",
    "title": "Into the {tidyverse}",
    "section": "Logical",
    "text": "Logical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\nTask 4\nAsk R whether:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last statement above may have caused you some trouble. If you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use in just a moment. Single = also has an important and specific role to play in function arguments. For now, you just need to know that = is a special operator that doesn’t do what we wanted it to do here, and that “exactly equals” in R is ==.\n\n\n\nTask 4.1\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. It might not seem like it at the moment, but this can be staggeringly useful for selecting and filtering data that meet particular requirements, or checking our data to find problems - we’ll see how later on!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#class-and-coercion",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#class-and-coercion",
    "title": "Into the {tidyverse}",
    "section": "Class and Coercion",
    "text": "Class and Coercion\nWith these simple examples, it may be obvious just by looking that 25 is a number and porcupine is a word. However, this isn’t always so straightforward, and there are some situations - such as data checking/cleaning, or debugging - where I might want to ask R to tell me what type of data a certain thing is. To do this, I can use another function, class(). R will simply print out, as a character, the name of the data type of whatever I put into the brackets.\n\nTask 5\nUse the class() function to get R to print the value \"numeric\".\n::: {.callout-tip collapse=“true”} #### Solution\n\n## Any numeric vector will do\nclass(216907)\n\n[1] \"numeric\"\n\n## You can also use a longer vector of numbers\n## as long as they are all numbers!\nclass(c(4:291, -1, 38.7, 100000000))\n\n[1] \"numeric\"\n\n\n:::\nYou can try the same with vectors containing logical or character data - give it a try!\n\n\nTask 6\nWhat data type does R give you if you combine numbers and characters in c()?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Again, anything will do\n\nclass(c(93, -1905, \"avocado\"))\n\n[1] \"character\"\n\n\n\n\n\nSomething interesting has happened here. Recall that atomic vectors created with c() must all have the same data type. Here, we combined two types of data: numeric and character. We didn’t get an error - instead, without warning or telling us, R quietly converted the entire vector to character type. This forcible conversion is called coersion.\n\n\n\n\n\n\nVocab: Coersion\n\n\n\nCoersion is when a piece of data is forcibly changed from one data type to another. This is sometimes intentional, but it can happen unintentionally (and without any warning or fanfare!), so is a common source of errors.\nCoersion follows a hierarchy; data types on the left can be coerced into the types further along to the right.\nlogical ==&gt; integer ==&gt; double (numeric) ==&gt; character\nAs we saw previously, you can check the data type of a vector with class(), or check if it is a particular type (and so receive a logical vector in response) with the is.*() family of functions. (The * notation refers to a placeholder for many different options, such as is.numeric, is.character, etc.)\nYou can similarly (try to) coerce a vector into a particular data type with the as.*() family of functions.\n\n\nThis explains why our vector from Task 6 was a character vector - since the vector contained at least one character element, everything else in the vector was coerced to the same type. This can cause problems because R can sometimes convert numerial data into characters, even though they still look like numbers.\nEven though we can do mathematical operations on numbers, we can’t do them on characters; it should be clear that asking e.g. what is \"tomato\" - 7 is nonsense. However, this is the case even if all of the data are numerals! For example:\n\n## No problem here; all numbers\nc(2:20, 45) - 7\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 38\n\n## Doesn't work\nc(2:20, \"45\") - 7\n\nError in c(2:20, \"45\") - 7: non-numeric argument to binary operator\n\n\nEven though “45” looks like a number, because it’s in quotes, R thinks that it’s a character, and will refuse to do the calculation, in the same way that it would refuse to do it with “tomato”."
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#objects",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#objects",
    "title": "Into the {tidyverse}",
    "section": "Objects",
    "text": "Objects\nR is called a “language” for a reason - it is actually a language, or a way of talking to computers to ask it to do things for you. Like any language, learning to “speak” R takes practice and repetition. In this section, we’ll cover the basic “grammar” of R, including some important ideas about how R understands what you ask it to do. However, just like any language you learn, the best way to really understand what each of these things do is to try them out for yourself, make mistakes, and keep using them until they’re familiar.\nIn a similar way that the basic unit of English is the word1, the basic unit of the R programming language is the object. This section will explore the basics of what an object is and some of their key features in R.\n\n\n\n\n\n\nVocab: Objects\n\n\n\nObjects are the basic elements that R is built around - the equivalent of words. An “object” in R is any bit of information that is stored with a particular name. Objects can hold anything, from a single number or word to huge datasets with thousands of data points or complex graphs.\n\n\n\nCreating an Object\nLet’s start by creating a new object. Here we’ll also formally meet a very important piece of R code: the assignment operator &lt;-.\nNote: At the moment your Environment should be empty. As a reminder, Environment is by default the first (leftmost) tab in one of your four main windows in RStudio. If you have a look at it just says, “Environment is empty”, we’re all good! If for some reason it isn’t, click the broom icon to clear everything from your environment before you get started. Managing your Environment is an important skill that we’ll come back to once we’ve got comfortable working with objects.\nFirst, let’s look at the foundational structure of almost everything you will do in R:\nobject &lt;- instructions\nYou can read this code as something like, “The object object is created from (&lt;-) some instructions.” Objects can be named almost anything (although see Naming, below); the object name is just a label so you, the person using R, can find, refer to, and use the information you need. The special operator &lt;-, often called the “assignment operator”, has single job: to assign output to names, or in other words, to create objects. You should always and only use &lt;- to create objects; it’s possible, to also use single equals =, but I strongly advise you not to!\nSo, what about the instructions in this pseudo-code above? These instructions can be very simple: a single number or word, or hundreds of lines of code, or anything in between. They’re simply any value command that produces some output. Whatever output the instructions produce will be “saved”, or assigned, to the name in object.\n\n\n\n\n\n\nNaming in R\n\n\n\nCOMING SOON\n\n\n\n\nTask 7\nUsing the object &lt;- instructions structure, create a new object called current_year that contains (as you might expect) the current year.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year &lt;- 2023\n\n\n\n\nLet’s have a look at that command. On the left side I’ve written the name I want my new object to have, which I’ve called current_year. (I could have called it anything, like the_first_example_of_an_object_InThisSection.so.far or exobjt7sol1 or anything else that follows R’s naming conventions; but it’s a good idea to name your objects something useful, brief, and obvious, so you can remember what they contain.) Then, I’ve written the assignment operator &lt;- to assign whatever comes after it to the object label current_year. Finally, I’ve written instructions for what I want this object to contain: in this case, just the number 2023.\nMake sure you do this yourself in your own document, even if you’ve looked at the solution rather than trying it for yourself first. Once you’ve typed the command, there’s a final, critical step to actually create the object: you have to run the command in order for it to take effect. As a reminder, you can do this by clicking the green ▶️ button in the upper right corner of the code chunk, or by pressing Ctrl/Cmd + Enter when your cursor is blinking on the same line as the code you want to run.\nAssuming your code is valid, you should see the green bar appear along the left-hand side of the code chunk, but you might notice that there’s no printout that appears under the code chunk, as there was previously. In fact, if the code ran successfully, it might look like nothing happened at all! To find out what did happen, have a look again in your Environment pane. You should now see a new section, “Values”, and underneath the name of your new object and what it contains. Success!\n\n\nCalling an Object\nFor any object, from the most simple to the most complex, you can always see what’s in it by calling the object. This simply means that you type the name of the object and run it. R will print out whatever is stored in the object.\n\nTask 8\nCall the current_year object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year\n\n[1] 2023\n\n\n\n\n\nThis output looks just like what we saw earlier in Task 1, when we just asked R to print out a number for us. R tells you that there is one value in the current_year object, which is the number 2023. In essence, the object name current_year is just a label for the number it contains.\n\n\n\n\n\n\nImportant: Creating vs Calling\n\n\n\nThese two actions are the essential basis of everything you will do in R. All of your code will, at base, either create an object, or call an object. (Changing an existing object, as we’ll see shortly, is the exact same procedure as creating one from scratch.)\nWhen you successfully create an object using the assignment operator (&lt;-), the object is created but is not printed out. This is because R always does only and exactly what you ask it to do, and using the assignment operator only tells R to assign something to an object, not to print it out.\nWhen you call an object, the current contents of that object are printed out, but that object is not changed - you only reproduce a copy of its contents for review. To create or change an object, you must use the assignment operator to assign the output to a new (or existing) object name.\n\n\nLet’s make all of this a bit more concrete by seeing how we can use objects effectively.\n\n\n\nUsing Objects\n\nTask 9\nCreate an object called birth_year that contains the year you were born.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbirth_year &lt;- 1988\n\n\n\n\nI have used my own birth year here, but you should replace the number with your own birth year. Again, when you type this command and run the command, it will seem like nothing happens. However, you will be able to see the new object in your Environment.\nNow we have two objects, current_year and birth_year. Since both of these objects contain a number, we can use them as if they were numbers.\n\n\nTask 10\nUsing these two objects, get R to print out your own age in years.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year - birth_year\n\n[1] 35\n\n\nThis line of code subtracts birth_year from current_year. Because these objects contain numbers, R treats them as if they were numbers, and outputs the difference between them.\n\n\n\nWe can also do any other mathematical operations on objects that contain numbers.\n\n\nTask 11\nWrite some mathematical equations using the current_year object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ncurrent_year*5\n\n[1] 10115\n\ncurrent_year+5\n\n[1] 2028\n\ncurrent_year^2 # to the power of 2\n\n[1] 4092529\n\n\n\n\n\nThis is all well and good, but there’s no real benefit to doing this with an object called current_year, rather than just using the number 2023. Instead, we can take advantage of objects by storing multiple pieces of information in a single object.\n\n\nTask 12\nUse the code below as a template to create an ages object, replacing the numbers with the ages of yourself and all your family members, in whatever order you like.\n\nages &lt;- c(35, 29, 64, 89, 2)\n\nAgain, when I run this command, a new object appears in my Environment, called ages. This one looks a bit different than the other two, though. In Environment, I can see that this object contains numbers (“num”); that there are four of them ([1:5]); and that those numbers are 35, 29, 64, 89, and 2. This new object is another vector, as we saw earlier. This particular object is a vector of length 5 - that is, it has five elements in it.\n\n\nTask 13\nAsk R for the class of the ages object.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nclass(ages)\n\n[1] \"numeric\"\n\n\n\n\n\nThis might not have been what you expected, but remember, ages (importantly, without quote marks!) is the name of an object. To find out what kind of data it is, R looks at what that object contains, not at the name of the object itself. We already saw that ages contains only numbers; so, R tells us that it’s a numeric vector.\nOne more example to emphasize this point, because it’s often a source of confusion when starting out with R. If we want to ask R the class of the word “ages”, we would need to put it in quotes, and we’d get a different answer:\n\nclass(\"ages\")\n\n[1] \"character\"\n\n\nThe key thing here is that objects have the class of the data they contain, and are not character data; and whenever you want to use an object, you must not use quotation marks. On the other hand, if you want to input character data into R, you must use quotation marks. Otherwise, R will look for an object or function with that name, which will likely produce a “cannot find object” error.\nSo, if the object ages is just a convenient name for a vector of numbers, what happens if we try to do the same maths we did before? For instance, I might want to calculate the birth year of each of my family members, using their ages. To do this, I have to subtract each of their ages from the current year. I could do this one at a time - or all at once using my ages object.\n\n\nTask 14\nCalculate each of your family members’ birth years using your ages object, and save the birth years you’ve just calculated in an object called birth_year.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbirth_year &lt;- current_year - ages\n\n\n\n\nBecause we’ve used the assignment operator, R doesn’t print out the years. Instead, the output of our calculation is saved as the object birth_year. Hmm - didn’t we already have an object called birth_year, though? What happened to it?\n\n\n\n\n\n\nImportant: Overwriting Objects\n\n\n\nYou might notice that we already had an object called birth_year that we created above. R, again, does only and exactly what you ask it to do. Unlike, say, a word processer, that will give you a warning if you try to save two documents in the same folder with the same name, R won’t ask you if you’re sure you want to overwrite an existing object with new information - it will just do it. If you have a look in your Environment, you will see that the previous version of birth_year, containing only your birth year, has been quietly replaced with the new one containing the vector of birth years you just created.\nThis can be a good thing, because you can easily update the information stored in an object with changes, edits, or new information. However, it also means that you can overwrite or replace data when you don’t want to, if you use the same object name.\nThis is why it is so important to keep track of all of the commands and changes you make to your data. If you accidentally replace your dataset with, say, a single word or number with an error in your code, you can easily retrace your steps and avoid redoing work.\nIf you are interested in understanding this process of assigning and replacing the contents of objects better, the aside below explains it in more depth.\n\n\n\n\n\n\nCan you actually change an object?\n\n\n\n\n\nThink of objects as boxes. The names of the objects are only labels, and you can store anything you like inside them. However, unlike in the physical world, objects in R cannot truly change. You can put stuff in and take stuff out, and that’s pretty much it. Unlike boxes, though, when you take stuff out of objects, you only take out a copy of its contents. The original contents of the box remain intact. Of course, you can do whatever you want (within limits) to the stuff once you’ve taken it out of the box, but you are only modifying the copy. The key thing to remember is that unless you put that modified stuff into a box, R will forget about it as soon as it’s done with it. In other words, if you want to “save” any changes you make, you must assign them to an object in order to keep them.\nNow, as you probably know, you can call your boxes (objects) whatever you want (again, within certain limits). This means that that you can call the new box the same as the old one, as we saw with birth_year above. When that happens, R basically takes the label off the old box, pastes it on the new one, and burns the old box. So even though some operations in R may look like they change objects, what’s actually happening is that R copies their content, modifies it, stores the result in a different object, puts the same label on it, and discards the original object. Understanding this mechanism will make things much easier!\nPutting the above into practice, this is how you “change” an R object:\n\n# put 1 into an object (box) called a\na &lt;- 1\n\n# copy the content of a, add 1 to it and store it in an object b\nb &lt;- a + 1\n\n# copy what's inside b and put it in a new object called a\n# discarding (\"overwriting\") the old object a\na &lt;- b\n\n# now see what's inside of a\n# (by copying its content and pasting it in the console)\na\n\n[1] 2\n\n\nOf course, you can just cut out the middleman (creating an object b). So to increment a by another 1, we can do:\n\na &lt;- a + 1\n\na\n\n[1] 3\n\n\n\n\n\n\n\nWe will talk further about using scripts and writing multiple commands below; but first, we’ll need to have a look at a very important type of object in R: the function."
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#functions",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#functions",
    "title": "Into the {tidyverse}",
    "section": "Functions",
    "text": "Functions\nFunctions are like verbs in the R language - they’re how R does anything. Functions may not look exactly like verbs in the language you speak because they have a different syntax (i.e., a different order and grammar), but they work in a very similar way. In order to use them, you need to learn how to “translate” the command you want to give R into a verb (function) it can understand.\n\nFun with Functions\nIn this section, we’ll go through a step-by-step worked example of puzzling out how to use a function.\nLet’s look at an example of how functions are like verbs, drawing on some basic linguistics. We’ll start with the English command, “Round the number 7.3928 to two decimal places.” If we want R to do this for us, we have to write this command in a way that R can understand. First, we need to know what function corresponds to the English verb “round” - that is, what function will do the same action that we want R to perform. We’re lucky in this case: the function in R is also called round(). (See the box below for more on how to find the function you want.)\nWe know that we’re looking at a function in R because functions always have a name followed by brackets. That is, they always have the general form function_name(). Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.\n\n\nTask 15\nTry running the round() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround()\n\nError in eval(expr, envir, enclos): 0 arguments passed to 'round' which requires 1 or 2 arguments\n\n\n\n\n\nUnsurprisingly, R has given us an error. This is an informative error, though - that is, the error gives of some sort of intelligible clue about what’s gone wrong. Namely, it tells us that round() can’t just work without additional information (i.e. “required arguments”). Imagine, for instance, if you wanted a friend or colleague to round 7.3928 to two decimal places, and in order to ask them to do that, you just shouted “ROUND!” at them. Just like that person would would, R has objected to this, telling you that it needs more information in order to do what you’ve asked it to.\nOur original command, “Round the number 7.3928 to two decimal places”, has two more important pieces of information that we need to tell R: what number we want to round (7.3928) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let’s look at the help documentation.\n\n\n\n\n\n\nHelp Documentation\n\n\n\nHelp documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it’s a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running ?function_name or help(function_name) in the console, or by clicking on the “Help” tab in the Files section of RStudio and using the Find box to search for the function.\n\n\n\nTask 16\nPull up the help documentation for round() in RStudio.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n?round\n\nstarting httpd help server ... done\n\n\n\n\n\nThe first section, “Description”, varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function including in this document, we can see that we have a useful description of round() that tells us that it rounds numbers (yay!) to a certain number of decimal places. That’s exactly what we want, so how do we use it?\nLet’s scroll down to “Usage”, which gives examples of what the function looks like. You can see that the basic structure of this function is round(x, digits = 0). It seems like we need to add some more information in the brackets of our function - but how do we interpret x and digits = 0?\n\n\n\nArguments\nThe information inside a function’s brackets to give it the information it needs to work are called arguments. Each argument in a function is separated by a comma, so we can see from round(x, digits = 0) that the round() function can take two arguments. How many arguments a function has depends on the function; some (like Sys.Date()) don’t need any arguments to run. One of the most useful parts of a function’s help documentation is the “Arguments” section, which tells you what each of the function’s arguments are and how to use them.\nThere are two main types of arguments: named and unnamed arguments. Conveniently, the arguments of round() give us one example of each.\n\nUnnamed Arguments\nThe first argument to round() is simply x. Just like in maths, x is a placeholder for some number or numbers (a “numeric vector”, which should sound familiar now) that you want to pass to the function. This is common notation in many functions: x, often the first argument in a function, is often the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that’s what we should replace with x.\n\n\nNamed Arguments\nThe second argument of round() is a named argument, digits = 0. You can think of named arguments like settings that change the way a function works, often with only certain allowable values. Here we can see that the name of the argument is digits; the name before the = sign tells R which setting we want to change.\nThe help documentation tells us that digits should be an “integer indicating the number of decimal places…to be used.” We can also see in “Usage” that this argument has a default value, digits = 0. That means that if we don’t explicitly include the argument digits when we use the function, by default the round() function will round the number you give it to 0 decimal places. Named arguments frequently, but not always, have a default, and it’s important to check so the function doesn’t quietly do something unexpected.\nDefault values of arguments are really useful, because the default is usually the most frequently used setting. It means you don’t have to specify every single aspect of a function every time you use it, as long as you want the function to work that way! In our case, we actually wanted round() to round to two decimal places, not 0. So, in our command, we should change the setting from the default, 0, to 2.\n\n\n\nUsing Functions\nNow that we know what both of these arguments mean, we can change them to actually translate the English sentence “Round the number 7.3928 to two decimal places” into a command that R can work with. We’ll explicitly write out each argument so we know what they are doing.\n\nTask 17\nUse the round() function to round 7.3928 to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround(7.3928, digits = 2)\n\n[1] 7.39\n\n\n\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\n\nIf you want to, you can achieve the same result by changing the order of the arguments. Because we have written the names of both arguments, R can still do what we want it to do:\n\nround(digits = 2, x = 7.3928)\n\n[1] 7.39\n\n\nWe can also, to some degree, drop the names of the arguments, as long as R can still understand what we’re trying to do:\n\nround(digits = 2, 7.3928)\n\n[1] 7.39\n\n\nHere I left out the x =. R can still understand this because round() only takes two arguments, and we explicitly told it what value belongs to digits, so it assumes the second number must be x.\n\nround(7.3928, 2)\n\n[1] 7.39\n\n\nThis time I dropped both argument names. R can still understand this because when you don’t specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 7.3928 to x and 2 to digits, which is what we wanted.\nAs I’ve become more proficient at writing code, I find that I’m more insistent on naming arguments, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That’s because Future Me hasn’t been staring at this code for the last five hours, and verbose code is much, much easier to read! So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:\n\nround(2, 7.3928)\n\n[1] 2\n\n\nHere, since we didn’t specify, R assumed that 2 was the number we wanted to round. This isn’t what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.\n\n\n\n\nPassing Multiple Values to Arguments\nA last important aspect of using functions is to remember that each argument in a function can only take a single object as input. For example, we saw above that we put the single value 7.3928 into the x argument of round(). But what if we wanted to round more than one number? We don’t want to have to write a new round() command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:\n\nround(7.3928, 2)\n\n[1] 7.39\n\n## ughhhh\nround(59.54, 2)\n\n[1] 59.54\n\n## noooooo :(\nround(0.198, 2)\n\n[1] 0.2\n\n## thanks I hate it\n\nSo what happens if we try to put all of those numbers into round()? We might first try this:\n\nround(7.3928, 59.54, 0.198, 2)\n\nError in eval(expr, envir, enclos): 4 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nOnce again, R tells us that this doesn’t work by throwing an error. R has tried to do what we wanted, but the round() function only allows a max of two arguments, and we’ve given it four. Behind the scenes, R has tried to run round(x = 7.3928, digits = 59.54... and can’t proceed from there because it doesn’t know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first x argument together. If only there was a way to concatenate them together…\nYou may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a single object, and then pass that object to round() as the x argument. We already saw that we can combine any number of things together into a single vector using the c() function.\n\n\nTask 18\nUse c() to create a new object containing the three numbers 7.3928, 59.54, and 0.198, then use round() to round them to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nnumbers &lt;- c(7.3928, 59.54, 0.198)\n\nround(numbers, digits = 2)\n\n[1]  7.39 59.54  0.20\n\n\n\n\n\nPerfect! This time, all three numbers together went into the x argument.\nWe could also simplify this even further by removing the intermediate step of creating the numbers object.\n\n\nTask 19\nUse c() and round() together in a single command to get the same output as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1]  7.39 59.54  0.20\n\n\n\n\n\nHere we can see a good example of a function inside another function. You can stack, or “nest”, functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it’s doing. (In the next tutorial, we’ll introduce a popular alternative to writing nested code: the pipe operator.)\nThat’s looking like some proper R code! Very nicely done.\n\n\n\n\n\n\nHelp Documentation, Revisited\n\n\n\nBefore we leave the round() function altogether, let’s take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the “Details” section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn’t doing what you expect it to, this is a good place to look for an explanation.\nFinally, at the end of the documentation you can find the “Examples” section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the “Run examples” link, which will run the code in the Examples section for you so you can see what the function will do.\n\n\n\n\n\nChoosing Functions\nJust like learning a new language, when you start out in R your “vocabulary” of functions will be small, and you’ll only be able to “speak” a small number of commands from memory. As you work more in R and practice using more functions, your vocabulary will grow. However, if you are trying to do something new or unusual in R, finding the right function that does what you want it to do often takes some work and research. This is just like having to look up a new word or phrase in the dictionary if you don’t know how to say something in the language you’re learning.\nIf you don’t know what function to use, your first step can be to Google it with a search like “function to [whatever you want to do] in R”, which will often put you on the right track! (R’s internal help search is often most useful when you already know the name of the function you want to use.)"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#packages",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#packages",
    "title": "Into the {tidyverse}",
    "section": "Packages",
    "text": "Packages\nIn this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nVocabulary: Package\n\n\n\nA package is a bundle of (usually, but not necessarily!) multiple functions. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\n\n\n\nRounding, Revisited\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do2.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\nTask 20\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\n\n\nInstalling Packages\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\nTask 21\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\n\ninstall.packages(\"weights\")\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\nTask 22\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\n\nLoading Packages\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\nTask 23\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\nLoading required package: Hmisc\n\n\nLoading required package: lattice\n\n\nLoading required package: survival\n\n\nLoading required package: Formula\n\n\nLoading required package: ggplot2\n\n\nWarning: package 'ggplot2' was built under R version 4.2.2\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\nTask 24\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1] \"7.39\"  \"59.54\" \".20\"  \n\n\n\n\n\nSuccess!\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(7.3928, 59.54, 0.198), digits = 2)\n\nError in rd(c(7.3928, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(7.3928, 59.54, 0.198), digits = 2)\n\n[1] \"7.39\"  \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type. You can do it either way - it’s up to you!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/tutorial_01.html#footnotes",
    "href": "tutorials/01_fundRmentals/tutorial_01.html#footnotes",
    "title": "Into the {tidyverse}",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs a linguist I have to note, one, words don’t exist, and two, the closest linguistic term for what an object is is probably “lexeme”. “Word” will get you in the right vicinity, though, conceptually. If you’d like to dive down this rabbit hole (rabbit-hole?) this Crash Course video on morphology is a good place to start, but don’t forget to come back and keep working on R!↩︎\nYou may not find any that you’d quite like to use - in that case, of course, you can code something new! Oh, the functions you’ll write…↩︎"
  },
  {
    "objectID": "tutorials/02_pRinciples/tutorial_05.html",
    "href": "tutorials/02_pRinciples/tutorial_05.html",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "Overview\n\n\n\nThis tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset."
  },
  {
    "objectID": "tutorials/02_pRinciples/tutorial_05.html#getting-started",
    "href": "tutorials/02_pRinciples/tutorial_05.html#getting-started",
    "title": "05: Mutate and Summarise",
    "section": "Getting Started",
    "text": "Getting Started\n\nUsing This Tutorial\n\n\nSetting Up\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/02_pRinciples/tutorial_05.html#mutate",
    "href": "tutorials/02_pRinciples/tutorial_05.html#mutate",
    "title": "05: Mutate and Summarise",
    "section": "Mutate",
    "text": "Mutate\nThe mutate() function is one of the most essential functions from the dplyr package. Its primary job is to easily and transparently make changes within a dataset - in particular, a tibble.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::mutate(\n    variable_name = instructions_for_creating_the_variable\n  )\n\nvariable_name is the name of the variable that will be added to the dataset by mutate(). This can be any name that follow’s R’s object naming rules. There are two main options for this name:\n\nIf the dataset does not already contain a variable called variable_name, a new variable will be added to the dataset.\nIf the dataset does already contain a variable called variable_name, the new variable will silently1 replace (i.e. overwrite) the existing variable with the same name.\n\n\nUsage\n\n\n\n\n\n\nTip\n\n\n\nAlthough creating or modifying variables will likely be the most frequent way you use mutate(), it has other handy features such as:\n\nDeleting variables\nDeciding where newly created variables appear in the dataset\nDeciding which variables appear in the output, depending on which you’ve used\n\nSee the help documentation for more by running help(mutate) or ?mutate in the Console.\n\n\n\n\n\nComposite Scores\n\nRow-wise magic is good magic. -Hadley Wickham\n\nA very common mutate() task is to create a composite score from multiple variables - for example, an overall anxiety score from a questionnaire with ten items on anxiety. Imagine we wanted to create an overall score that is the mean of the ratings on each of those ten items, for each participant.\nTo do this, we must use a method that ensures that each score is calculated separately for each participant. There are a variety of ways to accomplish this, but a robust and reasonably straightforward way uses the purpose-built function dplyr::rowwise().\n\n\n\n\n\n\nImportant\n\n\n\nThe code below assumes a dataset structured so that each participant has data on a single row only\nIf your data is tidy with observations from the same participants on multiple rows, you will need to reshape your data or adapt the code to suit your data structure.\n\n\n\n1my_tibble |&gt;\n2  dplyr::rowwise() |&gt;\n3  dplyr::mutate(\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")),\n                        na.rm = TRUE)\n  ) |&gt;\n4  dplyr::ungroup()\n\n\n1\n\nTake the dataset, and then,\n\n2\n\nGroup the dataset by row - and because each row is a participant, by participant. This means that any subsequent calculations will be done for each row separately.\n\n3\n\nCreate the new anxiety_mean variable. The new function c_across() works quite similar to c() - namely, creating a vector of variables to take the mean of. However, it has the advantage of allowing &lt;tidyselect&gt; for choosing the variables, instead of having to type them out one by one.\n\n4\n\nRemove the grouping that was created by rowwise(). Otherwise, all other subsequent operations on this dataset will continue to be performed within each row. (This isn’t typically the desired behaviour for this task, but it can be quite useful in other scenarios!)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor lots more details and examples on rowwise() and rowwise operations with dplyr - including which other scenarios in which a row-wise dataset would be useful - run vignette(\"rowwise\") in the Console.\n\n\n\n\n\n\n\n\nPractice Tasks\n\n\n\n\nWhat would the above code produce without the rowwise()...ungroup() steps (i.e. with only the mutate() command)? Make a prediction, then try it and find out if you were right.\nThe above code is definitely not the only way to obtain the same output. Try producing the the same anxiety_mean variable with the following methods. What are the benefits and drawbacks of each methods? Hint: Use vignette(\"rowwise\") to help if you get stuck.\nUsing a dedicated by-row function, rowMeans()\nUsing the basic structure of mutate() only\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\n\nWe can see what happens without rowwise()...ungroup() just by commenting them out of the pipe. To do this, either type # before each line, or highlight them and press CTRL/CMD + SHIFT + C.\n\n\nmy_tibble |&gt; \n  # dplyr::rowwise() |&gt; \n  dplyr::mutate(\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) # |&gt; don't forget to comment out this pipe or you'll get an error\n  # dplyr::ungroup()\n\nThis code still runs successfully, but the result isn’t what we wanted. Have a look at the anxiety_mean variable: all the values are the same. Instead of calculating the mean for each person, this code instead calculated the overall mean of all of the anxiety variables, and then assigned that single value to the anxiety_mean variable. Not what we wanted in this case - but it could be useful in other scenarios!\n\nIf we wanted to avoid, or didn’t remember, the rowwise()...ungroup() sequence, there are other options to produce the same result, but neither are easier to read or implement.\n\n1. Using rowMeans\nThe base function rowMeans() calculates the mean of each row without any additional jiggery pokery to worry about. The problem is specifying which variables to include, especially because we have ten in this example to work with.\nHowever, rowMeans() is an independent function who doesn’t need no dplyr, and as such does not work the same way, for instance, mean() does, with no straightforward workaround.\n\n## Reasonable but just doesn't work!\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(c(anxiety_1, anxiety_2, anxiety_3..., anxiety_10))\n  )\n\nError in dplyr::mutate(my_tibble, anxiety_mean = rowMeans(c(anxiety_1, : object 'my_tibble' not found\n\n\nThis is because rowMeans() is expecting a whole dataset, not just a subset of columns. You can solve this by select()ing within the rowMeans() function:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(dplyr::select(my_tibble, anxiety_1, anxiety_2...))\n  )\n\n…which has the major issue that if you update the name of your dataset, you must update it in TWO places - at the start of the pipe and inside rowMeans(), along with just being a huge mess.\nAlternatively, you can use dplyr::pick() with &lt;tidyselect&gt; semantics to make this less, well, terrible:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = rowMeans(pick(contains(\"anxiety\")))\n  )\n\n…which didn’t seem fair because we haven’t talked about pick(), and also defeated the purpose of using rowMeans() to avoid having to learn new dplyr functions. So, dplyr wins this one either way.\nIf you’re keen to never have to learn a jot more dplyr than absolutely necessary (I bet you are not having a good time so far!), this Stack Overflow post offers some other, non-dplyr solutions…that also depend on using the magrittr pipe %&gt;%! Sorry.\n2. Use basic mutate()\nThe most straightforward method - although perhaps not the most obvious - is to express the calculation you want as arithmetic using the relevant variables. In this instance, to calculate a mean, we sum the scores together and then divide by the number of scores:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_mean = (anxiety_1 + anxiety_2 + ... + anxiety_10)/10\n  )\n\nThis method, although very transparent, has some critical downsides.\n\nIt’s clunky and prone to error. This style works best for 2-3 variables contributing to the composite. For more variables, we end up with a lot of repetitive typing, which also means increased likelihood of typos, accidental omissions, or other errors - especially with a large number of variables, as we have here.\nIt’s not robust. Imagine that, on review of the anxiety scale, we find that anxiety_9 is a badly worded/unreliable item and decide to drop it from our analysis. We then either have to (remember to) manually update our code both to remove anxiety_9 and to change the denominator from 10 to 9 (not a good time), or debug the resulting error if we don’t remember.\n\nWe do teach this method to UGs specifically to reduce the number of functions they have to learn, but for real-life usage, in most cases, the rowwise() solution is likely preferable.\n\n\n\n\n\n\n\nRecoding and Conditionals\nThere are many functions out there for recoding variables, but the following method, using dplyr::case_when(), is recommended because it is so versatile. It can be used to recode the values from one variable into new one, but it can also combine information across variables to create a new one. It allows a series of if-else statements without having to actually have lots of if-else statements!\nThe generic format of case_when() can be stated as follows:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    new_variable = dplyr::case_when(\n      logical_assertion ~ value,\n      logical_assertion ~ value,\n      .default = value_to_use_for_cases_with_no_matches\n    )\n  )\n\n\nUsage\nWithin case_when(), each line contains a formula, written above as logical_assertion ~ value. This can be read as follows:\n\n“For the cases where logical_assertion returns TRUE, assign value to the new_variable.\n\nThese assertions are evaluated sequentially and the first match determines the value. This means that the assertions must be ordered from most specific to least specific.\n\n\n\n\n\n\nTesting Assertions\n\n\n\n\n\nThe assertions for case_when() are the same as the ones we used previously in filter(). In fact, if you need to test the assertion you are writing to ensure that your code will work as you want, you can try the same assertion in filter() to check whether the cases it returns are only and exactly the once you want to change.\n\n\n\nLet’s look at two examples of how dplyr::case_when() might come in handy.\n\nOne-Variable Input\nWe’ve created our composite anxiety_mean variable previously, and now we may want to change this continuous score into a categorical variable indicating whether or not participants display clinical levels of anxiety. So, we can use case_when() to recode anxiety_mean into a new anxiety_cat variable.\n\n1anxiety_cutoff &lt;- 35\n\n2my_tibble |&gt;\n3  dplyr::mutate(\n4    anxiety_cat = dplyr::case_when(\n5      anxiety_mean &gt;= anxiety_cutoff ~ 1,\n6      anxiety_mean &lt; anxiety_cutoff ~ 0,\n7      .default = NA\n    )\n  )\n\n\n1\n\nCreate a new object, anxiety_cutoff, containing the threshold value for separating clinical from non-clinical anxiety. This one is from REFERENCE.\n\n2\n\nTake the dataset, and then\n\n3\n\nMake a change to it as follows\n\n4\n\nCreate a new variable, anxiety_cat, by applying the following rules\n\n5\n\nFor cases where the value of anxiety_mean is greater than or equal to anxiety_cutoff, assign a value of 1 to anxiety_cat\n\n6\n\nFor cases where the value of anxiety_mean is less than anxiety_cutoff, assign a value of 0 to anxiety_cat\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign NA to anxiety_cat\n\n\n\n\n\n\n\n\n\n\nWhy the new anxiety_cutoff object?\n\n\n\n\n\nIn the code above, the cutoff value is stored in a new object, anxiety_cutoff, which is then used in the subsequent case_when() conditions. Why take this extra step?\nThis is a matter of style, since the output of this code would be entirely identical if I wrote the cutoff value into the case_when() assertions directly (e.g. anxiety_mean &gt;= 35). I have done it this way for a few reasons:\n\nThe threshold value is easy to find, in case I need to remind myself which one I used, and it’s clearly named, so I know what it represents.\nMost importantly, it’s easy to change, in case I need to update it later. I would only have to change the value in the object once, at the beginning of the code chunk, and all of the subsequent code using that object would be similarly updated.\n\nIn short, it makes the code easier to navigate, more resilient to later updates, and more transparent in its meaning.\n\n\n\n\n\nMulti-Variable Input\nWe might also like to create a useful coding variable to help keep track of the number of cases we’ve removed, and for what reasons. We can draw on input from multiple variables to create this single new variable.\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    remove = dplyr::case_when(\n2      distribution == \"Preview\" ~ \"preview\",\n3      info_consent != \"Yes\" ~ \"no_consent\",\n4      age &lt; 18 ~ \"age_young\",\n5      is.na(age) | age &gt; 100 ~ \"age_bad\",\n6      !grepl(\"eng\", tolower(fluent_lang)) ~ \"english_no\",\n7      .default = \"keep\"\n    )\n  )\n\n\n1\n\nTake the dataset my_tibble and make a change to it by a creating a new variable, remove, by applying the following rules\n\n2\n\nFor cases where the distribution variable contains exactly and only “Preview”, assign the value \"preview\". This is a common task for Qualtrics surveys to remove practice runs.\n\n3\n\nFor cases where the info_consent variable does NOT contain exactly and only the value “Yes”, assign the value \"no_consent\". This includes anyone who did not actively consent - both people who chose options OTHER than “Yes” (e.g. “No”), and people who did not respond.\n\n4\n\nFor cases where the numerical value in age is less than 18, assign the value \"age_young\".\n\n5\n\nFor cases where the value is age is NA, or is greater than 100, assign the value \"age_bad\".\n\n6\n\nFor cases where the value in fluent_lang, once converted to lowercase, does NOT contain the letters “engl”, assign the value \"english_no\". This searches open text responses to a question like “What languages do you speak fluently?” for the string “engl”.\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign the value \"keep\".\n\n\n\n\nBecause the first match for each case is the value it is assigned, each case will receive only one value, even if they match multiple criteria. For example, if you had a participant who gave their age as 17 and their fluent languages as Finnish and German, they would be coded as age_young rather than english_no because the assertion about age comes before the assertion about language. (This is sensible behaviour, because being 18 or older is an ethical requirement, whereas speaking English fluently likely isn’t.)\nFrom here, you can easily use this variable to summarise exclusions, and to filter out excluded cases for your final dataset.\n\n1my_tibble |&gt;\n  dplyr::count(remove)\n\n2final_tibble &lt;- my_tibble |&gt;\n  dplyr::filter(remove == \"keep\")\n\n\n1\n\nTake my_tibble and count the number of times each unique value occurs in the remove variable.\n\n2\n\nCreate a new object, final_tibble, by taking my_tibble and then retaining only the cases for which the remove variable has only and exactly the value \"keep\" - effectively dropping all other cases.\n\n\n\n\n\n\n\n\n\n\nRecoding Factors\n\n\n\n\n\nWhat about recoding or relabeling factors? For example, imagine a dataset where gender has been collected as 1, 2, and 3, with 1 corresponding to “Female”, 2 to “Male”, and 3 to “Nonbinary/third gender”. You\n\n\n\n\n\n\n\nAcross Multiple Variables\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Beginner Series live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Beginner Series tasks.\n\n\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    dplyr::across(&lt;tidyselect&gt;, function_to_apply)\n  )"
  },
  {
    "objectID": "tutorials/02_pRinciples/tutorial_05.html#summarise",
    "href": "tutorials/02_pRinciples/tutorial_05.html#summarise",
    "title": "05: Mutate and Summarise",
    "section": "Summarise",
    "text": "Summarise\n\nBasic Structure\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\n\n\n\n\nImportant\n\n\n\nYou may notice that the basic structure of summarise looks identical to the basic structure of mutate, above. The difference is that mutate creates or replaces variables within the same dataset, while summarise creates a new summary dataset without changing the original.\n\n\n\nUsage\n\n\n\nGrouped Summaries\n\nmy_tibble |&gt; \n  dplyr::group_by(group) |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\nReady-Made Summaries\n\n\nAcross Multiple Variables\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Beginner Series live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Beginner Series tasks."
  },
  {
    "objectID": "tutorials/02_pRinciples/tutorial_05.html#footnotes",
    "href": "tutorials/02_pRinciples/tutorial_05.html#footnotes",
    "title": "05: Mutate and Summarise",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere, “silently” means that R overwrites the existing variable without flagging that it is doing this or asking you if you are sure, so it’s important to be aware of this behaviour (and to know what variables already exist in your dataset).↩︎"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "R Training at Sussex",
    "section": "",
    "text": "This is the website for training courses in the programming language R, run by the Methods Teaching Team in the School of Psychology, University of Sussex.\n\n\nAt the moment, our training sessions are only open to members of staff in the School of Psychology at Sussex, or by invitation.\nIf you fit that description, DO X\nIf you do not fit that description but are interested in joining a training course in the future, please register your interest here and we will get in touch when/if there are open sessions available."
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "R Training at Sussex",
    "section": "Materials",
    "text": "Materials\n\nTutorials\nThe Tutorials section of the site contains tutorial documents designed to accompany live training sessions. They provide explanations, examples, and exercises designed for complete beginners through improvers.\n\n\nWorksheets\nWorksheets are hosted on the Posit Cloud workspace for the training course. You can join the workspace via Canvas.\n\n\nRecordings\nLive sessions are recorded and made available, with automatically-generated captions, as soon as possible after the sessions are complete. View session recordings on Canvas."
  },
  {
    "objectID": "tutorials.html#using-the-tutorials",
    "href": "tutorials.html#using-the-tutorials",
    "title": "Tutorials",
    "section": "",
    "text": "These tutorials are designed to accompany live training sessions, but they also serve as quick-reference guides for all the material covered in those sessions.\n\n\nIn live sessions, it is recommended to open the corresponding tutorial in the Viewer pane in Posit Cloud so that solutions and explanations are easily available. The workbook documents provided for each week will already contain the code to do this.\nHowever, the tutorials can also be easily accessed at any time through this website, so it isn’t necessary to open Posit Cloud to view them - simply use the sidebar to jump to the tutorial you want!\n\n\n\nThe exercises are strongly recommended to build your skills in R. All data and workbooks will be provided on Posit Cloud for completing the exercises.\nSolutions to all exercises are provided in the tutorial as well.\n\n\nSome exercises will be clearly labeled as “Challenges”. These exercises are optional and are meant to go beyond the core tutorial material. However, if you skip them, you will still be able to understand everything that follows; you won’t need to complete them in order to proceed."
  },
  {
    "objectID": "tutorials.html#content",
    "href": "tutorials.html#content",
    "title": "Tutorials",
    "section": "Content",
    "text": "Content\nTutorials are divided into three sections.\n\nFundRmentals\nThe three-part FundRmentals series covers essential basic skills in R, and is designed for absolute beginners who have never seen R before and who have little to no coding experience of any kind.\nBy the end of this series, you will be able to:\n\nNavigate the RStudio IDE\nCreate and work with different types of data\nWork with objects and functions\nPerform calculations and logical tests on single values and vectors\nRead in data from a .csv file into a tibble\nView, summarise, and arrange the order of a tibble\nCreate and render Quarto documents\nPerform and report t-test and linear model analyses\n\n\n\nEssentials\nThe four-part Essentials series is designed for novices with some basic skills in R, and follows on from the FundRmentals series. It covers the core data wrangling and analysis skills that we teach throughout the first year of the undergraduate Psychology course at Sussex, along with extra tips and techniques for efficient and transparent analysis to support dissertation supervisors to help their students.\nBy the end of this series, you will be able to:\n\nFilter cases and select variables, including efficient &lt;tidyselect&gt; semantics\nCreate new variables in a dataset, or change/recode existing ones\nCreate a variety of customised data visualisations\nPerform and efficiently report the results of t-tests, chi-squared tests, correlations, and simple and hierarchical linear models\n\n\n\nImprovRs\nThe four-part ImprovRs series is designed for those with a strong foundation in R who want to move to using R in part or entirely for their data management and analysis process, and follows on from the Essentials series. It covers specific skills in working with questionnaire data, advanced data wrangling, and an introduction to writing functions, with the aim of building a diverse toolbox of R skills.\nBy the end of this series, you will be able to:\n\nWork with labelled Qualtrics data and factors\nCreate standardised subscale scores\nGenerate automatic codebooks for Qualtrics datasets\nReshape (wide/long format) and merge/separate datasets\nWrite custom anonymous and named functions"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html",
    "href": "tutorials/01_fundRmentals/01_intro_i.html",
    "title": "01: IntRoductions I",
    "section": "",
    "text": "The Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nSo - let’s get cracking."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#logical-assertions",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#logical-assertions",
    "title": "01: IntRoductions I",
    "section": "",
    "text": "Before we jump headfirst data wrangling, we first need to practice a core idea that underlies how many of these functions work.\nMany of the functions and operations we will encounter in R rely on logical assertions. A logical assertion is a statement that can be either true or false (in R, of course, TRUE or FALSE). Let’s look at an example first.\nTo begin, let’s ask R whether 10 is greater than 5:\n\n10 &gt; 5\n\n[1] TRUE\n\n\nR sensibly returns TRUE. Essentially, we are making a claim (10 is greater than 5) and R tells us whether that claim, or assertion, is true or not. Similarly, we can assert that 5 is greater than 10:\n\n5 &gt; 10\n\n[1] FALSE\n\n\nAnd R again, very sensibly, tells us that we’re wrong (FALSE). So far so good!\n\n\nIn the next step, we’re going to meet a foundational piece of the way R works: the vector. Vectors are essentially one-dimensional lists of pieces of information. What this means is that instead of asking R about one number at a time, we could po"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#the-console",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#the-console",
    "title": "01: IntRoductions I",
    "section": "The Console",
    "text": "The Console\nThe Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nThat sounds pretty intense, so let’s get a couple of things straight right away. You will, inevitably, make typos and mistakes using R. You will write commands that make sense to you that R doesn’t understand; you will write commands that don’t make sense to you, that R does understand; and you will see all kinds of exciting errors, warning messages, and - once we get to the fun stuff - beautiful plots and results for our studies. So, right now, let’s get over the fear of doing something “wrong” in R. You will do many, many things wrong, just like someone saying their first few words in a new language. Who cares? You’re learning.\n\nTask 1\nType literally any gibberish, words, keysmashes etc. into the Console and press Enter.\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nThis is fun! I'm having fun!\n\nError: &lt;text&gt;:2:6: unexpected symbol\n1: ## Words!\n2: This is\n        ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\nWell, that went about as expected!\nLuckily, R has a very short memory (that is to say, no memory to speak of) and is always ready to do the next thing I ask straightaway, even if it’s nonsense - which is lucky for me, I can assure you.\nIf you haven’t tried this yet, and the cursor in the Console is just blinking balefully at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There are two important things that we are learning here:\n\nTo ask R to do something - that is, to “run” or “execute” the commands you write - you must write them out in the Console and press Enter.\nEventually, inevitably, something that you type WILL produce an error. This is no cause for panic, fear, or alarm, so get it out of the way now!\n\nFrom our gleeful keysmashing above, you will have seen that aslavb;lj aew aljvb, This is fun! I'm having fun!, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\nGlossoRlia\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nWhat I am trying to tackle right away is the idea that R is scary or incomprehensible. R is just a system for doing tasks that computers are great at - sifting through thousands of data points in a second, making systematic changes to huge datasets, creating complex mathematical models, drawing elaborate plots. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But although R can do maths a lot quicker than a human, it can’t design studies, or critically evaluate an argument, or appreciate a well-chosen emoji, or have sudden bursts of inspiration, or use the results it produces to improve society. Ultimately it’s just a tool to help you achieve your goals.\nRight, enough philosophizing. Let’s prove the point by jumping into R and learning about how it works!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#numbers",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#numbers",
    "title": "01: IntRoductions I",
    "section": "Numbers",
    "text": "Numbers\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\nTask 2\nType any single number in your new code chunk, then run the chunk.\n\n\n\n\n\n\nHint\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random - that's what I did!\n\n3958\n\n[1] 3958\n\n\n\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\nTask 2.1\nTry putting in another number that’s at least 4 digits long, including the commas to separate the thousands and hundreds places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n\n\nNo good there. This is because commas have an important role to play in functions, as we will see later on. For now, we’ve seen that for long numbers, we need to give them to R without any commas. (Full stops to mark decimal places are just fine; try it if you like.)\n\n\n\n\n\n\nNote\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets and commas.\n\n\nNext, let’s try doing some basic maths.\n\n\nTask 2.2\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n40 + 8\n\n[1] 48\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\nTask 2.3\nTry doing each of these things with the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\nNow, let’s say I wanted to have a bunch of different numbers to use for my analysis. In fact, I want every number between 1 and 50. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\nTask 2.4\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\nOne thing to notice here is that the indices I mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\nTask 2.5\nPrint out all the numbers 12 through 58; all of the numbers 23 through 106; and 36.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou may have tried something like this:\n\n12:58\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n[26] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58\n\n23:106\n\n [1]  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41\n[20]  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60\n[39]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79\n[58]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[77]  99 100 101 102 103 104 105 106\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. I’d actually like to have all of those numbers together. To do this, I’m going to use a function called c().\nTo use it, type the name of the function, which includes the brackets. Then, inside the brackets, put the numbers you want to put into a single vector, with different groups separated by commas.\n\nc(12:58, 23:106, 36)\n\n  [1]  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29\n [19]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [37]  48  49  50  51  52  53  54  55  56  57  58  23  24  25  26  27  28  29\n [55]  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47\n [73]  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65\n [91]  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83\n[109]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101\n[127] 102 103 104 105 106  36\n\n\n\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects (or concatenates, or combines) all of the numbers into a single series of elements, called a vector.\nActually, this isn’t a new thing; we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see the Vocab box on vectors and elements. When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing.\n\nc(12:58, 23:106, 36)[88]\n\n[1] 63\n\n\nWhat I’ve essentially asked is, “Put all of these numbers into a single vector, and then give me the 88th element in that vector.” As it turns out, the 88th element in that vector of numbers is 63.\n\n\n\n\n\n\nVocab: Vectors and Lists\n\n\n\nA vector is essentially a series of pieces of data, or elements. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nTask 2.6\nTo finish up, create a vector of every whole number between 37 and 86, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37-86) - 7\n\n[1] -56\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\nOrder of Operations\nAs you may remember from school, mathematical expressions are evaluated in a certain order. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#characters",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#characters",
    "title": "01: IntRoductions I",
    "section": "Characters",
    "text": "Characters\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\nTask 3\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\nThe placement of the quotes is very important here - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a very special sequence of letters in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nWhy have we got it here? Essentially, we asked R for the eighth element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a fifth element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#logical",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#logical",
    "title": "01: IntRoductions I",
    "section": "Logical",
    "text": "Logical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\n\n\n\n\n\nExercise\n\n\n\nCreate logical assertions that:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n49 does not equal 93\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n49 != 93\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last couple statements above may have caused you some trouble if the notation is unfamiliar.\nFor “does not equal”, ! is common notation in R for “not”, or the reverse of something. So != can be read as “not-equals”.\nFor “equals”, if you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use shortly. Single = also has an important and specific role to play in function arguments. Essentially = is a special operator that doesn’t assert equivalance. Instead, “exactly equals” in R is “double-equals” (or “exactly and only”), ==.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. This is a vectorised calculation again, as we saw with numeric data before. These vectorised assertions will be absolutely essential to selecting and filtering data that meet particular requirements, or checking our data to find problems."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#class-and-coercion",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#class-and-coercion",
    "title": "01: IntRoductions I",
    "section": "Class and Coercion",
    "text": "Class and Coercion\nWith these short examples, it may be obvious just by looking that 25 is a number and porcupine is a word. However, this isn’t always so straightforward, and there are some situations - such as data checking/cleaning, or debugging - where we might want to check what type of data a certain thing is. To do this, we’ll need another new function, class(). This function will print out, as a character, the name of the data type of whatever is put into the brackets.\n\n\n\n\n\n\nExercise\n\n\n\nUse the class() function to get R to print the values \"numeric\", \"logical\", and \"character\".\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Any numeric vector will do\nclass(216907)\n\n[1] \"numeric\"\n\n## You can also use a longer vector of numbers\n## as long as they are all numbers!\nclass(c(4:291, -1, 38.7, 100000000))\n\n[1] \"numeric\"\n\n## Logical has two options\n## Create a vector of TRUEs and FALSEs\nclass(TRUE)\n\n[1] \"logical\"\n\n## Create a vector that outputs logical values (now you're thinking with functions!)\nclass(c(6 &gt; 4, 10 == 37, 3 != 8))\n\n[1] \"logical\"\n\n## Character\nclass(\"antidisestablishmentarianism\")\n\n[1] \"character\"\n\n\n\n\n\nWhat data type does R give you if you combine numbers and characters in c()?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Again, anything will do\n\nclass(c(93, -1905, \"avocado\"))\n\n[1] \"character\"\n\n\n\n\n\n\n\nSomething interesting has happened here. Recall that atomic vectors created with c() must all have the same data type. Here, we combined two types of data: numeric and character. We didn’t get an error - instead, without warning or telling us, R quietly converted the entire vector to character type. This forcible conversion is called coersion.\n\n\n\n\n\n\nCoersion\n\n\n\nCoersion is when a piece of data is forcibly changed from one data type to another. This is sometimes intentional, but it can happen unintentionally (and without any warning or fanfare!), so is a common source of errors.\nCoersion follows a hierarchy; data types on the left can be coerced into the types further along to the right.\nlogical ==&gt; integer ==&gt; double (numeric) ==&gt; character\nAs we saw previously, you can check the data type of a vector with class(). You can also check if a vector is a particular type (and receive a logical vector in response) with the is.*() family of functions. (The * notation refers to a placeholder for many different options, such as is.numeric, is.character, etc.)\nYou can similarly (try to) coerce a vector into a particular data type with the as.*() family of functions.\n\n\nThis explains why our vector from the last exercise was a character vector - since the vector contained at least one character element, everything else in the vector was coerced to the same type. This can cause problems when, for example, numeric data is coerced into character data, even though it still looks like numbers.\nEven though we can do mathematical operations on numbers, we can’t do them on characters; it should be clear that asking e.g. what is \"tomato\" - 7 is nonsense. However, this is the case even if all of the data are numerals! For example:\n\n## No problem here; all numbers\nc(2:20, 45) - 7\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 38\n\n## Doesn't work\nc(2:20, \"45\") - 7\n\nError in c(2:20, \"45\") - 7: non-numeric argument to binary operator\n\n\nEven though “45” looks like a number, because it’s in quotes, R thinks that it’s a character, and will refuse to do the calculation, in the same way that it would refuse to do it with “tomato”."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#objects",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#objects",
    "title": "01: IntRoductions I",
    "section": "Objects",
    "text": "Objects\nR is a programming language, but (being created by speakers of natural language) it has many features similar or analogous to natural languages. In this section, we’ll cover the basic “grammar” of R, including how R understands what you ask it to do.\nIn a similar way that the basic unit of many languages is the word1, the basic unit of the R programming language is the object. This section will explore the basics of what an object is and some of their key features in R.\n\n\n\n\n\n\nDefinition: Objects\n\n\n\nObjects are the basic elements that R is built around - the equivalent of words. An “object” in R is any bit of information that is stored with a particular name. Objects can hold anything, from a single number or word to huge datasets with thousands of data points or complex graphs. These named objects are the main way you, the programmer, can store, retrieve, and interact with information in R.\n\n\n\nCreating an Object\nAlthough we have done quite a bit in R so far - creating vectors, doing calculations, etc. - you may notice that we haven’t stored this information anywhere. To store the output of code for further use, it needs to be assigned to an object using the assignment operator, &lt;-. Once an object is created, it will appear in the Environment pane.\n\n\n\n\n\n\nClear Your Environment\n\n\n\nAt the moment your Environment should be empty. As a reminder, Environment is by default the first (leftmost) tab in one of your four main windows in RStudio, probably the one on the top right.\nIf this window is blank except for “Environment is empty”, you’re ready to go. If for some reason it isn’t empty, click the broom icon to clear everything from your Environment before you get started, as indicted in the image below. (There will be a very ominous-sounding “Are you sure?” pop-up, but just click “Yes”.)\n\n\n\nFirst, let’s look at the foundational structure of almost everything you will do in R:\nobject &lt;- instructions\nThis is “pseudo-code”, or a “general format” for a command in R. It isn’t valid R code, but is rather intended as a midpoint between natural language and R to help make it clear how the code works. You can read this code as, “An object is created from (&lt;-) some instructions.”\n\nobject: Objects can be named almost anything (although see Naming, below). The object name is a label so you, the analyst, can find, refer to, and use the information you need.\n&lt;-: The assignment operator &lt;- has single job: to assign output to names, or in other words, to create objects.\ninstructions: Any amount of code that produces some output, which is what object will contain.\n\n\n\n\n\n\n\nNaming Objects\n\n\n\n\n\nCOMING SOON\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nThink of a research scenario familiar to you with two independent groups. You’re welcome to draw from your own research or expertise, but you should choose something with numerical scores. Some ideas include:\n\nReaction times on a button-pressing task from a control and an experimental intervention group\nStatistics anxiety scores from first and second year UG students\nQuiz marks from students with practicals scheduled 9am and students with practicals at 6pm\n\nMake a note of the scenario you chose. Then, create two new objects: one that contains a vector of seven scores from the first of the two groups, and the second that has seven different scores from the second group.\nHint: Just make up some numbers!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nChoosing scenario 3, this vector contains some hypothetical quiz marks from each class.\n\nquiz_9am &lt;- c(75, 58, 62, 14, 33, 67, 55)\nquiz_6pm &lt;- c(45, 90, 27, 65, 39, 77, 48)\n\nLet’s have a look at this command. On the left side I’ve written the name I want my new object to have, which I’ve called quiz_scores_9am. (I could have called it anything, like the_first_example_of_an_object_InThisSection.so.far or made_upQuizScores.fornineamclass or anything else that follows R’s naming conventions. However, it’s a good idea to name your objects something brief and obvious, so you can remember what they contain.) Next, the assignment operator &lt;- assigns whatever comes after it to the object label quiz_scores_9am. Finally, I’ve written instructions for what I want this object to contain: in this case, a vector of numbers that I’ve made up, but that reasonably look like quiz scores.\nIf you haven’t done this yet, do so now, even if you’ve looked at the solution rather than trying it for yourself first. Once you’ve typed the command, there’s a final step to actually create the object: you have to run the command in order for it to take effect. As a reminder, you can do this by clicking the green ▶️ button in the upper right corner of the code chunk, or by pressing Ctrl/Cmd + Enter when your cursor is blinking on the same line as the code you want to run.\n\n\n\n\n\nAssuming your code is valid, you should see a green bar appear along the left-hand side of the code chunk when you run the code, but you might notice that there’s no printout that appears under the code chunk, as there was previously. In fact, if the code ran successfully, it might look like nothing happened at all. To find out what did happen, look your Environment pane. You should now see a new section, “Values”, and underneath the name of your new object and what it contains. Success!\n\n\nCalling an Object\nFor any object, from the most simple to the most complex, you can always see what’s in it by calling the object. This simply means that you type the name of the object and run the code. R will print out whatever is stored in the object.\n\n\n\n\n\n\nExercise\n\n\n\nCall both of the objects you just created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nReplace with the name of the object you created, if you did something different.\n\nquiz_9am\n\n[1] 75 58 62 14 33 67 55\n\nquiz_6pm\n\n[1] 45 90 27 65 39 77 48\n\n\n\n\n\n\n\nThis output looks just like what we saw earlier, when we just asked R to print out a vector of numbers. In essence, the object names are just labels for storing and referring to the information they contain.\n\n\n\n\n\n\nCreating vs Calling\n\n\n\nThese two actions are the essential basis of everything you will do in R. All of your code will, at base, either create an object, or call an object. (Changing an existing object, as we’ll see shortly, is the exact same procedure as creating one from scratch.)\nWhen you create an object using the assignment operator (&lt;-), the object is created but is not printed out. This is because R always does only and exactly what you ask it to do, and using the assignment operator only tells R to assign something to an object, not to print it out.\nWhen you call an object, the current contents of that object are printed out, but that object is not changed - you only reproduce a copy of its contents for review. To create or change an object, you must use the assignment operator to assign the output to a new (or existing) object name.\n\n\nLet’s make all of this a bit more concrete by seeing how we can use objects effectively.\n\n\nUsing Objects\nSince objects are convenient reference labels for the information they contain, we can work with them as if they were the information they contain. In this case, our objects contain numbers, so we can use them for numerical calculations.\nFor instance, we might want to know what the mean mark was for this sample of quiz marks. To do this, we could make use of a very handy function, mean(), as follows:\n\nmean(quiz_9am)\n\n[1] 52\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCalculate the mean of each of the two sets of scores you created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhether you save the output of the mean() command is up to you!\n\nmean(quiz_9am)\n\n[1] 52\n\nmean(quiz_6pm)\n\n[1] 55.85714\n\n\n\n\n\nCalculate the difference in the mean of each of the two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nHere are two options for accomplishing this.\nThe first option is to save each mean value in a new object (if you didn’t do that already), then subtract one mean from the other. This is very easy to read, but a bit inefficient.\n\nmean_9am &lt;- mean(quiz_9am)\nmean_6pm &lt;- mean(quiz_6pm)\n\nmean_9am - mean_6pm\n\n[1] -3.857143\n\n\nThe second option is to do everything in one command, which takes a bit more effort to parse but is more succinct.\n\nmean(quiz_9am) - mean(quiz_6pm)\n\n[1] -3.857143\n\n\n\n\n\nWhat is the class of these objects?\n\n\n\n\n\n\nSolution\n\n\n\n\n\nEither one will do.\n\nclass(quiz_9am)\n\n[1] \"numeric\"\n\n\nSo, an object has the class of the data it contains.\n\n\n\n\n\n\n\n\n\n\n\nObject Names vs Strings\n\n\n\nYou may have been surprised to see that the class of these objects is numeric, rather than character - even though the name of the object is a character string. To find out the class of the object, R looks at what that object contains, not at the name of the object itself. We already saw that quiz_9am (or whatever your object is called) contains only numbers; so, R tells us that it’s a numeric vector.\nOne more example to emphasize this point, because it’s often a source of confusion when starting out with R. If we want to ask R the class of the string “quiz_9am”, we would need to put it in quotes, and we’d get a different answer:\n\nclass(\"quiz_9am\")\n\n[1] \"character\"\n\n\nThe key thing here is that objects have the class of the data they contain, and are not character data; and whenever you want to use an object, you must not use quotation marks. On the other hand, if you want to input character data into R, you must use quotation marks. Otherwise, R will look for an object or function with that name, which will likely produce a “cannot find object” error.\n\n\nBecause we’ve used the assignment operator, R doesn’t print out the years. Instead, the output of our calculation is saved as the object birth_year. Hmm - didn’t we already have an object called birth_year, though? What happened to it?\n\n\n\n\n\n\nImportant: Overwriting Objects\n\n\n\nYou might notice that we already had an object called birth_year that we created above. R, again, does only and exactly what you ask it to do. Unlike, say, a word processer, that will give you a warning if you try to save two documents in the same folder with the same name, R won’t ask you if you’re sure you want to overwrite an existing object with new information - it will just do it. If you have a look in your Environment, you will see that the previous version of birth_year, containing only your birth year, has been quietly replaced with the new one containing the vector of birth years you just created.\nThis can be a good thing, because you can easily update the information stored in an object with changes, edits, or new information. However, it also means that you can overwrite or replace data when you don’t want to, if you use the same object name.\nThis is why it is so important to keep track of all of the commands and changes you make to your data. If you accidentally replace your dataset with, say, a single word or number with an error in your code, you can easily retrace your steps and avoid redoing work.\nIf you are interested in understanding this process of assigning and replacing the contents of objects better, the aside below explains it in more depth.\n\n\n\n\n\n\nCan you actually change an object?\n\n\n\n\n\nThink of objects as boxes. The names of the objects are only labels, and you can store anything you like inside them. However, unlike in the physical world, objects in R cannot truly change. You can put stuff in and take stuff out, and that’s pretty much it. Unlike boxes, though, when you take stuff out of objects, you only take out a copy of its contents. The original contents of the box remain intact. Of course, you can do whatever you want (within limits) to the stuff once you’ve taken it out of the box, but you are only modifying the copy. The key thing to remember is that unless you put that modified stuff into a box, R will forget about it as soon as it’s done with it. In other words, if you want to “save” any changes you make, you must assign them to an object in order to keep them.\nNow, as you probably know, you can call your boxes (objects) whatever you want (again, within certain limits). This means that that you can call the new box the same as the old one, as we saw with birth_year above. When that happens, R basically takes the label off the old box, pastes it on the new one, and burns the old box. So even though some operations in R may look like they change objects, what’s actually happening is that R copies their content, modifies it, stores the result in a different object, puts the same label on it, and discards the original object. Understanding this mechanism will make things much easier!\nPutting the above into practice, this is how you “change” an R object:\n\n# put 1 into an object (box) called a\na &lt;- 1\n\n# copy the content of a, add 1 to it and store it in an object b\nb &lt;- a + 1\n\n# copy what's inside b and put it in a new object called a\n# discarding (\"overwriting\") the old object a\na &lt;- b\n\n# now see what's inside of a\n# (by copying its content and pasting it in the console)\na\n\n[1] 2\n\n\nOf course, you can just cut out the middleman (creating an object b). So to increment a by another 1, we can do:\n\na &lt;- a + 1\n\na\n\n[1] 3\n\n\n\n\n\n\n\nWe will talk further about using scripts and writing multiple commands below; but first, we’ll need to have a look at a very important type of object in R: the function."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#functions",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#functions",
    "title": "01: IntRoductions I",
    "section": "Functions",
    "text": "Functions\nFunctions are like verbs in the R language - they’re how R does anything. In order to use them, you need to “translate” the command you want to give R into a verb (function) it can understand.\n\nBasics and Help\nLet’s look at an example of how this translation might work. For this example, I’m going to use a number I generated earlier: the mean of the quiz_6pm group, which was 55.8571429, which I’d like to round to two decimal places - a common task for reporting results in APA style.\nIf we want R to do this for us, we have to write this command in a way that R can understand. First, we need to know what function corresponds to the English verb “round” - that is, what function will do the same action that we want R to perform. We’re lucky in this case: the function in R is also called round(). (See the box below for more on how to find the function you want.)\nWe know that we’re looking at a function in R because functions always have a name followed by brackets. That is, they always have the general form function_name(). Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.\n\n\n\n\n\n\nExercise\n\n\n\nTry running the round() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround()\n\nError in eval(expr, envir, enclos): 0 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nUnsurprisingly, R has given us an error. This is an informative error, though - that is, the error gives of some sort of intelligible clue about what’s gone wrong. Namely, it tells us that round() can’t just work without additional information (i.e. “required arguments”). Imagine, for instance, if you wanted a colleague to round 55.8571429 to two decimal places, and in order to ask them to do that, you just shouted “ROUND!” at them. Similarly, R has objected to this, telling you that it needs more information in order to do what you’ve asked it to.\n\n\n\n\n\nWhat we want to do, “Round the number 55.8571429 to two decimal places”, has two more important pieces of information that we need to tell R: what number we want to round (55.8571429) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let’s look at the help documentation.\n\n\n\n\n\n\nExercise\n\n\n\nOpen the help documentation for the round() function by running ?round() or help(round) in the Console.\n\n\n\n\n\n\n\n\nHelp Documentation\n\n\n\nHelp documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it’s a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running ?function_name or help(function_name) in the Console, or by clicking on the “Help” tab in the Files section of RStudio and using the Find box to search for the function.\n\n\nThe first section, “Description”, varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function including in this document, we can see that we have a useful description of round() that tells us that it rounds numbers (that’s a good sign) to a certain number of decimal places. That’s exactly what we want, so how do we use it?\nLet’s scroll down to “Usage”, which gives examples of what the function looks like. You can see that the basic structure of this function is round(x, digits = 0). It seems like we need to add some more information in the brackets of our function - but how do we interpret x and digits = 0?\n\n\nArguments\nThe information inside a function’s brackets to give it the information it needs to work are called arguments. Each argument in a function is separated by a comma, so we can see from round(x, digits = 0) that the round() function can take two arguments. How many arguments a function has depends on the function; some (like Sys.Date()) don’t need any arguments to run. One of the most useful parts of a function’s help documentation is the “Arguments” section, which tells you what each of the function’s arguments are and how to use them.\nThere are two main types of arguments: named and unnamed arguments. Conveniently, the arguments of round() give us one example of each.\n\nUnnamed Arguments\nThe first argument to round() is simply x. Just like in maths, x is a placeholder for some number or numbers (a “numeric vector”, which should sound familiar now) that you want to pass to the function. This is common notation in many functions: x, often the first argument in a function, is often the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that’s what we should replace with x.\nThis argument has no default so it must be provided, or the function won’t run.\n\n\nNamed Arguments\nThe second argument of round() is a named argument, digits = 0. You can think of named arguments like settings that change the way a function works, often with only certain allowable values. Here we can see that the name of the argument is digits; the name before the = sign tells R which setting we want to change.\nThe help documentation tells us that digits should be an “integer indicating the number of decimal places…to be used.” We can also see in “Usage” that this argument has a default value, digits = 0. That means that if we don’t explicitly include the argument digits when we use the function, by default the round() function will round the number you give it to 0 decimal places. Named arguments frequently, but not always, have a default, and it’s important to check so the function doesn’t quietly do something unexpected.\nDefault values of arguments are really useful, because the default is usually the most frequently used setting. It means you don’t have to specify every single aspect of a function every time you use it, as long as you want the function to work that way! In our case, we actually wanted round() to round to two decimal places, not 0. So, in our command, we should change the setting from the default, 0, to 2.\n\n\n\nUsing Functions\nNow that we know what both of these arguments mean, we can change them to actually translate the English sentence “Round the number 55.8571429 to two decimal places” into a command that R can work with. We’ll explicitly write out each argument so we know what they are doing.\n\n\n\n\n\n\nExercise\n\n\n\nUse the round() function to round 55.8571429 to two decimal places.\nIf you prefer, you can do this with one of the means you calculated for your own scores earlier.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Using the actual value from my earlier calculation\nround(55.85714, 2)\n\n[1] 55.86\n\n## Using a nested function - that is, calculating the mean and then rounding it!\nround(mean(quiz_6pm), 2)\n\n[1] 55.86\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\n\n\n\nIf you want to, you can achieve the same result by changing the order of the arguments. Because we have written the names of both arguments, R can still do what we want it to do:\n\nround(digits = 2, x = 55.85714)\n\n[1] 55.86\n\n\nWe can also, to some degree, drop the names of the arguments, as long as R can still understand what we’re trying to do:\n\nround(digits = 2, 55.85714)\n\n[1] 55.86\n\n\nHere I left out the x =. R can still understand this because round() only takes two arguments, and we explicitly told it what value belongs to digits, so it assumes the second number must be x.\n\nround(55.85714, 2)\n\n[1] 55.86\n\n\nThis time I dropped both argument names. R can still understand this because when you don’t specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 55.85714 to x and 2 to digits, which is what we wanted.\nAs I use R more and more, I find that I name arguments more consistently, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That’s because when I come back from lunch, or the next day, or six months later to revisit the same code, it’s much easier to recall what it all means when it’s well-annotated. So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:\n\nround(2, 55.85714)\n\n[1] 2\n\n\nHere, since we didn’t specify, R assumed that 2 was the number we wanted to round. This isn’t what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.\n\n\n\n\nPassing Multiple Values to Arguments\nA last important aspect of using functions is to remember that each argument in a function can only take a single object or value as input. For example, we saw above that we put the single value 55.85714 into the x argument of round(). But what if we wanted to round more than one number? We don’t want to have to write a new round() command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:\n\nround(55.85714, 2)\n\n[1] 55.86\n\n## ughhhh\nround(59.54, 2)\n\n[1] 59.54\n\n## noooooo :(\nround(0.198, 2)\n\n[1] 0.2\n\n## thanks I hate it\n\n\n\n\n\n\n\nExercise\n\n\n\nBefore you go on, have a go using a single round() command to round all three numbers at once.\nHint: Refer to Vectors.\n\n\nSo what happens if we try to put all of those numbers into round()? We might first try this:\n\nround(55.85714, 59.54, 0.198, 2)\n\nError in eval(expr, envir, enclos): 4 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nOnce again, R tells us that this doesn’t work by throwing an error. R has tried to do what we wanted, but the round() function only allows a max of two arguments, and we’ve given it four. Behind the scenes, R has tried to run round(x = 55.85714, digits = 59.54... and can’t proceed from there because it doesn’t know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first x argument together. If only there was a way to concatenate them together…\nYou may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a single object, and then pass that object to round() as the x argument. We already saw that we can combine any number of things together into a single vector using the c() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n## Create an intermediate object to contain the numbers\nnumbers &lt;- c(55.85714, 59.54, 0.198)\nround(numbers, digits = 2)\n\n[1] 55.86 59.54  0.20\n\n## Put the vector of numbers into round() directly\nround(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] 55.86 59.54  0.20\n\n\n\n\nHere we can see a good example of a function inside another function. You can stack, or “nest”, functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it’s doing. (There’s a great solution to this problem that we’ll make extensive use of in the future: the pipe operator.)\nThat’s looking like some proper R code! Very nicely done.\n\n\n\n\n\n\nHelp Documentation, Revisited\n\n\n\nBefore we leave the round() function altogether, let’s take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the “Details” section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn’t doing what you expect it to, this is a good place to look for an explanation.\nFinally, at the end of the documentation you can find the “Examples” section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the “Run examples” link, which will run the code in the Examples section for you so you can see what the function will do."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#packages",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#packages",
    "title": "01: IntRoductions I",
    "section": "Packages",
    "text": "Packages\nIn this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nDefinition: Package\n\n\n\nA package is a collection of code, maybe containing functions, data, or other useful bits. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\n\n\n\nRounding, Revisited\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do2.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\n\n\n\n\n\nExercise\n\n\n\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\n\nInstalling Packages\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\n\n\n\n\n\nExercise\n\n\n\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\ninstall.packages(\"weights\")\n\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\n\n\n\n\nExercise\n\n\n\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\nLoading Packages\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\n\n\n\n\n\nExercise\n\n\n\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\n\n\n\n\nExercise\n\n\n\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\n\n\n\n\n\nThird time lucky!\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type. You can do it either way - it’s up to you!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#footnotes",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#footnotes",
    "title": "01: IntRoductions I",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs a linguist I have to note, one, words don’t exist, and two, the closest linguistic term for what an object is is probably “lexeme”. “Word” will get you in the right vicinity, though, conceptually. If you’d like to dive down this rabbit hole (rabbit-hole?) this Crash Course video on morphology is a good place to start.↩︎"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html",
    "href": "tutorials/02_essentials/05_changes.html",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "This tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset.\n\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#getting-started",
    "href": "tutorials/02_essentials/05_changes.html#getting-started",
    "title": "05: Mutate and Summarise",
    "section": "Getting Started",
    "text": "Getting Started\n\nUsing This Tutorial\n\n\nSetting Up\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#mutate",
    "href": "tutorials/02_essentials/05_changes.html#mutate",
    "title": "05: Mutate and Summarise",
    "section": "Mutate",
    "text": "Mutate\nThe mutate() function is one of the most essential functions from the dplyr package. Its primary job is to easily and transparently make changes within a dataset - in particular, a tibble.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::mutate(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\nUsage\nvariable_name is the name of the variable that will be changed by mutate(). This can be any name that follow’s R’s object naming rules. There are two main options for this name:\n\nIf the dataset does not already contain a variable called variable_name, a new variable will be added to the dataset.\nIf the dataset does already contain a variable called variable_name, the new variable will silently1 replace (i.e. overwrite) the existing variable with the same name.\n\ninstructions_for_creating_the_variable tells the function how to create variable_name. These instructions can be any valid R code, from a single value or constant, to complicated calculations or combinations of other variables. You can think of these instructions exactly the same way as the vector calculations we covered earlier, and they must return a series of values that is the same length as the existing dataset.\n\n\nExample\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    group = \"control\",\n    score = \n  )\n\n\n1\n\nTake the dataset\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAlthough creating or modifying variables will likely be the most frequent way you use mutate(), it has other handy features such as:\n\nDeleting variables\nDeciding where newly created variables appear in the dataset\nDeciding which variables appear in the output, depending on which you’ve used\n\nSee the help documentation for more by running help(mutate) or ?mutate in the Console.\n\n\n\n\n\nComposite Scores\n\nRow-wise magic is good magic. -Hadley Wickham\n\nA very common mutate() task is to create a composite score from multiple variables - for example, an overall anxiety score from a questionnaire with ten items on anxiety. Imagine we wanted to create an overall score that is the mean of the ratings on each of those ten items, for each participant.\nTo do this, we need two new functions.\n\nThe first new function, dplyr::c_across(), provides an efficient way to select multiple variables to contribute to the calculation - namely, by using &lt;tidyselect&gt; semantics.\nThe second new function is actually a pair of functions, dplyr::rowwise() and dplyr::ungroup(). These two respectively impose and remove an internal structure to the dataset, such that each row is treated like its own group, and any operations are done within those row-wise groups.\n\nLet’s see the combination of these two in action.\n\n\n\n\n\n\nImportant\n\n\n\nThe code below assumes a dataset structured so there is information from each participant on only and exactly one row in the dataset, i.e “wide” format.\nIf your data is tidy with observations from the same participants on multiple rows, you will need to reshape your data or otherwise adapt the code to suit your data structure.\n\n\n\n1my_tibble |&gt;\n2  dplyr::rowwise() |&gt;\n3  dplyr::mutate(\n    anxiety_score = mean(c_across(starts_with(\"anxiety\")),\n                        na.rm = TRUE)\n  ) |&gt;\n4  dplyr::ungroup()\n\n\n1\n\nTake the dataset, and then -\n\n2\n\nGroup the dataset by row. This means that any subsequent calculations will be done for each row separately.\n\n3\n\nCreate the new anxiety_mean variable. The new function c_across() works quite similar to c() - namely, creating a vector of variables for mean() to take the mean of. However, it has the advantage of allowing &lt;tidyselect&gt; for choosing the variables, instead of having to type them out one by one.\n\n4\n\nRemove the by-row grouping that was created by rowwise(). Otherwise, all other subsequent operations on this dataset will continue to be performed within each row. (This isn’t typically the desired behaviour for this task, but it can be quite useful in other scenarios!)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor lots more details and examples on rowwise() and rowwise operations with dplyr - including which other scenarios in which a row-wise dataset would be useful - run vignette(\"rowwise\") in the Console.\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWhat would the above code produce without the rowwise()...ungroup() steps (i.e. with only the mutate() command)? Make a prediction, then try it.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe can see what happens without rowwise()...ungroup() just by commenting them out of the pipe. To do this, either type # before each line, or highlight them and press CTRL/CMD + SHIFT + C.\n\nmy_tibble |&gt; \n  # dplyr::rowwise() |&gt; \n  dplyr::mutate(\n    anxiety_score = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) # |&gt; don't forget to comment out this pipe or you'll get an error\n  # dplyr::ungroup()\n\nThis code still runs successfully, but the result isn’t what we wanted. Have a look at the anxiety_mean variable: all the values are the same. Instead of calculating the mean for each person, this code instead calculated the overall mean of all of the anxiety variables, and then assigned that single value to the anxiety_mean variable. Not what we wanted in this case - but it could be useful in other scenarios!\n\n\n\nThe above code is definitely not the only way to obtain the same output. Try producing the the same anxiety_mean variable with the following methods. What are the benefits and drawbacks of each methods? Hint: Use vignette(\"rowwise\") to help if you get stuck.\n\nUsing a dedicated by-row function, rowMeans()\nUsing the basic structure of mutate() only\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf we wanted to avoid, or didn’t remember, the rowwise()...ungroup() sequence, there are other options to produce the same result, but neither are easier to read or implement.\n1. Using rowMeans\nThe base function rowMeans() calculates the mean of each row without any additional jiggery pokery to worry about. The problem is specifying which variables to include, especially because we have ten in this example to work with.\nHowever, rowMeans() is an independent function who doesn’t need no dplyr, and as such does not work the same way, for instance, mean() does, with no straightforward workaround.\n\n## Reasonable but just doesn't work!\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(c(anxiety_1, anxiety_2, anxiety_3..., anxiety_10))\n  )\n\nError in dplyr::mutate(my_tibble, anxiety_score = rowMeans(c(anxiety_1, : object 'my_tibble' not found\n\n\nThis is because rowMeans() is expecting a whole dataset, not just a subset of columns. You can solve this by select()ing within the rowMeans() function:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(dplyr::select(my_tibble, anxiety_1, anxiety_2...))\n  )\n\n…which has the major issue that if you update the name of your dataset, you must update it in TWO places - at the start of the pipe and inside rowMeans(), along with just being a huge mess.\nAlternatively, you can use dplyr::pick() with &lt;tidyselect&gt; semantics to make this less, well, terrible:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(pick(contains(\"anxiety\")))\n  )\n\n…which didn’t seem fair because we haven’t talked about pick(), and also defeated the purpose of using rowMeans() to avoid having to learn new dplyr functions. So, dplyr wins this one either way.\nIf you’re keen to never have to learn a jot more dplyr than absolutely necessary (I bet you are not having a good time so far!), this Stack Overflow post offers some other, non-dplyr solutions…that also depend on using the magrittr pipe %&gt;%! Sorry.\n2. Use basic mutate()\nThe most straightforward method - although perhaps not the most obvious - is to express the calculation you want as arithmetic using the relevant variables. In this instance, to calculate a mean, we sum the scores together and then divide by the number of scores:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = (anxiety_1 + anxiety_2 + ... + anxiety_10)/10\n  )\n\nThis method, although very transparent, has some critical downsides.\n\nIt’s clunky and prone to error. This style works best for 2-3 variables contributing to the composite. For more variables, we end up with a lot of repetitive typing, which also means increased likelihood of typos, accidental omissions, or other errors - especially with a large number of variables, as we have here.\nIt’s not robust. Imagine that, on review of the anxiety scale, we find that anxiety_9 is a badly worded/unreliable item and decide to drop it from our analysis. We then either have to (remember to) manually update our code both to remove anxiety_9 and to change the denominator from 10 to 9 (not a good time), or debug the resulting error if we don’t remember.\n\nWe do teach this method to UGs specifically to reduce the number of functions they have to learn, but for real-life usage, in most cases, the rowwise() solution is likely preferable.\n\n\n\n\n\n\n\nConditionals\nThere are many functions out there for recoding variables, but the following method, using dplyr::case_when(), is recommended because it is so versatile. It can be used to recode the values from one variable into new one, but it can also combine information across variables and handle multiple conditionals. It essentially allows a series of if-else statements without having to actually have lots of if-else statements.\nThe generic format of case_when() can be stated as follows:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    new_variable = dplyr::case_when(\n      logical_assertion ~ value,\n      logical_assertion ~ value,\n      .default = value_to_use_for_cases_with_no_matches\n    )\n  )\n\n\nUsage\nlogical_assertion is any R code that returns TRUE and FALSE values.\nvalue is the value to assign to new_value for the cases for which logical_assertion returns TRUE.\nThe assertions are evaluated sequentially (from first to last in the order they are written in the function), and the first match determines the value. This means that the assertions must be ordered from most specific to least specific.\n\n\n\n\n\n\nTesting Assertions\n\n\n\n\n\nThe assertions for case_when() are the same as the ones we used previously in filter(). In fact, if you need to test the assertion you are writing to ensure that your code will work as you want, you can try the same assertion in filter() to check whether the cases it returns are only and exactly the once you want to change.\n\n\n\nLet’s look at two examples of how dplyr::case_when() might come in handy.\n\nOne-Variable Input\nWe’ve created our composite anxiety_mean variable previously, and now we may want to change this continuous score into a categorical variable indicating whether or not participants display clinical levels of anxiety. So, we can use case_when() to recode anxiety_mean into a new anxiety_cat variable.\n\n1anxiety_cutoff &lt;- 35\n\n2my_tibble |&gt;\n3  dplyr::mutate(\n4    anxiety_cat = dplyr::case_when(\n5      anxiety_score &gt;= anxiety_cutoff ~ \"anx\",\n6      anxiety_score &lt; anxiety_cutoff ~ \"control\",\n7      .default = NA\n    )\n  )\n\n\n1\n\nCreate a new object, anxiety_cutoff, containing the threshold value for separating clinical from non-clinical anxiety. This one is from REFERENCE.\n\n2\n\nTake the dataset, and then…\n\n3\n\nMake a change to it by…\n\n4\n\nCreating a new variable, anxiety_cat, by applying the following rules:\n\n5\n\nFor cases where the value of anxiety_mean is greater than or equal to anxiety_cutoff, assign the value “anx” to anxiety_cat\n\n6\n\nFor cases where the value of anxiety_mean is less than anxiety_cutoff, assign the value “control” to anxiety_cat\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign NA to anxiety_cat\n\n\n\n\n\n\n\n\n\n\nWhy the new anxiety_cutoff object?\n\n\n\n\n\nIn the code above, the cutoff value is stored in a new object, anxiety_cutoff, which is then used in the subsequent case_when() conditions. Why take this extra step?\nThis is a matter of style, since the output of this code would be entirely identical if I wrote the cutoff value into the case_when() assertions directly (e.g. anxiety_mean &gt;= 35). I have done it this way for a few reasons:\n\nThe threshold value is easy to find, in case I need to remind myself which one I used, and it’s clearly named, so I know what it represents.\nMost importantly, it’s easy to change, in case I need to update it later. I would only have to change the value in the object once, at the beginning of the code chunk, and all of the subsequent code using that object would be similarly updated.\n\nIn short, it makes the code easier to navigate, more resilient to later updates, and more transparent in its meaning.\n\n\n\n\n\nMulti-Variable Input\nWe might also like to create a useful coding variable to help keep track of the number of cases we’ve removed, and for what reasons. We can draw on input from multiple variables to create this single new variable.\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    remove = dplyr::case_when(\n2      distribution == \"Preview\" ~ \"preview\",\n3      info_consent != \"Yes\" ~ \"no_consent\",\n4      age &lt; 18 ~ \"age_young\",\n5      is.na(age) | age &gt; 100 ~ \"age_bad\",\n6      !grepl(\"eng\", tolower(fluent_lang)) ~ \"english_no\",\n7      .default = \"keep\"\n    )\n  )\n\n\n1\n\nTake the dataset my_tibble and make a change to it by a creating a new variable, remove, by applying the following rules\n\n2\n\nFor cases where the distribution variable contains exactly and only “Preview”, assign the value \"preview\". This is a common task for Qualtrics surveys to remove practice runs.\n\n3\n\nFor cases where the info_consent variable does NOT contain exactly and only the value “Yes”, assign the value \"no_consent\". This includes anyone who did not actively consent - both people who chose options OTHER than “Yes” (e.g. “No”), and people who did not respond.\n\n4\n\nFor cases where the numerical value in age is less than 18, assign the value \"age_young\".\n\n5\n\nFor cases where the value is age is NA, or is greater than 100, assign the value \"age_bad\".\n\n6\n\nFor cases where the value in fluent_lang, once converted to lowercase, does NOT contain the letters “engl”, assign the value \"english_no\". This searches open text responses to a question like “What languages do you speak fluently?” for the string “engl”.\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign the value \"keep\".\n\n\n\n\nBecause the first match for each case is the value it is assigned, each case will receive only one value, even if they match multiple criteria. For example, if you had a participant who gave their age as 17 and their fluent languages as Finnish and German, they would be coded as age_young rather than english_no because the assertion about age comes before the assertion about language. (This is sensible behaviour, because being 18 or older is an ethical requirement, whereas speaking English fluently likely isn’t.)\nFrom here, you can easily use this variable to summarise exclusions, and to filter out excluded cases for your final dataset.\n\n1my_tibble |&gt;\n  dplyr::count(remove)\n\n2final_tibble &lt;- my_tibble |&gt;\n  dplyr::filter(remove == \"keep\")\n\n\n1\n\nTake my_tibble and count the number of times each unique value occurs in the remove variable.\n\n2\n\nCreate a new object, final_tibble, by taking my_tibble and then retaining only the cases for which the remove variable has only and exactly the value \"keep\" - effectively dropping all other cases.\n\n\n\n\n\n\n\n\n\n\nRecoding Factors\n\n\n\n\n\nWhat about recoding or relabeling factors? For example, imagine a dataset where gender has been collected as 1, 2, and 3, with 1 corresponding to “Female”, 2 to “Male”, and 3 to “Nonbinary/third gender”. You\n\n\n\n\n\n\n\nIteration\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    dplyr::across(&lt;tidyselect&gt;, function_to_apply)\n  )"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#summarise",
    "href": "tutorials/02_essentials/05_changes.html#summarise",
    "title": "05: Mutate and Summarise",
    "section": "Summarise",
    "text": "Summarise\nThe summarise() function looks almost exactly like mutate, with almost identical syntax. However, its primary job is to quickly generate summary tables from datasets.\n\nBasic Structure\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\n\n\n\n\nImportant\n\n\n\nYou may notice that the basic structure of summarise looks identical to the basic structure of mutate, above. The difference is that mutate creates or replaces variables within the same dataset, while summarise creates a new summary dataset without changing the original.\n\n\n\nUsage\nvariable_name is the name of a variable that will created in the new summary tibble. This can be any name that follow’s R’s object naming rules.\ninstructions_for_creating_the_variable tells the function how to create variable_name. The instrutions can refer to variables in the piped-in dataset, but should output a single value, rather than a vector of values (as we saw in mutate()).\n\n\nExample\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\n\n\n\nBy Group\nBasic summary tables are fine, but the real power of summarise() is in combination with the helper function dplyr::group_by() to split up the summary calculations by the values of a grouping variable.\nSimilar to what we saw with rowwise(), group_by() creates internal structure in the dataset - a new group for each unique value in the grouping variable. Any subsequent calculations done with the dataset are done within those groups.\n\nExample\n\n1my_tibble |&gt;\n  dplyr::group_by(anxiety_cat) |&gt;\n2  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\nmy_tibble |&gt;\n3  dplyr::group_by(anxiety_cat, gender) |&gt;\n  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\n\n1\n\nTake the dataset, and then group by the values in the anxiety_cat variable that we created earlier.\n\n2\n\nProduce a summary table of the mean and SD of the anxiety_mean variable. Compare this to the ungrouped summary in the previous section - it’s the same columns, but a new row for each group.\n\n3\n\nGroup by multiple grouping variables, separated by a comma.\n\n\n\n\n\n\n\n\n\n\nReshaping Summary Tables\n\n\n\n\n\nThe second summary table, grouped by both anxiety diagnosis and gender, would likely be easier to read with one variable on separate rows and the other in separate columns. To learn how to reshape a summary table, see Tutorial 10.\n\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIteration\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\nDespite the versatility of summarise(), you may have already noticed that the code covered so far is very typing-intensive if you want information about more than one variable. This is neither efficient nor particularly enjoyable:\n\n## Down with this sort of thing!\nmy_tibble |&gt;\n  dplyr::group_by(anxiety_cat) |&gt; \n  dplyr::summarise(\n    mean_anx = mean(anxiety_score, na.rm = TRUE),\n    sd_anx = sd(anxiety_score, na.rm = TRUE),\n    mean_autism = mean(autism_score, na.rm = TRUE),\n    sd_autism = sd(autism_score, na.rm = TRUE),\n    mean_ext = mean(extroversion_score, na.rm = TRUE),\n    sd_ext = sd(extroversion_score, na.rm = TRUE)\n  )\n\nIf we wanted to also include, for instance, range and CIs, this code would quickly become unmanageably long and difficult to read, not to mention increasingly prone to errors.\nThere are two main solutions to this issue, and which you choose depends on what you want the output to contain and how much work you want to put into reading the help documentation of various functions.\n\nOption 1: Use an Existing Function\n\n\n\n\n\n\nChoose this option if:\n\n\n\n\nYou just want the basic descriptives and don’t need grouped summaries\nYou don’t mind reading up in the help documentation to get the right combination of arguments, and/or trying out a few different functions/packages to find the one that works for you.\n\n\n\nAs we saw in Tutorial 03: Datasets, there are existing functions that output pre-made summaries across multiple variables. If you revisit datawizard::describe_distribution(), you will find in the help documentation that it can utilise &lt;tidyselect&gt; syntax to select the variables you want, and the output can even be forced into a tibble for further wrangling.\n\n\nOption 2: Function List + across()\n\n\n\n\n\n\nChoose this option if:\n\n\n\n\nYou want custom or complex summary information and/or you want grouped summaries\nLike me, you just want to do everything yourself so you know it’s exactly right.\n\n\n\nThe big, inefficient multi-variable summarise() command above has two main issues to resolve.\n\nWe had to type the same functions over and over (i.e. mean() and sd() are repeated for each variable). Instead, we’ll create a list of functions to use, so we only have to type out each function once.\nWe had to manually type in each variable name we want to use. Instead, we’re going to utilise dplyr::across() to apply the list of functions from the first step to variables selected with &lt;tidyselect&gt;.\n\n\n\n\n\n\n\nTip\n\n\n\nFor more explanation about dplyr::across(), see the section on iteration with mutate() earlier on. For a much more in-depth explanation, run vignette(\"colwise\") in the Console.\n\n\n\n\nExample\n\n1fxs &lt;- list(\n2  mean = ~ mean(.x, na.rm = TRUE),\n  sd = ~ sd(.x, na.rm = TRUE)\n)\n\npeng |&gt; \n  dplyr::group_by(island) |&gt; \n  dplyr::summarise(\n3    across(where(is.numeric), fxs)\n  )\n\n\n1\n\nTo begin, create a new object containing a list. I’ve called mine fxs, short for “functions”, but you can of course call it anything you like.\n\n2\n\nThe elements inside the list have a special format. The first bit, e.g. mean =, gives each element a name. This name will be appended to the relevant column in the summarise() output, so choose something informative. The second bit, e.g. ~ mean(.x, na.rm = TRUE), is the function we want to apply to each variable. The two things to note are the ~, which denotes “this is a function to apply”, and .x, which is a placeholder for each of the variables that the function will be applied to.\n\n3\n\nInstead of using the familiar name = instructions format, we’re instead using across(). Generally, across() has two arguments. The first selects which variables to use using &lt;tidyselect&gt;; in this case, I’ve selected all of the numeric-type variables in the dataset (since it will be difficult to calculate the mean and SD otherwise!). The second provides a list of function(s) to apply to all of the selected variables. So, I’ve put in the list I made in the previous steps that contains all the functions I want to use.\n\n\n\n\n# A tibble: 3 × 11\n  island bill_…¹ bill_…² bill_…³ bill_…⁴ flipp…⁵ flipp…⁶ body_…⁷ body_…⁸ year_…⁹\n  &lt;fct&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Biscoe    45.3    4.77    15.9    1.82    210.   14.1    4716.    783.   2008.\n2 Dream     44.2    5.95    18.3    1.13    193.    7.51   3713.    417.   2008.\n3 Torge…    39.0    3.03    18.4    1.34    191.    6.23   3706.    445.   2008.\n# … with 1 more variable: year_sd &lt;dbl&gt;, and abbreviated variable names\n#   ¹​bill_length_mm_mean, ²​bill_length_mm_sd, ³​bill_depth_mm_mean,\n#   ⁴​bill_depth_mm_sd, ⁵​flipper_length_mm_mean, ⁶​flipper_length_mm_sd,\n#   ⁷​body_mass_g_mean, ⁸​body_mass_g_sd, ⁹​year_mean\n\n\nThis function list + across() method is extremely versatile. If you are using a lesser-known statistical technique, or even functions of your own making, you can easily add them to your list of functions and apply them with across()."
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#footnotes",
    "href": "tutorials/02_essentials/05_changes.html#footnotes",
    "title": "05: Mutate and Summarise",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere, “silently” means that R overwrites the existing variable without flagging that it is doing this or asking you if you are sure, so it’s important to be aware of this behaviour (and to know what variables already exist in your dataset).↩︎"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#overview",
    "href": "tutorials/02_essentials/05_changes.html#overview",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "This tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset.\n\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/02_essentials/05_changes.html#next-steps",
    "href": "tutorials/02_essentials/05_changes.html#next-steps",
    "title": "05: Mutate and Summarise",
    "section": "Next Steps",
    "text": "Next Steps\nThe next tutorial applies everything we’ve covered so far to the creation of beautiful and professional data visualisations.\n\n\n\n\n\n\nFor more on…\n\n\n\n\nReshaping summaries into nicely formatted, publication-worth tables, see Tutorial 10: Reshaping and Merging\nUsing &lt;tidyselect&gt;, see Tutorial 04: Filter and Select\nRow-wise and column-wise operations, run vignette(\"rowwise\") and vignette(\"colwise\") respectively in the Console."
  },
  {
    "objectID": "tutorials/02_essentials/04_filter.html",
    "href": "tutorials/02_essentials/04_filter.html",
    "title": "04: Filter and Select",
    "section": "",
    "text": "This tutorial covers two important dplyr functions: filter() and select(). Easy to confuse, filter() uses logical assertations to return a subset of rows (cases) in a dataset, while select() returns a subset of the columns (variables) in the dataset.\n\n\n\n\n\n\nTip\n\n\n\nTo remember which does which:\n\nfilter() works on rows, which starts with “r”, so it contains the letter “r”.\nselect() works on columns, which starts with “c”, so it contains the letter “c”.\n\n\n\n\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.3.1\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'tibble' was built under R version 4.3.1\n\n\nWarning: package 'tidyr' was built under R version 4.3.1\n\n\nWarning: package 'readr' was built under R version 4.3.1\n\n\nWarning: package 'purrr' was built under R version 4.3.1\n\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\n\nWarning: package 'stringr' was built under R version 4.3.1\n\n\nWarning: package 'forcats' was built under R version 4.3.1\n\n\nWarning: package 'lubridate' was built under R version 4.3.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "tutorials/02_essentials/04_filter.html#overview",
    "href": "tutorials/02_essentials/04_filter.html#overview",
    "title": "04: Filter and Select",
    "section": "",
    "text": "This tutorial covers two important dplyr functions: filter() and select(). Easy to confuse, filter() uses logical assertations to return a subset of rows (cases) in a dataset, while select() returns a subset of the columns (variables) in the dataset.\n\n\n\n\n\n\nTip\n\n\n\nTo remember which does which:\n\nfilter() works on rows, which starts with “r”, so it contains the letter “r”.\nselect() works on columns, which starts with “c”, so it contains the letter “c”.\n\n\n\n\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.3.1\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'tibble' was built under R version 4.3.1\n\n\nWarning: package 'tidyr' was built under R version 4.3.1\n\n\nWarning: package 'readr' was built under R version 4.3.1\n\n\nWarning: package 'purrr' was built under R version 4.3.1\n\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\n\nWarning: package 'stringr' was built under R version 4.3.1\n\n\nWarning: package 'forcats' was built under R version 4.3.1\n\n\nWarning: package 'lubridate' was built under R version 4.3.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "tutorials/02_essentials/04_filter.html#filter",
    "href": "tutorials/02_essentials/04_filter.html#filter",
    "title": "04: Filter and Select",
    "section": "Filter",
    "text": "Filter\nThe filter() function’s primary job is to easily and transparently subset the rows within a dataset - in particular, a tibble. filter() takes one or more logical assertions and returns only the rows for which the assertion is TRUE. Columns are not affected by filter()`, only rows.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::filter(\n    logical_assertion\n  )\n\n\nUsage\nlogical_assertion is a statement that returns logical values, just like the assertions we saw in the first tutorial. The rows where the assertion returns TRUE will be included in the output; those that return FALSE will not. Inside the filter() command, use the names of the variable in the piped dataset to create the logical assertions.\n\n\nExamples\nTo include:\n\nNumerical comparisons, dplyr::between()\n%in%, grepl()\nTASK: Filter on some example\n\n\n\n\n\n\n\nMultiple Conditions\n\nOR | and AND &\nComma defaults to AND\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Cleaning\n\nKeeping only people who consented\nFiltering by age\nDealing with missing data\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\n\n\n\nSolution"
  },
  {
    "objectID": "tutorials/02_essentials/04_filter.html#select",
    "href": "tutorials/02_essentials/04_filter.html#select",
    "title": "04: Filter and Select",
    "section": "Select",
    "text": "Select\nThe select() function is probably the most straightforward of the core {dplyr} functions. Its primary job is to easily and transparently subset the columns within a dataset - in particular, a tibble. Rows are not affected by select(), only columns.\n\nBasic Structure\nTo subset a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::select(\n    variable_to_keep, !variable_to_drop, \n    keep_this_one:through_this_one,\n    rename_variable = old_name,\n    variable_number\n  )\n\n\nUsage\n\nvariable_to_keep: Choose a variable to include in the output by including its name. Multiple variables can be selected separated by commas.\n!variable_to_drop: Drop a variable from the output by putting an exclamation mark (!) or a minus sign (-) in front of its name. Multiple variables can be dropped, separated by commas with a ! (or -) before each.\nkeep_this_one:through_this_one: Choose a range of variables to include in the output with a colon (:). All the variables between and including the two named will be selected (or dropped, with !(drop_this_one:through_this_one))\nrename_variable: Choose a variable to include in the output, but give it a new name.\nvariable_number: Choose a variable to include in the output by where it appears in the dataset, numbered left to right. For example, “2” will select the second column in the original dataset.\n\nColumns will appear in the output in the order they are selected in select(), so this function can also be used to reorder columns.\n\n\n\n&lt;tidyselect&gt;\nThe real power in select(), and in many other {tidyverse} functions, is in a system of helper functions and notations collectively called &lt;tidyselect&gt;. The overall goal of “&lt;tidyselect&gt; semantics” is to make selecting variables easy, efficient, and clear.\nThese helper functions can be combined with the selection methods above in any combination. Some very convenient options include:\n\neverything() for all columns\nstarts_with(), ends_with(), and contains() for selecting columns by name\nnum_range() for selecting columns with a shared prefix and numerical range, e.g. item_1, item_2, item_3 etc.\nall_of() and any_of() for selecting using character vectors\nwhere() for selecting with a function\nmatches() for selecting with regular expressions (not covered in this tutorial)\n\nRather than list examples of all the helper functions here, it’s best to just try them out for yourself!s\n\n\n\n\n\n\nExercises\n\n\n\nOpen the help documentation by running ?dplyr::select in the Console to see examples of how to use all of the &lt;tidyselect&gt; helper functions.\nSelect the columns that start with\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nSelect all of the columns that contain a score\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nSelect the first ten items of the C and D subscales\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nRedo the exercise from the previous section using &lt;tidyselect&gt; helpers.\n\n\n\nUsing Functions\nLet’s say we want to create a summary table of all of the numeric variables in our dataset. Before we can create our summary in the next tutorial, we may first want to produce a subset of our dataset that only contains numeric variables.\nTo do this, we can use the &lt;tidyselect&gt; helper function where(). This helper function lets us use any function that returns TRUE and FALSE to select columns. Essentially, we don’t have to select columns by name - we can use any criteria we want, as long as we have (or can create!) a function that expresses that criteria.\nEspecially helpful here is the is.*() family of functions in base R. This group of functions all have the same format, where the * is a stand-in for any type of data or object, e.g. is.logical(), is.numeric(), is.factor() etc. (The very useful is.na() that we’ve seen above is also a member of this family.) These functions work like a question about whatever you put into them - for example, is.numeric() can be read as, “Is (whatever’s in the brackets) numeric?”\n\n\n\n\n\n\nTip\n\n\n\nYou can quickly find all of the functions in this family by typing is. in the Console and pressing Tab.\n\n\nPutting these two together, we could accomplish the task of selecting only numeric variables as follows:\n\nmy_tibble |&gt; \n  dplyr::select(\n    where(is.numeric)\n  )\n\nThis command evaluates each column and determines whether they contain numeric data (TRUE) or not (FALSE), and only returns the columns that return TRUE.\n\n\n\n\n\n\nWarning\n\n\n\nThe following material in this section isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\nThe function in where() that determines which columns to keep doesn’t have to be an existing named function. Another option is to use a “purrr-style lambda” or formula (a phrase you may see in help documentation) to write our own criteria on the spot. What we are essentially doing is writing an ad-hoc function.\nFor example, let’s select all of the numeric variables that have a minimum value of 3:\n\nmy_tibble |&gt; \n  dplyr::select(\n    where(is.numeric & ~ min(.x, na.rm = TRUE) &gt;= 3)\n  )\n\nThe second of these criteria is one of these “purrr-style” formulae. Is has two components:\n\nThe ~ (apparently pronounced “twiddle”!) at the beginning, which is a shortcut for the longer function(x) ... notation for creating functions.\nThe .x, which is a placeholder for each of the variables that the function will be applied to.\n\nSo, this command can be read: “Take my tibble and select all the columns where the following is true: the data type is numeric and the minimum value in that column is greater than or equal to 3 (ignoring missing values).”\n\n\n\n\n\n\nOptional Exercises\n\n\n\n\n\n\n\n\n\nSolution"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#making-mistakes",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#making-mistakes",
    "title": "01: IntRoductions I",
    "section": "Making Mistakes",
    "text": "Making Mistakes\nBefore we go any further, an affirmation: you will, inevitably, make typos and errors using R. You will write commands that make sense to you that R doesn’t understand; and you will write commands that don’t make sense to you, that R does understand. You will make lots of mistakes, so let’s start there: with errors.\n\n\n\n\n\n\nExercises\n\n\n\nType literally any gibberish, words, keysmashes etc. into the code chunk on the worksheet and press Run (or Ctrl/Cmd + Shift + Enter).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nAm I a coward? Who calls me villain?\n\nError: &lt;text&gt;:2:4: unexpected symbol\n1: ## Words!\n2: Am I\n      ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\n\n\n\n\n\nWell, that went about as well as expected.\nIf you haven’t tried this yet, and your code chunk is just ominously staring at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There’s two important things to learn from this:\n\nTo ask R to do something, you must write them out somewhere (in a code chunk, in the Console) and then run them.\nEventually, inevitably, something that you type WILL produce an error.\n\nFrom our keysmashing above, you will have seen that aslavb;lj aew aljvb, Am I a coward? Who calls me villain?, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\n\n\n\n\nGlossoRlia\n\n\n\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nAlthough it certainly is complex, and occasionally quite frustrating, R is just a system for doing computational and analytical tasks. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But it is comprehensible, and ultimately it’s just a tool to help you do your work well."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#types-of-data",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#types-of-data",
    "title": "01: IntRoductions I",
    "section": "Types of Data",
    "text": "Types of Data\nOne key concept for using R is the different ways it categorises data. “Data” here means any piece of information you put into R - a word, a number, the result of a command or calculation, a dataset, etc. Depending on the type of data you have, R will treat it differently, and some operations only work on certain types of data. So, let’s have a look at how R encodes and deals with different types of data. Here’s well cover three of the most common and important: numeric, character, and logical.\n\nNumeric\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\n\n\n\n\n\nExercise\n\n\n\nType any single number and run the code.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random\n\n3958\n\n[1] 3958\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\n\n\n\n\n\nExercise\n\n\n\nHow does R handle commas within a number (e.g. to separate the thousands place from the hundreds)? How about full stops for decimals?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n3.958\n\n[1] 3.958\n\n\n\n\n\n\n\nSo, commas within numbers throw an error. This is because commas have an important role to play in functions, so long numbers must be inputted into R without any punctuation. However, full stops to mark decimal places are just fine.\n\n\n\n\n\n\nGrammar Check\n\n\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets or misplaced commas.\n\n\n\nNext, let’s try doing some basic maths.\n\n\n\n\n\n\nExercise\n\n\n\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 + 8\n\n[1] 48\n\n\n\n\n\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” (or whatever numbers you chose) and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\n\n\n\n\nExercise\n\n\n\nTry subtracting, dividing, and multiplying the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\n\n\n\nVectors\nLet’s imagine I want to generate some simple participant ID numbers to keep track of the order that they completed my study, and I had 50 in total. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\n\n\nNotice that the indices mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out all the numbers 12 through 30; all of the numbers 23 through 55; and 36, all in one command.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\n\n\n\n\n\nYou may have tried something like this:\n\n12:30\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n\n23:55\n\n [1] 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\n[26] 48 49 50 51 52 53 54 55\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. However, we want all those numbers in a single command. To do this, I’m going to use a function called c().\nThis is our first contact with functions in R, and we’ll explore how they work more later on. To use this one, type it out, then inside the brackets, put the numbers you want to collect (or concatenate, or combine), with different groups separated by commas.\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects all of the numbers into a single series of elements, called a vector.\nActually, we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see Tip box on vectors and elements). When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing with square brackets.\n\nc(12:30, 23:55, 36)[33]\n\n[1] 36\n\n\nWhat I’ve essentially asked R is, “Put all of these numbers into a single vector, and then give me the 33th element in that vector.” As it turns out, the 33th element in that vector of numbers is 36.\n\n\n\n\n\n\nDefinition: Vectors\n\n\n\nA vector is essentially a series of pieces of data, or elements. It is a key basic piece of how data is stored in R. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nVector Calculations\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector of every whole number between 37 and 63, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37:63) - 7\n\n [1] 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54\n[26] 55 56\n\n\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\n\n\n\nOrder of Operations\n\n\n\nMathematical expressions are evaluated in a certain order of priority. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly.\n\n\n\n\n\nCharacter\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\n\n\nThe placement of the quotes is very important - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a special value in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nHere, we asked R for the third element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a third element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do.\n\n\nLogical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\n\n\n\n\n\nExercise\n\n\n\nWrite the following assertions in R:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n49 does not equal 93\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n49 != 93\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last couple statements above may have caused you some trouble if the notation is unfamiliar.\nFor “does not equal”, ! is common notation in R for “not”, or the reverse of something. So != can be read as “not-equals”.\nFor “equals”, if you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use shortly. Single = also has an important and specific role to play in function arguments. Essentially = is a special operator that doesn’t assert equivalance. Instead, “exactly equals” in R is “double-equals” (or “exactly and only”), ==.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. This is a vectorised calculation again, as we saw with numeric data before. These vectorised assertions will be absolutely essential to selecting and filtering data that meet particular requirements, or checking our data to find problems."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_datasets.html",
    "href": "tutorials/01_fundRmentals/03_datasets.html",
    "title": "03: Datasets",
    "section": "",
    "text": "There are many ready-made options in various packages to quickly produce summary tables. At the UG level, students are introduced datawizard::describe_distribution(), which is one such function. To use it, simply put the name of the dataset object inside the brackets.\nBesides its default settings, the output can be further customised to add or remove particular statistics; see the help documentation.\n\n\n\ndatawizard::describe_distribution(my_tibble)\n\n\n\n\nDeciding whether to use functions like this will depend on what you want out of them and how much work you want to put into reading the help documentation.\nThis output, by default, appears as text output, which is quite difficult to work with. However, it can easily be coerced into a tibble if you want to keep"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_datasets.html#summaries",
    "href": "tutorials/01_fundRmentals/03_datasets.html#summaries",
    "title": "03: Datasets",
    "section": "",
    "text": "There are many ready-made options in various packages to quickly produce summary tables. At the UG level, students are introduced datawizard::describe_distribution(), which is one such function. To use it, simply put the name of the dataset object inside the brackets.\nBesides its default settings, the output can be further customised to add or remove particular statistics; see the help documentation.\n\n\n\ndatawizard::describe_distribution(my_tibble)\n\n\n\n\nDeciding whether to use functions like this will depend on what you want out of them and how much work you want to put into reading the help documentation.\nThis output, by default, appears as text output, which is quite difficult to work with. However, it can easily be coerced into a tibble if you want to keep"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro_i.html#lets-get-testing",
    "href": "tutorials/01_fundRmentals/01_intro_i.html#lets-get-testing",
    "title": "01: IntRoductions I",
    "section": "Let’s Get Testing",
    "text": "Let’s Get Testing\nLet’s put all of this together and have a look at what we can already do with the skills in this tutorial. R has many, many uses, but one of its core purposes is statistical analysis - and we already know more than enough to do this.\n\nComparing Groups with t-test\nWe’ve created two objects that contain scores from two different groups - scores we made up, but we will get to real data soon (in the next tutorial!). For now, one common statistical test we could run on data like this is a t-test, which is a hypothesis test essentially quantifying whether scores come from the same or different populations.\nThe function to run a t-test in R is t.test(), so let’s have a go!\n\n\n\n\n\n\nExercise\n\n\n\nBring up the help documentation for t.test() and use it to run a t-test comparing your two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nt.test(quiz_9am, quiz_6pm)\n\n\n    Welch Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 11.969, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23978  21.52550\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\n\n\n\n\n\nThere are a lot of options in the t.test() function, which can be used, through different arguments, to run almost any variety of t-test you can think of. In this case, though, the code is quite simple, because we want all the default settings (for a two-sample, independent test), so we only need to provide x and y, our two numeric vectors.\nNote that the output mentions “Welch Two Sample t-test”, which is a robust version of the test that does not assume equal variances. This is the version that is taught to undergraduates, because we have not at this point introduced the process of assumption testing. If you definitely know that the variances are equal and you definitely want Student’s t-test, you can instead change the default setting:\n\nt.test(quiz_9am, quiz_6pm, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 12, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23255  21.51826\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\nIn the next tutorial, we’ll see how to turn this rather ugly R output automatically into beautifully formatted reporting like this:\n\nWe compared mean scores between two groups, one who took the quiz in a 9am practical session (M = 52) and the other who took the quiz in a 6pm practical session (M =55.86, Mdiff = -3.86). There was no statistically significant difference in scores between timing groups (t(12) = -0.33, p = 0.746, 95% CI [-29.23, 21.52])."
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_intro_ii.html",
    "href": "tutorials/01_fundRmentals/02_intro_ii.html",
    "title": "02: IntRoductions II",
    "section": "",
    "text": "In this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nDefinition: Package\n\n\n\nA package is a collection of code, maybe containing functions, data, or other useful bits. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\n\n\n\n\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do1.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\n\n\n\n\n\nExercise\n\n\n\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\n\n\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\n\n\n\n\n\nExercise\n\n\n\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\ninstall.packages(\"weights\")\n\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\n\n\n\n\nExercise\n\n\n\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\n\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\n\n\n\n\n\nExercise\n\n\n\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\nWarning: package 'weights' was built under R version 4.3.1\n\n\nLoading required package: Hmisc\n\n\nWarning: package 'Hmisc' was built under R version 4.3.1\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\n\n\n\n\nExercise\n\n\n\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\n\n\n\n\n\nThird time lucky!\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type.\nAnother option is the {conflicted} package in tidyverse. If you load this package, you can no longer get away without specifying; instead of choosing this whichever is the most recently loaded function with the same name, R will instead throw an error and force you to choose which package/function combo you want to use. See ?conflicted for more!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_intro_ii.html#packages",
    "href": "tutorials/01_fundRmentals/02_intro_ii.html#packages",
    "title": "02: IntRoductions II",
    "section": "",
    "text": "In this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nDefinition: Package\n\n\n\nA package is a collection of code, maybe containing functions, data, or other useful bits. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\n\n\n\n\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do1.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\n\n\n\n\n\nExercise\n\n\n\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\n\n\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\n\n\n\n\n\nExercise\n\n\n\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\ninstall.packages(\"weights\")\n\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\n\n\n\n\nExercise\n\n\n\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\n\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\n\n\n\n\n\nExercise\n\n\n\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\nWarning: package 'weights' was built under R version 4.3.1\n\n\nLoading required package: Hmisc\n\n\nWarning: package 'Hmisc' was built under R version 4.3.1\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\n\n\n\n\nExercise\n\n\n\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\n\n\n\n\n\nThird time lucky!\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type.\nAnother option is the {conflicted} package in tidyverse. If you load this package, you can no longer get away without specifying; instead of choosing this whichever is the most recently loaded function with the same name, R will instead throw an error and force you to choose which package/function combo you want to use. See ?conflicted for more!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_intro_ii.html#footnotes",
    "href": "tutorials/01_fundRmentals/02_intro_ii.html#footnotes",
    "title": "02: IntRoductions II",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou may not find any that you’d quite like to use - in that case, of course, you can code something new! Oh, the functions you’ll write…↩︎"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_datasets.html",
    "href": "tutorials/01_fundRmentals/02_datasets.html",
    "title": "02: IntRoductions II",
    "section": "",
    "text": "Libraries\nReading in, viewing and summarising datasets\nSubsetting with `$`, `pull()`\nUseful verbs: count, tally, mean, sd, min, max, etc.\nQuarto: chunk options, inline code, automatic numbering, rendering\nBase R visualisations"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_datasets.html#using-quarto",
    "href": "tutorials/01_fundRmentals/02_datasets.html#using-quarto",
    "title": "02: IntRoductions II",
    "section": "Using Quarto",
    "text": "Using Quarto\nHeadings and code chunks Code chunk options Rendering $ subsetting and inline code Maybe another test? With real data to practice? Probably chi-squared, it’s short lol Reading in datasets"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_datasets.html#packages",
    "href": "tutorials/01_fundRmentals/02_datasets.html#packages",
    "title": "02: IntRoductions II",
    "section": "Packages",
    "text": "Packages\nIn this final section for this tutorial, we’ll introduce one of the main strengths of R: its many, many user-written open-source packages.\n\n\n\n\n\n\nDefinition: Package\n\n\n\nA package is a collection of code, maybe containing functions, data, or other useful bits. Some packages, like {base} and {stats} (that contain the c() and round() functions we have used respectively) come automatically installed and loaded with R, and you can use them right off the bat without having to do anything special. For the others, you must install and load them before you can use them.\nTo install packages, use install.packages(\"package_name\") in the Console ONLY. Note that you must use quotes!\nTo load lackages, use library(package_name) at the beginning of your document.\n\n\nIf the difference between installing and loading isn’t clear, the following optional explainers will help explore what each does.\n\n\n\n\n\n\nRounding, Revisited\n\n\n\n\n\nLet’s say at this point that we’re not entirely happy with the way round() did the rounding on our four numbers in the last tutorial. We actually wanted the output to drop the leading 0 and keep the trailing 0, so instead of rounding 0.198 to 0.2, we wanted .20. Looking at the documentation for round(), there doesn’t seem to be a way to change this in the round() function itself. So, we’ll need to find another function that does what we want it to do1.\nWith a bit of industrious Googling, we can find that there’s a different function, rd(), that does drop the leading 0. Fantastic! Let’s do it.\n\n\n\n\n\n\nExercise\n\n\n\nUse the help documentation for rd() to round the same three numbers as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nWhat happened? We know we spelled the function correctly (it’s only two letters!) and we can see from the help documentation that the arguments are the same as for round(). Why doesn’t this work?\nThere’s a hint in the upper right corner of the help documentation that says: “From weights v1.0.1”. This is the name of the package that contains the function rd(). From the error message that R gave us above, we can tell that R doesn’t come with this package pre-loaded. So, even though the function does exist, we don’t currently have access to it.\n\nInstalling Packages\nOnce you know the name of the package you want to install (as we found out above), you can then ask R to go on the Internet, find the package, and install it. Luckily, the function that does this is very easy to remember!\n\n\n\n\n\n\nExercise\n\n\n\nRun the code below to install the {weights} package in the Console (and NOT in a code chunk!)\nHint: Notice the quote marks. This function won’t work properly if you don’t put in the quotes.\ninstall.packages(\"weights\")\n\n\nYou should see a lot of code come up very quickly - the default colour scheme in RStudio has this text in red, which looks alarming, but unless you see the word “ERROR”, everything’s fine. There will be lots of trying URL and theninstalling *binary* package and finally The downloaded source packages are in followed by a file name. If this is what happened when you ran this function, congratulations! You are now the proud owner of a copy of the {weights} package, successfully installed on your computer.\n(Note: If R throws an error and tells you that the package failed to install, see this troubleshooter for solving package installation errors.)\nNow that we have the package that contains the rd() function, let’s try using it again.\n\n\n\n\n\n\nExercise\n\n\n\nRun the same rd() command as above.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\n\n\n\n\n\nThe same “cannot find function” error comes up again, even though we’re sure now that we have the correct package installed. What happened?\n\n\nLoading Packages\nEven though we’ve installed the package, we haven’t yet loaded it into our current session of R. To do this, we need a second command that will tell R that we want to access the {weights} package and the functions in it.\n\n\n\n\n\n\nExercise\n\n\n\nRun the following code to load the {weights} package.\nHint: No quote marks this time!\n\nlibrary(weights)\n\nWarning: package 'weights' was built under R version 4.3.1\n\n\nLoading required package: Hmisc\n\n\nWarning: package 'Hmisc' was built under R version 4.3.1\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\n\n\nIf you installed the package successfully, you should find that nothing (apparently) happens when you execute this command. That’s a good thing - it means the command has run without errors. However, if we want to check, let’s have a look at the packages that are currently loaded.\nTo do this, look at the “Packages” tab (next to the “Files” and “Plots” tabs). Here you can see a list of all of the packages that are currently installed in R. The ones with a tick mark next to them are currently loaded. If you scroll down, you should see {weights} in this list with a tick. Pick another random package and click on the tick box; you should see that RStudio automatically runs another library() command in the Console for you.\n\n\n\n\n\n\nExercise\n\n\n\nNow that the {weights} package is loaded, run the same rd() command again.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\n\n\n\n\n\nThird time lucky!\n\n\n\n\n\n\n\n\n\n\nInstalling vs Loading\n\n\n\n\n\nInstalling vs loading packages is often a source of confusion when starting out with R, so let’s look at this in a bit more depth.\nWhen you open up RStudio the first time, this is a lot like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Outlook. Let’s say you’ve just got a new phone and you want to post about it on Facebook. To do this, you’ll need to:\n\nGo to your phone’s app store and download the Facebook app.\nOnce the download is complete, you have to open the app to use it.\n\nYou must complete both of these steps in order to use the Facebook app. You might recognise that these correspond almost exactly to install.packages() and library() respectively. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.\nAn important point to note here is that you typically only have to download the Facebook app to your phone once, the first time you want to use it. After that, you can just open the app that you’ve already downloaded. This is the exactly the same way that you should use install.packages() and library(). You typically only need to use install.packages() once per device, and you should always run the command in the Console, not in your documents (where they often cause errors!). However, you will need to load the packages you want to use for any particular document with library() every time.\nIn summary:\n\ninstall.packages(): downloads and installs a package; run only once in the console\nlibrary(): loads a package for current use; run at the start of every session, include at the beginning of every document\n\n\n\n\n\n\n\n\n\n\nVerbose Code and Conflicts\n\n\n\n\n\nAt the risk of causing confusion, you can get around some of the annoying issues with library() by using verbose code. This means that instead of writing only the function name, in your code you write the package name along with the function name to run the code, separated by a double colon, like this: package_name::function_name(). Because R knows where to look for the function, it doesn’t matter if the package is loaded or not!\nTo see this, un-load (that is, detach) the {weights} package, either by unticking the box next to it in the “Packages” tab, or by running the code below in the Console:\n\ndetach(\"package:weights\")\n\nYou should see that if you try to run the same rd() command, you again get a “function not found” error:\n\nrd(c(55.85714, 59.54, 0.198), digits = 2)\n\nError in rd(c(55.85714, 59.54, 0.198), digits = 2): could not find function \"rd\"\n\n\nNow add on the package name, and the function runs just fine:\n\nweights::rd(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] \"55.86\" \"59.54\" \".20\"  \n\n\nOf course, you must still have the {weights} package installed!\nVerbose code is also an excellent failsafe to prevent errors or unintended output due to conflicts. A conflict occurs when two packages contain a function with the same name. There are many, many people in the R community designing functions and packages, and although they try to avoid giving functions the same name, sometimes it happens.\nIf you don’t include a package name with your function call, whichever package you’ve loaded most recently will be the one that R uses. In R terminology, the most recently loaded function will mask, or take precedence over, any other functions with the same name. R will also give you a warning when you load a package with conflicts, although those warnings can be easy to miss (there was a message to this effect when we loaded the {weights} package - did you see it?). There are methods to deal with it, like the {conflicted} package, but one of the most foolproof is to always use the package_name::function_name() verbose notation.\nIf you wrote every function like this, you would never have any problem with accidentally using the wrong function, so some people recommend it as best practice (especially if you are writing packages for other people to use). However, it also makes your code a bit harder to read at a glance and is more onerous to type.\nAnother option is the {conflicted} package in tidyverse. If you load this package, you can no longer get away without specifying; instead of choosing this whichever is the most recently loaded function with the same name, R will instead throw an error and force you to choose which package/function combo you want to use. See ?conflicted for more!"
  },
  {
    "objectID": "tutorials/01_fundRmentals/02_datasets.html#footnotes",
    "href": "tutorials/01_fundRmentals/02_datasets.html#footnotes",
    "title": "02: IntRoductions II",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou may not find any that you’d quite like to use - in that case, of course, you can code something new! Oh, the functions you’ll write…↩︎"
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html",
    "href": "tutorials/01_fundRmentals/01_intro.html",
    "title": "01: IntRoductions I",
    "section": "",
    "text": "The Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nSo - let’s get cracking."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#making-mistakes",
    "href": "tutorials/01_fundRmentals/01_intro.html#making-mistakes",
    "title": "01: IntRoductions I",
    "section": "Making Mistakes",
    "text": "Making Mistakes\nBefore we go any further, an affirmation: you will, inevitably, make typos and errors using R. You will write commands that make sense to you that R doesn’t understand; and you will write commands that don’t make sense to you, that R does understand. You will make lots of mistakes, so let’s start there: with errors.\n\n\n\n\n\n\nExercises\n\n\n\nType literally any gibberish, words, keysmashes etc. into the code chunk on the worksheet and press Run (or Ctrl/Cmd + Shift + Enter).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nAm I a coward? Who calls me villain?\n\nError: &lt;text&gt;:2:4: unexpected symbol\n1: ## Words!\n2: Am I\n      ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\n\n\n\n\n\nWell, that went about as well as expected.\nIf you haven’t tried this yet, and your code chunk is just ominously staring at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There’s two important things to learn from this:\n\nTo ask R to do something, you must write them out somewhere (in a code chunk, in the Console) and then run them.\nEventually, inevitably, something that you type WILL produce an error.\n\nFrom our keysmashing above, you will have seen that aslavb;lj aew aljvb, Am I a coward? Who calls me villain?, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\n\n\n\n\nGlossoRlia\n\n\n\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nAlthough it certainly is complex, and occasionally quite frustrating, R is just a system for doing computational and analytical tasks. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But it is comprehensible, and ultimately it’s just a tool to help you do your work well."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#types-of-data",
    "href": "tutorials/01_fundRmentals/01_intro.html#types-of-data",
    "title": "01: IntRoductions I",
    "section": "Types of Data",
    "text": "Types of Data\nOne key concept for using R is the different ways it categorises data. “Data” here means any piece of information you put into R - a word, a number, the result of a command or calculation, a dataset, etc. Depending on the type of data you have, R will treat it differently, and some operations only work on certain types of data. So, let’s have a look at how R encodes and deals with different types of data. Here’s well cover three of the most common and important: numeric, character, and logical.\n\nNumeric\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\n\n\n\n\n\nExercise\n\n\n\nType any single number and run the code.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random\n\n3958\n\n[1] 3958\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\n\n\n\n\n\nExercise\n\n\n\nHow does R handle commas within a number (e.g. to separate the thousands place from the hundreds)? How about full stops for decimals?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n3.958\n\n[1] 3.958\n\n\n\n\n\n\n\nSo, commas within numbers throw an error. This is because commas have an important role to play in functions, so long numbers must be inputted into R without any punctuation. However, full stops to mark decimal places are just fine.\n\n\n\n\n\n\nGrammar Check\n\n\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets or misplaced commas.\n\n\n\nNext, let’s try doing some basic maths.\n\n\n\n\n\n\nExercise\n\n\n\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 + 8\n\n[1] 48\n\n\n\n\n\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” (or whatever numbers you chose) and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\n\n\n\n\nExercise\n\n\n\nTry subtracting, dividing, and multiplying the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\n\n\n\nVectors\nLet’s imagine I want to generate some simple participant ID numbers to keep track of the order that they completed my study, and I had 50 in total. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\n\n\nNotice that the indices mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out all the numbers 12 through 30; all of the numbers 23 through 55; and 36, all in one command.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\n\n\n\n\n\nYou may have tried something like this:\n\n12:30\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n\n23:55\n\n [1] 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\n[26] 48 49 50 51 52 53 54 55\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. However, we want all those numbers in a single command. To do this, I’m going to use a function called c().\nThis is our first contact with functions in R, and we’ll explore how they work more later on. To use this one, type it out, then inside the brackets, put the numbers you want to collect (or concatenate, or combine), with different groups separated by commas.\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects all of the numbers into a single series of elements, called a vector.\nActually, we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see Tip box on vectors and elements). When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing with square brackets.\n\nc(12:30, 23:55, 36)[33]\n\n[1] 36\n\n\nWhat I’ve essentially asked R is, “Put all of these numbers into a single vector, and then give me the 33th element in that vector.” As it turns out, the 33th element in that vector of numbers is 36.\n\n\n\n\n\n\nDefinition: Vectors\n\n\n\nA vector is essentially a series of pieces of data, or elements. It is a key basic piece of how data is stored in R. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nVector Calculations\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector of every whole number between 37 and 63, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37:63) - 7\n\n [1] 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54\n[26] 55 56\n\n\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\n\n\n\nOrder of Operations\n\n\n\nMathematical expressions are evaluated in a certain order of priority. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly.\n\n\n\n\n\nCharacter\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\n\n\nThe placement of the quotes is very important - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a special value in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nHere, we asked R for the third element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a third element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do.\n\n\nLogical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\n\n\n\n\n\nExercise\n\n\n\nWrite the following assertions in R:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n49 does not equal 93\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n49 != 93\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last couple statements above may have caused you some trouble if the notation is unfamiliar.\nFor “does not equal”, ! is common notation in R for “not”, or the reverse of something. So != can be read as “not-equals”.\nFor “equals”, if you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use shortly. Single = also has an important and specific role to play in function arguments. Essentially = is a special operator that doesn’t assert equivalance. Instead, “exactly equals” in R is “double-equals” (or “exactly and only”), ==.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. This is a vectorised calculation again, as we saw with numeric data before. These vectorised assertions will be absolutely essential to selecting and filtering data that meet particular requirements, or checking our data to find problems."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#class-and-coercion",
    "href": "tutorials/01_fundRmentals/01_intro.html#class-and-coercion",
    "title": "01: IntRoductions I",
    "section": "Class and Coercion",
    "text": "Class and Coercion\nWith these short examples, it may be obvious just by looking that 25 is a number and porcupine is a word. However, this isn’t always so straightforward, and there are some situations - such as data checking/cleaning, or debugging - where we might want to check what type of data a certain thing is. To do this, we’ll need another new function, class(). This function will print out, as a character, the name of the data type of whatever is put into the brackets.\n\n\n\n\n\n\nExercise\n\n\n\nUse the class() function to get R to print the values \"numeric\", \"logical\", and \"character\".\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Any numeric vector will do\nclass(216907)\n\n[1] \"numeric\"\n\n## You can also use a longer vector of numbers\n## as long as they are all numbers!\nclass(c(4:291, -1, 38.7, 100000000))\n\n[1] \"numeric\"\n\n## Logical has two options\n## Create a vector of TRUEs and FALSEs\nclass(TRUE)\n\n[1] \"logical\"\n\n## Create a vector that outputs logical values (now you're thinking with functions!)\nclass(c(6 &gt; 4, 10 == 37, 3 != 8))\n\n[1] \"logical\"\n\n## Character\nclass(\"antidisestablishmentarianism\")\n\n[1] \"character\"\n\n\n\n\n\nWhat data type does R give you if you combine numbers and characters in c()?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Again, anything will do\n\nclass(c(93, -1905, \"avocado\"))\n\n[1] \"character\"\n\n\n\n\n\n\n\nSomething interesting has happened here. Recall that atomic vectors created with c() must all have the same data type. Here, we combined two types of data: numeric and character. We didn’t get an error - instead, without warning or telling us, R quietly converted the entire vector to character type. This forcible conversion is called coersion.\n\n\n\n\n\n\nCoersion\n\n\n\nCoersion is when a piece of data is forcibly changed from one data type to another. This is sometimes intentional, but it can happen unintentionally (and without any warning or fanfare!), so is a common source of errors.\nCoersion follows a hierarchy; data types on the left can be coerced into the types further along to the right.\nlogical ==&gt; integer ==&gt; double (numeric) ==&gt; character\nAs we saw previously, you can check the data type of a vector with class(). You can also check if a vector is a particular type (and receive a logical vector in response) with the is.*() family of functions. (The * notation refers to a placeholder for many different options, such as is.numeric, is.character, etc.)\nYou can similarly (try to) coerce a vector into a particular data type with the as.*() family of functions.\n\n\nThis explains why our vector from the last exercise was a character vector - since the vector contained at least one character element, everything else in the vector was coerced to the same type. This can cause problems when, for example, numeric data is coerced into character data, even though it still looks like numbers.\nEven though we can do mathematical operations on numbers, we can’t do them on characters; it should be clear that asking e.g. what is \"tomato\" - 7 is nonsense. However, this is the case even if all of the data are numerals! For example:\n\n## No problem here; all numbers\nc(2:20, 45) - 7\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 38\n\n## Doesn't work\nc(2:20, \"45\") - 7\n\nError in c(2:20, \"45\") - 7: non-numeric argument to binary operator\n\n\nEven though “45” looks like a number, because it’s in quotes, R thinks that it’s a character, and will refuse to do the calculation, in the same way that it would refuse to do it with “tomato”."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#objects",
    "href": "tutorials/01_fundRmentals/01_intro.html#objects",
    "title": "01: IntRoductions I",
    "section": "Objects",
    "text": "Objects\nR is a programming language, but (being created by speakers of natural language) it has many features similar or analogous to natural languages. In this section, we’ll cover the basic “grammar” of R, including how R understands what you ask it to do.\nIn a similar way that the basic unit of many languages is the word1, the basic unit of the R programming language is the object. This section will explore the basics of what an object is and some of their key features in R.\n\n\n\n\n\n\nDefinition: Objects\n\n\n\nObjects are the basic elements that R is built around - the equivalent of words. An “object” in R is any bit of information that is stored with a particular name. Objects can hold anything, from a single number or word to huge datasets with thousands of data points or complex graphs. These named objects are the main way you, the programmer, can store, retrieve, and interact with information in R.\n\n\n\nCreating an Object\nAlthough we have done quite a bit in R so far - creating vectors, doing calculations, etc. - you may notice that we haven’t stored this information anywhere. To store the output of code for further use, it needs to be assigned to an object using the assignment operator, &lt;-. Once an object is created, it will appear in the Environment pane.\n\n\n\n\n\n\nClear Your Environment\n\n\n\nAt the moment your Environment should be empty. As a reminder, Environment is by default the first (leftmost) tab in one of your four main windows in RStudio, probably the one on the top right.\nIf this window is blank except for “Environment is empty”, you’re ready to go. If for some reason it isn’t empty, click the broom icon to clear everything from your Environment before you get started, as indicted in the image below. (There will be a very ominous-sounding “Are you sure?” pop-up, but just click “Yes”.)\n\n\n\nFirst, let’s look at the foundational structure of almost everything you will do in R:\nobject &lt;- instructions\nThis is “pseudo-code”, or a “general format” for a command in R. It isn’t valid R code, but is rather intended as a midpoint between natural language and R to help make it clear how the code works. You can read this code as, “An object is created from (&lt;-) some instructions.”\n\nobject: Objects can be named almost anything (although see Naming, below). The object name is a label so you, the analyst, can find, refer to, and use the information you need.\n&lt;-: The assignment operator &lt;- has single job: to assign output to names, or in other words, to create objects.\ninstructions: Any amount of code that produces some output, which is what object will contain.\n\n\n\n\n\n\n\nNaming Objects\n\n\n\n\n\nCOMING SOON\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nThink of a research scenario familiar to you with two independent groups. You’re welcome to draw from your own research or expertise, but you should choose something with numerical scores. Some ideas include:\n\nReaction times on a button-pressing task from a control and an experimental intervention group\nStatistics anxiety scores from first and second year UG students\nQuiz marks from students with practicals scheduled 9am and students with practicals at 6pm\n\nMake a note of the scenario you chose. Then, create two new objects: one that contains a vector of seven scores from the first of the two groups, and the second that has seven different scores from the second group.\nHint: Just make up some numbers!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nChoosing scenario 3, this vector contains some hypothetical quiz marks from each class.\n\nquiz_9am &lt;- c(75, 58, 62, 14, 33, 67, 55)\nquiz_6pm &lt;- c(45, 90, 27, 65, 39, 77, 48)\n\nLet’s have a look at this command. On the left side I’ve written the name I want my new object to have, which I’ve called quiz_9am[^1]. Next, the assignment operator &lt;- assigns whatever comes after it to the object label quiz_scores_9am. Finally, I’ve written instructions for what I want this object to contain: in this case, a vector of numbers that I’ve made up, but that reasonably look like quiz scores.\n[^1]: I could have called it anything, like the_first_example_of_an_object_InThisSection.so.far or made_upQuizScores.fornineamclass or anything else that follows R’s naming conventions. However, it’s a good idea to name your objects something brief and obvious, so you can remember what they contain.\nIf you haven’t done this yet, do so now, even if you’ve looked at the solution rather than trying it for yourself first. Once you’ve typed the command, there’s a final step to actually create the object: you have to run the command in order for it to take effect. As a reminder, you can do this by clicking the green ▶️ button in the upper right corner of the code chunk, or by pressing Ctrl/Cmd + Enter when your cursor is blinking on the same line as the code you want to run.\n\n\n\n\n\nAssuming your code is valid, you should see a green bar appear along the left-hand side of the code chunk when you run the code, but you might notice that there’s no printout that appears under the code chunk, as there was previously. In fact, if the code ran successfully, it might look like nothing happened at all. To find out what did happen, look your Environment pane. You should now see a new section, “Values”, and underneath the name of your new object and what it contains. Success!\n\n\nCalling an Object\nFor any object, from the most simple to the most complex, you can always see what’s in it by calling the object. This simply means that you type the name of the object and run the code. R will print out whatever is stored in the object.\n\n\n\n\n\n\nExercise\n\n\n\nCall both of the objects you just created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nReplace with the name of the object you created, if you did something different.\n\nquiz_9am\n\n[1] 75 58 62 14 33 67 55\n\nquiz_6pm\n\n[1] 45 90 27 65 39 77 48\n\n\n\n\n\n\n\nThis output looks just like what we saw earlier, when we just asked R to print out a vector of numbers. In essence, the object names are just labels for storing and referring to the information they contain.\n\n\n\n\n\n\nCreating vs Calling\n\n\n\nThese two actions are the essential basis of everything you will do in R. All of your code will, at base, either create an object, or call an object. (Changing an existing object, as we’ll see shortly, is the exact same procedure as creating one from scratch.)\nWhen you create an object using the assignment operator (&lt;-), the object is created but is not printed out. This is because R always does only and exactly what you ask it to do, and using the assignment operator only tells R to assign something to an object, not to print it out.\nWhen you call an object, the current contents of that object are printed out, but that object is not changed - you only reproduce a copy of its contents for review. To create or change an object, you must use the assignment operator to assign the output to a new (or existing) object name.\n\n\nLet’s make all of this a bit more concrete by seeing how we can use objects effectively.\n\n\nUsing Objects\nSince objects are convenient reference labels for the information they contain, we can work with them as if they were the information they contain. In this case, our objects contain numbers, so we can use them for numerical calculations.\nFor instance, we might want to know what the mean mark was for this sample of quiz marks. To do this, we could make use of a very handy function, mean(), as follows:\n\nmean(quiz_9am)\n\n[1] 52\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCalculate the mean of each of the two sets of scores you created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhether you save the output of the mean() command is up to you!\n\nmean(quiz_9am)\n\n[1] 52\n\nmean(quiz_6pm)\n\n[1] 55.85714\n\n\n\n\n\nCalculate the difference in the mean of each of the two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nHere are two options for accomplishing this.\nThe first option is to save each mean value in a new object (if you didn’t do that already), then subtract one mean from the other. This is very easy to read, but a bit inefficient.\n\nmean_9am &lt;- mean(quiz_9am)\nmean_6pm &lt;- mean(quiz_6pm)\n\nmean_9am - mean_6pm\n\n[1] -3.857143\n\n\nThe second option is to do everything in one command, which takes a bit more effort to parse but is more succinct.\n\nmean(quiz_9am) - mean(quiz_6pm)\n\n[1] -3.857143\n\n\n\n\n\nWhat is the class of these objects?\n\n\n\n\n\n\nSolution\n\n\n\n\n\nEither one will do.\n\nclass(quiz_9am)\n\n[1] \"numeric\"\n\n\nSo, an object has the class of the data it contains.\n\n\n\n\n\n\n\n\n\n\n\nObject Names vs Strings\n\n\n\nYou may have been surprised to see that the class of these objects is numeric, rather than character - even though the name of the object is a character string. To find out the class of the object, R looks at what that object contains, not at the name of the object itself. We already saw that quiz_9am (or whatever your object is called) contains only numbers; so, R tells us that it’s a numeric vector.\nOne more example to emphasize this point, because it’s often a source of confusion when starting out with R. If we want to ask R the class of the string “quiz_9am”, we would need to put it in quotes, and we’d get a different answer:\n\nclass(\"quiz_9am\")\n\n[1] \"character\"\n\n\nThe key thing here is that objects have the class of the data they contain, and are not character data; and whenever you want to use an object, you must not use quotation marks. On the other hand, if you want to input character data into R, you must use quotation marks. Otherwise, R will look for an object or function with that name, which will likely produce a “cannot find object” error.\n\n\nBecause we’ve used the assignment operator, R doesn’t print out the years. Instead, the output of our calculation is saved as the object birth_year. Hmm - didn’t we already have an object called birth_year, though? What happened to it?\n\n\n\n\n\n\nImportant: Overwriting Objects\n\n\n\nYou might notice that we already had an object called birth_year that we created above. R, again, does only and exactly what you ask it to do. Unlike, say, a word processer, that will give you a warning if you try to save two documents in the same folder with the same name, R won’t ask you if you’re sure you want to overwrite an existing object with new information - it will just do it. If you have a look in your Environment, you will see that the previous version of birth_year, containing only your birth year, has been quietly replaced with the new one containing the vector of birth years you just created.\nThis can be a good thing, because you can easily update the information stored in an object with changes, edits, or new information. However, it also means that you can overwrite or replace data when you don’t want to, if you use the same object name.\nThis is why it is so important to keep track of all of the commands and changes you make to your data. If you accidentally replace your dataset with, say, a single word or number with an error in your code, you can easily retrace your steps and avoid redoing work.\nIf you are interested in understanding this process of assigning and replacing the contents of objects better, the aside below explains it in more depth.\n\n\n\n\n\n\nCan you actually change an object?\n\n\n\n\n\nThink of objects as boxes. The names of the objects are only labels, and you can store anything you like inside them. However, unlike in the physical world, objects in R cannot truly change. You can put stuff in and take stuff out, and that’s pretty much it. Unlike boxes, though, when you take stuff out of objects, you only take out a copy of its contents. The original contents of the box remain intact. Of course, you can do whatever you want (within limits) to the stuff once you’ve taken it out of the box, but you are only modifying the copy. The key thing to remember is that unless you put that modified stuff into a box, R will forget about it as soon as it’s done with it. In other words, if you want to “save” any changes you make, you must assign them to an object in order to keep them.\nNow, as you probably know, you can call your boxes (objects) whatever you want (again, within certain limits). This means that that you can call the new box the same as the old one, as we saw with birth_year above. When that happens, R basically takes the label off the old box, pastes it on the new one, and burns the old box. So even though some operations in R may look like they change objects, what’s actually happening is that R copies their content, modifies it, stores the result in a different object, puts the same label on it, and discards the original object. Understanding this mechanism will make things much easier!\nPutting the above into practice, this is how you “change” an R object:\n\n# put 1 into an object (box) called a\na &lt;- 1\n\n# copy the content of a, add 1 to it and store it in an object b\nb &lt;- a + 1\n\n# copy what's inside b and put it in a new object called a\n# discarding (\"overwriting\") the old object a\na &lt;- b\n\n# now see what's inside of a\n# (by copying its content and pasting it in the console)\na\n\n[1] 2\n\n\nOf course, you can just cut out the middleman (creating an object b). So to increment a by another 1, we can do:\n\na &lt;- a + 1\n\na\n\n[1] 3\n\n\n\n\n\n\n\nWe will talk further about using scripts and writing multiple commands below; but first, we’ll need to have a look at a very important type of object in R: the function."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#functions",
    "href": "tutorials/01_fundRmentals/01_intro.html#functions",
    "title": "01: IntRoductions I",
    "section": "Functions",
    "text": "Functions\nFunctions are like verbs in the R language - they’re how R does anything. In order to use them, you need to “translate” the command you want to give R into a verb (function) it can understand.\n\nBasics and Help\nLet’s look at an example of how this translation might work. For this example, I’m going to use a number I generated earlier: the mean of the quiz_6pm group, which was 55.8571429, which I’d like to round to two decimal places - a common task for reporting results in APA style.\nIf we want R to do this for us, we have to write this command in a way that R can understand. First, we need to know what function corresponds to the English verb “round” - that is, what function will do the same action that we want R to perform. We’re lucky in this case: the function in R is also called round().\nWe know that we’re looking at a function in R because functions often have a name followed by brackets (and nothing else in R does). That is, they have the general form function_name(). Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.\n\n\n\n\n\n\nExercise\n\n\n\nTry running the round() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround()\n\nError in eval(expr, envir, enclos): 0 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nUnsurprisingly, R has given us an error. This is an informative error, though - that is, the error gives of some sort of intelligible clue about what’s gone wrong. Namely, it tells us that round() can’t just work without additional information (i.e. “required arguments”). Imagine, for instance, if you wanted a colleague to round 55.8571429 to two decimal places, and in order to ask them to do that, you just shouted “ROUND!” at them. Similarly, R has objected to this, telling you that it needs more information in order to do what you’ve asked it to.\n\n\n\n\n\nWhat we want to do, “Round the number 55.8571429 to two decimal places”, has two more important pieces of information that we need to tell R: what number we want to round (55.8571429) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let’s look at the help documentation.\n\n\n\n\n\n\nExercise\n\n\n\nOpen the help documentation for the round() function by running ?round() or help(round) in the Console.\n\n\n\n\n\n\n\n\nHelp Documentation\n\n\n\nHelp documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it’s a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running ?function_name or help(function_name) in the Console, or by clicking on the “Help” tab in the Files section of RStudio and using the Find box to search for the function.\n\n\nThe first section, “Description”, varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function including in this document, we can see that we have a useful description of round() that tells us that it rounds numbers (that’s a good sign) to a certain number of decimal places. That’s exactly what we want, so how do we use it?\nLet’s scroll down to “Usage”, which gives examples of what the function looks like. You can see that the basic structure of this function is round(x, digits = 0). It seems like we need to add some more information in the brackets of our function - but how do we interpret x and digits = 0?\n\n\nArguments\nThe information inside a function’s brackets to give it the information it needs to work are called arguments. Each argument in a function is separated by a comma, so we can see from round(x, digits = 0) that the round() function can take two arguments. How many arguments a function has depends on the function; some (like Sys.Date()) don’t need any arguments to run. One of the most useful parts of a function’s help documentation is the “Arguments” section, which tells you what each of the function’s arguments are and how to use them.\nThere are two main types of arguments: named and unnamed arguments. Conveniently, the arguments of round() give us one example of each.\n\nUnnamed Arguments\nThe first argument to round() is simply x. Just like in maths, x is a placeholder for some number or numbers (a “numeric vector”, which should sound familiar now) that you want to pass to the function. This is common notation in many functions: x, often the first argument in a function, is often the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that’s what we should replace with x.\nThis argument has no default so it must be provided, or the function won’t run.\n\n\nNamed Arguments\nThe second argument of round() is a named argument, digits = 0. You can think of named arguments like settings that change the way a function works, often with only certain allowable values. Here we can see that the name of the argument is digits; the name before the = sign tells R which setting we want to change.\nThe help documentation tells us that digits should be an “integer indicating the number of decimal places…to be used.” We can also see in “Usage” that this argument has a default value, digits = 0. That means that if we don’t explicitly include the argument digits when we use the function, by default the round() function will round the number you give it to 0 decimal places. Named arguments frequently, but not always, have a default, and it’s important to check so the function doesn’t quietly do something unexpected.\nDefault values of arguments are really useful, because the default is usually the most frequently used setting. It means you don’t have to specify every single aspect of a function every time you use it, as long as you want the function to work that way! In our case, we actually wanted round() to round to two decimal places, not 0. So, in our command, we should change the setting from the default, 0, to 2.\n\n\n\nUsing Functions\nNow that we know what both of these arguments mean, we can change them to actually translate the English sentence “Round the number 55.8571429 to two decimal places” into a command that R can work with. We’ll explicitly write out each argument so we know what they are doing.\n\n\n\n\n\n\nExercise\n\n\n\nUse the round() function to round 55.8571429 to two decimal places.\nIf you prefer, you can do this with one of the means you calculated for your own scores earlier.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Using the actual value from my earlier calculation\nround(55.85714, 2)\n\n[1] 55.86\n\n## Using a nested function - that is, calculating the mean and then rounding it!\nround(mean(quiz_6pm), 2)\n\n[1] 55.86\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\n\n\n\nIf you want to, you can achieve the same result by changing the order of the arguments. Because we have written the names of both arguments, R can still do what we want it to do:\n\nround(digits = 2, x = 55.85714)\n\n[1] 55.86\n\n\nWe can also, to some degree, drop the names of the arguments, as long as R can still understand what we’re trying to do:\n\nround(digits = 2, 55.85714)\n\n[1] 55.86\n\n\nHere I left out the x =. R can still understand this because round() only takes two arguments, and we explicitly told it what value belongs to digits, so it assumes the second number must be x.\n\nround(55.85714, 2)\n\n[1] 55.86\n\n\nThis time I dropped both argument names. R can still understand this because when you don’t specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 55.85714 to x and 2 to digits, which is what we wanted.\nAs I use R more and more, I find that I name arguments more consistently, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That’s because when I come back from lunch, or the next day, or six months later to revisit the same code, it’s much easier to recall what it all means when it’s well-annotated. So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:\n\nround(2, 55.85714)\n\n[1] 2\n\n\nHere, since we didn’t specify, R assumed that 2 was the number we wanted to round. This isn’t what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.\n\n\n\n\nPassing Multiple Values to Arguments\nA last important aspect of using functions is to remember that each argument in a function can only take a single object or value as input. For example, we saw above that we put the single value 55.85714 into the x argument of round(). But what if we wanted to round more than one number? We don’t want to have to write a new round() command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:\n\nround(55.85714, 2)\n\n[1] 55.86\n\n## ughhhh\nround(59.54, 2)\n\n[1] 59.54\n\n## noooooo :(\nround(0.198, 2)\n\n[1] 0.2\n\n## thanks I hate it\n\n\n\n\n\n\n\nExercise\n\n\n\nBefore you go on, have a go using a single round() command to round all three numbers at once.\nHint: Refer to Vectors.\n\n\nSo what happens if we try to put all of those numbers into round()? We might first try this:\n\nround(55.85714, 59.54, 0.198, 2)\n\nError in eval(expr, envir, enclos): 4 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nOnce again, R tells us that this doesn’t work by throwing an error. R has tried to do what we wanted, but the round() function only allows a max of two arguments, and we’ve given it four. Behind the scenes, R has tried to run round(x = 55.85714, digits = 59.54... and can’t proceed from there because it doesn’t know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first x argument together. If only there was a way to concatenate them together…\nYou may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a single object, and then pass that object to round() as the x argument. We already saw that we can combine any number of things together into a single vector using the c() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n## Create an intermediate object to contain the numbers\nnumbers &lt;- c(55.85714, 59.54, 0.198)\nround(numbers, digits = 2)\n\n[1] 55.86 59.54  0.20\n\n## Put the vector of numbers into round() directly\nround(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] 55.86 59.54  0.20\n\n\n\n\nHere we can see a good example of a function inside another function. You can stack, or “nest”, functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it’s doing. (There’s a great solution to this problem that we’ll make extensive use of in the future: the pipe operator.)\nThat’s looking like some proper R code! Very nicely done.\n\n\n\n\n\n\nHelp Documentation, Revisited\n\n\n\nBefore we leave the round() function altogether, let’s take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the “Details” section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn’t doing what you expect it to, this is a good place to look for an explanation.\nFinally, at the end of the documentation you can find the “Examples” section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the “Run examples” link, which will run the code in the Examples section for you so you can see what the function will do."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#lets-get-testing",
    "href": "tutorials/01_fundRmentals/01_intro.html#lets-get-testing",
    "title": "01: IntRoductions I",
    "section": "Let’s Get Testing",
    "text": "Let’s Get Testing\nLet’s put all of this together and have a look at what we can already do with the skills in this tutorial. R has many, many uses, but one of its core purposes is statistical analysis - and we already know more than enough to do this.\n\nComparing Groups with t-test\nWe’ve created two objects that contain scores from two different groups - scores we made up, but we will get to real data soon (in the next tutorial!). For now, one common statistical test we could run on data like this is a t-test, which is a hypothesis test essentially quantifying whether scores come from the same or different populations.\nThe function to run a t-test in R is t.test(), so let’s have a go!\n\n\n\n\n\n\nExercise\n\n\n\nBring up the help documentation for t.test() and use it to run a t-test comparing your two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nt.test(quiz_9am, quiz_6pm)\n\n\n    Welch Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 11.969, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23978  21.52550\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\n\n\n\n\n\nThere are a lot of options in the t.test() function, which can be used, through different arguments, to run almost any variety of t-test you can think of. In this case, though, the code is quite simple, because we want all the default settings (for a two-sample, independent test), so we only need to provide x and y, our two numeric vectors.\nNote that the output mentions “Welch Two Sample t-test”, which is a robust version of the test that does not assume equal variances. This is the version that is taught to undergraduates, because we have not at this point introduced the process of assumption testing. If you definitely know that the variances are equal and you definitely want Student’s t-test, you can instead change the default setting:\n\nt.test(quiz_9am, quiz_6pm, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 12, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23255  21.51826\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\nIn the next tutorial, we’ll see how to turn this rather ugly R output automatically into beautifully formatted reporting like this:\n\nWe compared mean scores between two groups, one who took the quiz in a 9am practical session (M = 52) and the other who took the quiz in a 6pm practical session (M =55.86, Mdiff = -3.86). There was no statistically significant difference in scores between timing groups (t(12) = -0.33, p = 0.746, 95% CI [-29.23, 21.52])."
  },
  {
    "objectID": "tutorials/01_fundRmentals/01_intro.html#footnotes",
    "href": "tutorials/01_fundRmentals/01_intro.html#footnotes",
    "title": "01: IntRoductions I",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs a linguist I have to note, one, words don’t exist, and two, the closest linguistic term for what an object is is probably “lexeme”. “Word” will get you in the right vicinity, though, conceptually. If you’d like to dive down this rabbit hole (rabbit-hole?) this Crash Course video on morphology is a good place to start.↩︎"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html",
    "href": "tutorials/01_fundRmentals/03_vizlm.html",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#summaries",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#summaries",
    "title": "03: Datasets",
    "section": "",
    "text": "There are many ready-made options in various packages to quickly produce summary tables. At the UG level, students are introduced datawizard::describe_distribution(), which is one such function. To use it, simply put the name of the dataset object inside the brackets.\nBesides its default settings, the output can be further customised to add or remove particular statistics; see the help documentation.\n\n\n\ndatawizard::describe_distribution(my_tibble)\n\n\n\n\nDeciding whether to use functions like this will depend on what you want out of them and how much work you want to put into reading the help documentation.\nThis output, by default, appears as text output, which is quite difficult to work with. However, it can easily be coerced into a tibble if you want to keep"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#overview",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#overview",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#lm-in-quarto",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#lm-in-quarto",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "LM in Quarto",
    "text": "LM in Quarto\nQuarto documents are a mix of text and code, the next generation of R Markdown documents. For our purposes, we will be using R within Quarto, but Quarto documents support the integration of many different coding languages, including Python, Julia, and Observable. If you’ve previously used Rmd (RMarkdown), Quarto is backwards-compatible and will able to render most documents with no issues.\n\n\n\n\n\n\nHelp with Quarto\n\n\n\nThe official Quarto Guide is extensive, detailed, and extremely helpful. It’s always the best first stop for any questions you have about using Quarto. Quarto also offers detailed tutorials.\nProf Andy Field has also recorded a series of video guides to using Quarto that are used in UG teaching.\n\n\n\nGetting Started\nTo get some hands-on practice working with Quarto, we will create a new Quarto document from scratch, which will become a short report on a linear model analysis.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new Quarto document via File &gt; New File &gt; Quarto Document.\nIf you like, you can give it a title; you will be able to change this later.\nThen, click “Create”.\n\n\nBy default, your new Quarto document will already have some settings and content to demonstrate how it works. Most importantly, you can see that there are three main types of information in this document:\n\nThe YAML header at the top, delineated by ---s, which contains information about how the document will be rendered\nThe body text, which contains regular text\nThe code chunks, which contain code - in this case, specifically, R.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWe will come to each of these in turn, but for now, delete everything in the document except the YAML header.\n\n\n\n\n\n\n\n\nVisual vs Source Mode\n\n\n\n\n\nA new feature with Quarto is Visual mode, which is very like using Word or a similar word processing programme. All formatting can be applied and previewed in the document itself, using keyboard shortcuts or the familiar formatting buttons along the top toolbar.\nVisual mode also has an “insert anything” shortcut, /, that allows you to quickly insert elements into your document. If you type / at the start of a new line (or Ctrl/Cmd + / otherwise), a drop-down list of possible elements will appear, which you can navigate by scrolling or search by typing.\nAlternatively, you can toggle to Source mode by clicking the “Source” button at the very top left of the document pane. In Source mode you can edit the document using Markdown formatting. This allows more fine-tuned control of elements, but automatic formatting and the / shortcut don’t work in this mode.\nWhich you use is entirely personal preference - I toggle regularly between them depending on what I’m trying to do, so pick whichever works for you.\n\n\n\n\n\nCreating a Setup Code Chunk\nTo prepare for our analysis, we will need a place to load packages and read in the data. Any executable code - that is, code that you want to run and do something - must be written in a code chunk and NOT in the body text1.\n\n\n\n\n\n\nNew Code Chunks\n\n\n\nThere are several ways to insert a new code chunk.\n\nIn Visual mode, by typing / and then Enter (since “R Code Chunk” is the first option)\nIn either mode, by:\n\nClicking the green “insert code chunk” button in the top right\nTyping out the literal code fencing ({r})\nUsing a keyboard shortcut.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk, add commands to load the {tidyverse} package and to read in the dataset located in the data folder of your project into an object called teach_tib, and name the code chunk setup.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLoad {tidyverse}:\nWe don’t know yet what exactly which packages we’ll need, but I make a habit of loading {tidyverse} at the top of any document where I am likely to use it (which is just about always!).\nRead in the data:\nIn the Posit Cloud project workspace for this tutorial, there is a star.csv object. Look back on Tutorial 02 for more detail about how to read in datasets.\nName the code chunk:\nNaming code chunks is optional. Most of the time, it won’t make any difference, although it does help navigate your document a bit easier and find errors. However, it’s a good idea for setup chunks like this because they behave in a different way. Namely, they will always run first when you run any subsequent chunks, and they default to the include: false code chunk option, which prevents any messages or warnings from appearing in your document.\nIn short, name your code chunk by including |# label: setup at the beginning of the chunk, and see the section on code chunk options for more info!\nAltogether, your new code chunk should look like this:\n```{r}\n|# label: setup\n\nlibrary(tidyverse)\n\nteach_tib &lt;- readr::read_csv(\"data/teaching_ratings.csv\")\n```"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#the-linear-model",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#the-linear-model",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "The Linear Model",
    "text": "The Linear Model\nIn this section, we will walk through the process of fitting, comparing, and reporting hierarchical linear models in R. This is not a statistics tutorial, so there will be minimal detail about how to understand or interpret the output of these commands. Instead, refer to Prof Andy Field’s discovr tutorials, which are the primary teaching materials for the same content in UG teaching. All of the code and interpretation in the following section is from discovr_08, the GLM.\n\n\n\n\n\n\nUsing the discovr tutorials\n\n\n\n\n\nProf Andy Field’s discovr tutorials provide detailed walkthroughs of both the R code and the statistical concepts of a variety of statistical analyses. They are a good place to look first to understand what your UG supervisees or advisees have been taught on a particular topic.\nThe tutorials are built in {learnr}, an interactive platform for learning and running R code. So, unlike the tutorial you’re currently reading, they must be run inside an R session. We have already installed all of the tutorials in your Posit Cloud workspace.\nTo open a tutorial, open any project and click on the Tutorial tab in the Environment pane. You can run any tutorial from here, but the relevant one for the linear modelling we are working on now is discovr_08, “the GLM”. Scroll down to this tutorial and click the “Start Tutorial ▶️” button to load the tutorial.\nBecause discovr tutorials run within R, you don’t need to use any external documents; you can write and run R code within the tutorial itself. However, I strongly recommend that whenever you work with these tutorials, you write and run your code in a separate document, otherwise you will have no record of the code and output.\n\n\n\n\n\n\n\n\n\nCodebook\n\n\n\nToday’s data is a truncated version of the TeachingRatings dataset from the {AER} package. You can load the codebook in the Help viewer by running the following in the Console:\n?AER::TeachingRatings\n\n\n\nOne Predictor\nNow that we have some data, we can fit our first model with a single predictor. We will do this with the very hardworking lm() function in R, standing for “linear model”.\nThe lm() function has a lot of options (as you might expect, given the versatility and ubiquity of linear models!), but its basic format to fit a linear model with a single predictor is very simple:\nlm(outcome ~ predictor, data = our_dataset)\nIn this function, outcome ~ predictor is a formula expressing a (simplified version of) the linear model equation. Here, outcome is the name of the variable in our_dataset that contains the outcome or dependent variable y, and predictor is the name of the variable that contains the predictor or independent variable x.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk and use the Codebook and the lm() function to fit a linear model predicting teaching evaluation score from beauty ratings. Save the resulting model in a new object called eval_lm.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm &lt;- lm(eval ~ beauty, data = teach_tib)\n\nThat’s it!\n\n\n\n\n\n\nModel Information\nNow we have a new object that contains all the information about our model. We could simply call the name of this object, but the output doesn’t tell us anything besides the actual value of the b estimates. Instead, we’ll use some useful functions from the {tidyverse} package {broom} to get the information we need.\n\n\nModel Fit\nTo get some common measures of model fit, we can use the function broom::glance(). The output includes \\(R^2\\), adjusted \\(R^2\\), and F and accompanying statistics in comparison to the null model (the mean of the outcome alone).\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::glance() to get model fit statistics.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::glance(eval_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic   p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0357        0.0336 0.545      17.1 0.0000425     1  -375.  757.  769.\n# … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\n\n\n\n\n\nHelpfully, broom::glance() (and many other {tidyverse} functions) output tibbles, which means we can work with them as we already know how to do. In Tutorials 4 and 5, we’ll also learn more about changing and filtering tibbles that will make this very more useful. For now, we can simply note the information we get out of this function for future use.\n\n\nModel Parameters\nTo get information about the b estimates for individual predictors, we can use the function broom::tidy(). We could run this function without any other information, as we did with glance() above, but we’ll change one argument here in order to get 95% confidence intervals for b in the output as well.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::tidy(). Use the argument conf.int = TRUE to obtain confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::tidy(eval_lm, conf.int = TRUE)\n\n# A tibble: 2 × 7\n  term        estimate std.error statistic   p.value conf.low conf.high\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)    4.00     0.0253    158.   0           3.95       4.05 \n2 beauty         0.133    0.0322      4.13 0.0000425   0.0698     0.196\n\n\n\n\n\n\n\n\n\n\nHierarchial Models\nNext, we may want to test the addition of further predictors in the model. We can then compare the more complex multi-predictor model to the single-predictor model.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, fit a linear model with teaching evaluations as the outcome, and both beauty ratings and gender as predictors. Save the model output in a new object called eval_full_lm.\nThen, obtain model fit statistics and parameters as before.\nHint: to add a new predictor, you will need to literally add it (+) to the formula.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_full_lm &lt;- lm(eval ~ beauty + gender, data = teach_tib)\n\nbroom::glance(eval_full_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic     p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0663        0.0622 0.537      16.3 0.000000141     2  -368.  744.  760.\n# … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\nbroom::tidy(eval_full_lm)\n\n# A tibble: 3 × 5\n  term         estimate std.error statistic    p.value\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0         \n2 beauty          0.149    0.0320      4.65 0.00000434\n3 genderfemale   -0.198    0.0510     -3.88 0.000120  \n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat About Interactions?\n\n\n\n\n\nThe models we’re describing here contain only additions, not interactions. So, you may be wondering, “What if I want to model more complex relationships between predictors?” If that’s what you’re trying to do now, you may want to jump ahead to discovr_10 for moderation and mediation.\nOtherwise, we will get there in this course eventually!\n\n\n\n\nComparing Models\nNow we have two models, one simpler with only a single predictor, and the other with two predictors. We might next want to test whether the more complex, two-predictor model is a significant improvement over the simpler model, in order to decide which model to retain. We can do this with the anova() function1 to compare the two models.\n\n\n\n\n\n\nWarning\n\n\n\nThe anova() function will only work for model comparison for particular models.\n\nThe models must be hierarchical. That is, the more complex model(s) must contain all of the predictor(s) present in the less complex model(s).\nAll models must be fit to the same dataset. If, for example, your first predictor has no missing values, but your second predictor had one, the model with using the second predictor would have been fit to a dataset of a different size than the model using only the first, and the anova() function will throw an error to this effect.\n\nIf you encounter this issue, you may need to inspect and clean your dataset before you proceed with analysis!\n\n\n\n\n\n\n\n\nExercise\n\n\n\nPut both model objects into the anova() function to find out which model to retain.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nanova(eval_lm, eval_full_lm)\n\nAnalysis of Variance Table\n\nModel 1: eval ~ beauty\nModel 2: eval ~ beauty + gender\n  Res.Df    RSS Df Sum of Sq      F    Pr(&gt;F)    \n1    461 137.16                                  \n2    460 132.81  1    4.3467 15.056 0.0001196 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nSignificance Codes\n\n\n\n\n\nThe output from many base-R {stats} functions, like anova(), include a line labeled Signif. codes that provide a key for understanding the notation given for significance levels in p-values.\nReading the key from left to right, we can see that a result is given three asterisks (***) when the p-value is between 0 and .001; two asterisks between .001 and .01; and so on.\nThis can be a useful visual check, especially because p-values that are very, very small are frequently expressed in scientific notation, which can make them more difficult to spot.\n\n\n\nThe F-test is significant, indicating that the more complex two-predictor model is a significant improvement over the one-predictor model, so we will proceed with the two-predictor model.\n\n\nStandardised Bs\nYou may have noticed that the output we’ve seen so for only contains unstandardised model parameter estimates. If we want standardised Bs expressing the relationship between predictor(s) and outcome in standard deviation units, we can make use of the model_parameters() function from the {parameters} package to standardise our bs.\n\n\n\n\n\n\nExercise\n\n\n\nUse the standarize = \"refit\" argument in the parameters::model_parameters() function to obtain standardised Bs.\n\n\n\n\n\n\nWarning\n\n\n\nNote the spelling of standardize with a “z”! Spelling it with an “s” will not rescale the parameter estimates.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, standardize = \"refit\")\n\nRegistered S3 methods overwritten by 'parameters':\n  method                           from      \n  as.double.parameters_kurtosis    datawizard\n  as.double.parameters_skewness    datawizard\n  as.double.parameters_smoothness  datawizard\n  as.numeric.parameters_kurtosis   datawizard\n  as.numeric.parameters_skewness   datawizard\n  as.numeric.parameters_smoothness datawizard\n  print.parameters_distribution    datawizard\n  print.parameters_kurtosis        datawizard\n  print.parameters_skewness        datawizard\n  summary.parameters_kurtosis      datawizard\n  summary.parameters_skewness      datawizard\n\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        0.15 | 0.06 | [ 0.03,  0.27] |   2.53 | 0.012 \nbeauty          |        0.21 | 0.05 | [ 0.12,  0.30] |   4.65 | &lt; .001\ngender [female] |       -0.36 | 0.09 | [-0.54, -0.18] |  -3.88 | &lt; .001\n\n\n\n\n\n\n\n\n\n\nAssumptions Checks\nAt Sussex, we teach a range of model diagnostics and robust model sensitivity tests in order to test model assumptions. We will look briefly at each of these in turn.\n\n\n\n\n\n\nTip\n\n\n\nRemember, there are more examples and longer explanations in the discovr_08 tutorial!\n\n\n\nResidual Plots\nTo begin, we can generate nicely formatted, customisable residual plots using the function ggplot2::autoplot(). However, it is essential to load the {ggfortify} package in order for this to work!\n\n\n\n\n\n\nExercise\n\n\n\nLoad the {ggfortify} package and use the autoplot() function to generate residual plots for eval_full_lm. Set the which argument to c(1, 3, 2, 4).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(ggfortify)\n\nLoading required package: ggplot2\n\nggplot2::autoplot(eval_full_lm, which = c(1, 3, 2, 4))\n\nWarning in all(hii == 0) || diff(hii) &lt; 1e-10 * mean(hii, na.rm = TRUE):\n'length(x) = 462 &gt; 1' in coercion to 'logical(1)'\n\n\n\n\n\nIf you’re wondering what’s up with which, the plot() function that autoplot() is based on has a total of six plots available. Here I’ve chosen the two residual plots, the normal Q-Q and the Cook’s distance plot. Plots 5 and 6 have to do with leverage, which we don’t teach at UG level. To see them, simply add them to the which = argument.\n\n\n\n\n\nIf you want to customise the theme or look of these plots further, they are built with {ggplot2} so you can add or change anything about them using that package. We will come round to a detailed exploration of data visualisations with {ggplot2} in Tutorial 06.\n\n\nDistribution of Standardised Residuals\nWe teach UGs that normality is the least important of the assumptions of the linear model - the most important being additivity and linearity - so we\n\n\nRobust Models\nAt UG level, we teach robust models for two purposes:\n\nAs sensitivity tests to check assumptions. If a robust technique that adjusts for a particular issue, such as heteroscedasticity, results in a model that is substantially different from the unadjusted model, we might conclude that the unadjusted model did in fact have that particular issue.\nAs robust alternatives to the unadjusted model.\n\n\nRobust Parameter Estimates\nOur first robust model re-estimates the parameter estimates using robust techniques withe the robust::lmRob() function. We can then compare the robust parameter estimates to the unadjusted ones obtained with lm() to find out if our estimates were biased, and report the robust parameter estimates if they were.\n\n\n\n\n\n\nExercise\n\n\n\nFit the same two-predictor model again with robust::lmRob() and compare the results to the unadjusted two-predictor model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm_rob &lt;- robust::lmRob(eval ~ beauty + gender, data = teach_tib)\n\nRegistered S3 methods overwritten by 'robust':\n  method              from      \n  plot.covfm          fit.models\n  print.covfm         fit.models\n  summary.covfm       fit.models\n  print.summary.covfm fit.models\n\n\nrlm is already registered in the fit.models registry\n\n\ncovfm is already registered in the fit.models registry\n\neval_lm_rob\n\n\nCall:\nrobust::lmRob(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.1044        0.1388       -0.2071  \n\neval_full_lm\n\n\nCall:\nlm(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.0816        0.1486       -0.1978  \n\n\nComparing the values of the two versions of the model, we can see that the parameter estimates have changed very little, so we might conclude that the unadjusted model was fine.\n\n\n\n\n\n\n\nRobust CIs and p-values\nTo test and adjust for heteroscedastic residuals, we can re-estimate the standard error using a robust method. To do this, we’ll use the parameters::model_parameters() function with the argument vcov = \"HC4\" as recommended in the discovr tutorial. To do this, use the unadjusted model object eval_full_lm as the first argument.\n\n\n\n\n\n\nExercise\n\n\n\nUse parameters::model_parameters() to re-estimate the SEs, CIs, and p-values, and compare the results to the unadjusted model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, vcov = \"HC4\")\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        4.08 | 0.03 | [ 4.02,  4.15] | 123.94 | &lt; .001\nbeauty          |        0.15 | 0.03 | [ 0.09,  0.21] |   4.65 | &lt; .001\ngender [female] |       -0.20 | 0.05 | [-0.30, -0.10] |  -3.88 | &lt; .001\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nThe parameter estimates will not change, but the SEs, CIs, and p-values may. Here, the values are nearly identical and there are no major changes - that is, no predictors have become non-significant that were previously significant - so we might again conclude that the unadjusted model was not unduly biased.\n\n\n\n\n\n\n\nBootstrapping\nIf we had a small sample size, a final option would be to bootstrap the confidence intervals. To do this, we will again use parameters::model_parameters(), but this time with bootstrap = TRUE.\nNote: Sample size is not an issue with this dataset (N = 463).\n\n\n\n\n\n\nExercise\n\n\n\nProduce bootstrapped confidence intervals for the two-predictor model and compare to the unadjusted confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, bootstrap = TRUE)\n\nParameter       | Coefficient |         95% CI |      p\n-------------------------------------------------------\n(Intercept)     |        4.08 | [ 4.02,  4.15] | &lt; .001\nbeauty          |        0.15 | [ 0.08,  0.21] | &lt; .001\ngender [female] |       -0.20 | [-0.30, -0.10] | &lt; .001\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nWe could once again note that there are no major changes, as previously, so the evidence of our checks suggests that the original, unadjusted model was not unduly biased."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#quarto-options",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#quarto-options",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Quarto Options",
    "text": "Quarto Options\n\nYAML Options\nThe first thing your new Quarto document contains is a block at the top that looks like this:\n---\ntitle: \"Untitled\"\nformat: html\neditor: visual\n---\nThis block delineated by the ---s is the YAML header. The options here are\n\n\nCode Chunk Options\n\n\nInline Code\n\n\nRendering\n\nDebugging Errors\nHeadings and code chunks Code chunk options Rendering $ subsetting and inline code Maybe another test? With real data to practice? Probably chi-squared, it’s short lol Reading in datasets"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#footnotes",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#footnotes",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSomewhat confusingly, this is not the function we teach UGs to perform ANOVAs! See discovr tutorials 11, 12, 15, and 16 for a detailed guide through the afex package for running linear models with categorical predictors.↩︎\nMostly true, except for inline code!↩︎"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_vizlm.html#quarto",
    "href": "tutorials/01_fundRmentals/03_vizlm.html#quarto",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Quarto",
    "text": "Quarto\nQuarto documents are a mix of text and code, the next generation of R Markdown documents. For our purposes, we will be using R within Quarto, but Quarto documents support the integration of many different coding languages, including Python, Julia, and Observable. If you’ve previously used Rmd (RMarkdown), Quarto is backwards-compatible and will able to render most documents with no issues.\n\n\n\n\n\n\nHelp with Quarto\n\n\n\nThe official Quarto Guide is extensive, detailed, and extremely helpful. It’s always the best first stop for any questions you have about using Quarto. Quarto also offers detailed tutorials.\nProf Andy Field has also recorded a series of video guides to using Quarto that are used in UG teaching.\n\n\n\nGetting Started\nTo get some hands-on practice working with Quarto, we will create a new Quarto document from scratch. We will use the analysis code we’ve already written to create a nicely formatted report.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new Quarto document via File &gt; New File &gt; Quarto Document.\nIf you like, you can give it a title; you will be able to change this later.\nThen, click “Create”.\n\n\nBy default, your new Quarto document will already have some settings and content to demonstrate how it works. Most importantly, you can see that there are three main types of information in this document:\n\nThe YAML header at the top, delineated by ---s, which contains information about how the document will be rendered\nThe body text, which contains regular text\nThe code chunks, which contain code - in this case, specifically, R.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWe will come to each of these in turn, but for now, delete everything in the document except the YAML header.\n\n\n\n\n\n\n\n\nVisual vs Source Mode\n\n\n\n\n\nA new feature with Quarto is Visual mode, which is very like using Word or a similar word processing programme. All formatting can be applied and previewed in the document itself, using keyboard shortcuts or the familiar formatting buttons along the top toolbar.\nVisual mode also has an “insert anything” shortcut, /, that allows you to quickly insert elements into your document. If you type / at the start of a new line (or Ctrl/Cmd + / otherwise), a drop-down list of possible elements will appear, which you can navigate by scrolling or search by typing.\nAlternatively, you can toggle to Source mode by clicking the “Source” button at the very top left of the document pane. In Source mode you can edit the document using Markdown formatting. This allows more fine-tuned control of elements, but automatic formatting and the / shortcut don’t work in this mode.\nWhich you use is entirely personal preference - I toggle regularly between them depending on what I’m trying to do, so pick whichever works for you.\n\n\n\n\n\nCreating a Setup Code Chunk\nTo prepare for our analysis, we will need a place to load packages and read in the data. Any executable code - that is, code that you want to run and do something - must be written in a code chunk and NOT in the body text2.\n\n\n\n\n\n\nNew Code Chunks\n\n\n\nThere are several ways to insert a new code chunk.\n\nIn Visual mode, by typing / and then Enter (since “R Code Chunk” is the first option)\nIn either mode, by:\n\nClicking the green “insert code chunk” button in the top right\nTyping out the literal code fencing ({r})\nUsing a keyboard shortcut.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk, add commands to load all the packages we used in the previous Linear Model section, read in the dataset located in the data folder of your project into an object called teach_tib, and name the code chunk setup.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLoad packages:\nIn the previous section, we used the following packages:\n\n{tidyverse}, or specifically {broom}, for tidying up the linear model output\n{ggfortify} for creating diagnostic plots\n{parameters} for standardising bs, re-estimating CIs, and boostrapping\n{lmRob} for robust parameter estimates\n\nRead in the data:\nIn the Posit Cloud project workspace for this tutorial, there is a teaching.csv object. Look back on Tutorial 02 for more detail about how to read in datasets.\nName the code chunk:\nNaming code chunks is optional. Most of the time, it won’t make any difference, although it does help navigate your document a bit easier and find errors. However, it’s a good idea for setup chunks like this because they behave in a different way. Namely, they will always run first when you run any subsequent chunks, and they default to the include: false code chunk option, which prevents any messages or warnings from appearing in your document.\nIn short, name your code chunk by including |# label: setup at the beginning of the chunk, and see the section on code chunk options for more info!\nAltogether, your new code chunk should look like this:\n```{r}\n|# label: setup\n\nlibrary(tidyverse)\nlibrary(ggfortify)\nlibrary(parameters)\nlibrary(lmRob)\n\nteach_tib &lt;- readr::read_csv(\"data/teaching_ratings.csv\")\n```"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html",
    "href": "tutorials/01_fundRmentals/03_lm.html",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#overview",
    "href": "tutorials/01_fundRmentals/03_lm.html#overview",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#the-linear-model",
    "href": "tutorials/01_fundRmentals/03_lm.html#the-linear-model",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "The Linear Model",
    "text": "The Linear Model\nIn this section, we will walk through the process of fitting, comparing, and reporting hierarchical linear models in R. This is not a statistics tutorial, so there will be minimal detail about how to understand or interpret the output of these commands. Instead, refer to Prof Andy Field’s discovr tutorials, which are the primary teaching materials for the same content in UG teaching. All of the code and interpretation in the following section is from discovr_08, the GLM.\n\nThere are two key goals for this linear model walkthrough:\n\nCreate a detailed “cheatsheet” for a linear model analysis for future reference\nGet familiar with the discovr tutorials\n\nOf the two, the first is more important. I’d strongly recommend you open the relevant discovr tutorial and skim through it as you go so you’re familiar with what it contains. However, the following sections of this tutorial will present the same code and information with very abbreviated text, to serve as a quick reference.\nYou can also have them both open at once and refer to each!\n\n\n\n\n\n\n\nUsing the discovr tutorials\n\n\n\n\n\nProf Andy Field’s discovr tutorials provide detailed walkthroughs of both the R code and the statistical concepts of a variety of statistical analyses. They are a good place to look first to understand what your UG supervisees or advisees have been taught on a particular topic.\nThe tutorials are built in {learnr}, an interactive platform for learning and running R code. So, unlike the tutorial you’re currently reading, they must be run inside an R session. We have already installed all of the tutorials in your Posit Cloud workspace.\nTo open a tutorial, open any project and click on the Tutorial tab in the Environment pane. You can run any tutorial from here, but the relevant one for the linear modelling we are working on now is discovr_08, “the GLM”. Scroll down to this tutorial and click the “Start Tutorial ▶️” button to load the tutorial.\nBecause discovr tutorials run within R, you don’t need to use any external documents; you can write and run R code within the tutorial itself. However, I strongly recommend that whenever you work with these tutorials, you write and run your code in a separate document, otherwise you will have no record of the code and output.\n\n\n\n\nData and Codebook\nToday’s data is a truncated version of the TeachingRatings dataset from the {AER} package. You can load the codebook in the Help viewer by running the following in the Console:\n?AER::TeachingRatings\n\n\nOne Predictor\nNow that we have some data, we can fit our first model with a single predictor. We will do this with the very hardworking lm() function in R, standing for “linear model”.\nThe lm() function has a lot of options (as you might expect, given the versatility and ubiquity of linear models!), but its basic format to fit a linear model with a single predictor is very simple:\nlm(outcome ~ predictor, data = our_dataset)\nIn this function, outcome ~ predictor is a formula expressing a (simplified version of) the linear model equation. Here, outcome is the name of the variable in our_dataset that contains the outcome or dependent variable y, and predictor is the name of the variable that contains the predictor or independent variable x.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk and use the Codebook and the lm() function to fit a linear model predicting teaching evaluation score from beauty ratings. Save the resulting model in a new object called eval_lm.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm &lt;- lm(eval ~ beauty, data = teach_tib)\n\nThat’s it!\n\n\n\n\n\n\nModel Information\nNow we have a new object that contains all the information about our model. We could simply call the name of this object, but the output doesn’t tell us anything besides the actual value of the b estimates. Instead, we’ll use some useful functions from the {tidyverse} package {broom} to get the information we need.\n\n\nModel Fit\nTo get some common measures of model fit, we can use the function broom::glance(). The output includes \\(R^2\\), adjusted \\(R^2\\), and F and accompanying statistics in comparison to the null model (the mean of the outcome alone).\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::glance() to get model fit statistics.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::glance(eval_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic   p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0357        0.0336 0.545      17.1 0.0000425     1  -375.  757.  769.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\n\n\n\n\n\nHelpfully, broom::glance() (and many other {tidyverse} functions) output tibbles, which means we can work with them as we already know how to do. In Tutorials 4 and 5, we’ll also learn more about changing and filtering tibbles that will make this very more useful. For now, we can simply note the information we get out of this function for future use.\n\n\nModel Parameters\nTo get information about the b estimates for individual predictors, we can use the function broom::tidy(). We could run this function without any other information, as we did with glance() above, but we’ll change one argument here in order to get 95% confidence intervals for b in the output as well.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::tidy(). Use the argument conf.int = TRUE to obtain confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::tidy(eval_lm, conf.int = TRUE)\n\n# A tibble: 2 × 7\n  term        estimate std.error statistic   p.value conf.low conf.high\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)    4.00     0.0253    158.   0           3.95       4.05 \n2 beauty         0.133    0.0322      4.13 0.0000425   0.0698     0.196\n\n\n\n\n\n\n\n\n\n\nHierarchial Models\nNext, we may want to test the addition of further predictors in the model. We can then compare the more complex multi-predictor model to the single-predictor model.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, fit a linear model with teaching evaluations as the outcome, and both beauty ratings and gender as predictors. Save the model output in a new object called eval_full_lm.\nThen, obtain model fit statistics and parameters as before.\nHint: to add a new predictor, you will need to literally add it (+) to the formula.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_full_lm &lt;- lm(eval ~ beauty + gender, data = teach_tib)\n\nbroom::glance(eval_full_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic     p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0663        0.0622 0.537      16.3 0.000000141     2  -368.  744.  760.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\nbroom::tidy(eval_full_lm)\n\n# A tibble: 3 × 5\n  term         estimate std.error statistic    p.value\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0         \n2 beauty          0.149    0.0320      4.65 0.00000434\n3 genderfemale   -0.198    0.0510     -3.88 0.000120  \n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat About Interactions?\n\n\n\n\n\nThe models we’re describing here contain only additions, not interactions. So, you may be wondering, “What if I want to model more complex relationships between predictors?” If that’s what you’re trying to do now, you may want to jump ahead to discovr_10 for moderation and mediation.\nOtherwise, we will get there in this course eventually!\n\n\n\n\nComparing Models\nNow we have two models, one simpler with only a single predictor, and the other with two predictors. We might next want to test whether the more complex, two-predictor model is a significant improvement over the simpler model, in order to decide which model to retain. We can do this with the anova() function1 to compare the two models.\n\n\n\n\n\n\nWarning\n\n\n\nThe anova() function will only work for model comparison for particular models.\n\nThe models must be hierarchical. That is, the more complex model(s) must contain all of the predictor(s) present in the less complex model(s).\nAll models must be fit to the same dataset. If, for example, your first predictor has no missing values, but your second predictor had one, the model with using the second predictor would have been fit to a dataset of a different size than the model using only the first, and the anova() function will throw an error to this effect.\n\nIf you encounter this issue, you may need to inspect and clean your dataset before you proceed with analysis!\n\n\n\n\n\n\n\n\nExercise\n\n\n\nPut both model objects into the anova() function to find out which model to retain.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nanova(eval_lm, eval_full_lm)\n\nAnalysis of Variance Table\n\nModel 1: eval ~ beauty\nModel 2: eval ~ beauty + gender\n  Res.Df    RSS Df Sum of Sq      F    Pr(&gt;F)    \n1    461 137.16                                  \n2    460 132.81  1    4.3467 15.056 0.0001196 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nSignificance Codes\n\n\n\n\n\nThe output from many base-R {stats} functions, like anova(), include a line labeled Signif. codes that provide a key for understanding the notation given for significance levels in p-values.\nReading the key from left to right, we can see that a result is given three asterisks (***) when the p-value is between 0 and .001; two asterisks between .001 and .01; and so on.\nThis can be a useful visual check, especially because p-values that are very, very small are frequently expressed in scientific notation, which can make them more difficult to spot.\n\n\n\nThe F-test is significant, indicating that the more complex two-predictor model is a significant improvement over the one-predictor model, so we will proceed with the two-predictor model.\n\n\nStandardised Bs\nYou may have noticed that the output we’ve seen so for only contains unstandardised model parameter estimates. If we want standardised Bs expressing the relationship between predictor(s) and outcome in standard deviation units, we can make use of the model_parameters() function from the {parameters} package to standardise our bs.\n\n\n\n\n\n\nExercise\n\n\n\nUse the standarize = \"refit\" argument in the parameters::model_parameters() function to obtain standardised Bs.\n\n\n\n\n\n\nWarning\n\n\n\nNote the spelling of standardize with a “z”! Spelling it with an “s” will not rescale the parameter estimates.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, standardize = \"refit\")\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        0.15 | 0.06 | [ 0.03,  0.27] |   2.53 | 0.012 \nbeauty          |        0.21 | 0.05 | [ 0.12,  0.30] |   4.65 | &lt; .001\ngender [female] |       -0.36 | 0.09 | [-0.54, -0.18] |  -3.88 | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a Wald t-distribution approximation.\n\n\n\n\n\n\n\n\n\n\nAssumptions Checks\nAt Sussex, we teach a range of model diagnostics and robust model sensitivity tests in order to test model assumptions. We will look briefly at each of these in turn.\n\n\n\n\n\n\nTip\n\n\n\nRemember, there are more examples and longer explanations in the discovr_08 tutorial!\n\n\n\nResidual Plots\nTo begin, we can generate nicely formatted, customisable residual plots using the function ggplot2::autoplot(). However, it is essential to load the {ggfortify} package in order for this to work!\n\n\n\n\n\n\nExercise\n\n\n\nLoad the {ggfortify} package and use the autoplot() function to generate residual plots for eval_full_lm. Set the which argument to c(1, 3, 2, 4).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(ggfortify)\n\nWarning: package 'ggfortify' was built under R version 4.3.1\n\n\nLoading required package: ggplot2\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\nggplot2::autoplot(eval_full_lm, which = c(1, 3, 2, 4))\n\n\n\n\nIf you’re wondering what’s up with which, the plot() function that autoplot() is based on has a total of six plots available. Here I’ve chosen the two residual plots, the normal Q-Q and the Cook’s distance plot. Plots 5 and 6 have to do with leverage, which we don’t teach at UG level. To see them, simply add them to the which = argument.\n\n\n\n\n\nIf you want to customise the theme or look of these plots further, they are built with {ggplot2} so you can add or change anything about them using that package. We will come round to a detailed exploration of data visualisations with {ggplot2} in Tutorial 06.\n\n\nDistribution of Standardised Residuals\nIn the UG core statistics modules at Sussex, we teach that normality is the least important of the assumptions of the linear model - the most important being additivity and linearity - so we do not generally worry too much about normally distributed standardised residuals, especially in large sample sizes. However, we do teach them how to evaluate the proportion of standardised residuals with values above $$1.96 (approximately 5%), $$2.56 (approximately 1%), and above $$3 (likely an outlier). For details on how to use broom::augment() to obtain standardised residuals and other model diagnostic measures like Cook’s distance, see the discovr_08 tutorial.\n\n\nRobust Models\nAt UG level, we teach robust models for two purposes:\n\nAs sensitivity tests to check assumptions. If a robust technique that adjusts for a particular issue, such as heteroscedasticity, results in a model that is substantially different from the unadjusted model, we might conclude that the unadjusted model did in fact have that particular issue.\nAs robust alternatives to the unadjusted model.\n\n\nRobust Parameter Estimates\nOur first robust model re-estimates the parameter estimates using robust techniques withe the robust::lmRob() function. We can then compare the robust parameter estimates to the unadjusted ones obtained with lm() to find out if our estimates were biased, and report the robust parameter estimates if they were.\n\n\n\n\n\n\nExercise\n\n\n\nFit the same two-predictor model again with robust::lmRob() and compare the results to the unadjusted two-predictor model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm_rob &lt;- robust::lmRob(eval ~ beauty + gender, data = teach_tib)\n\neval_lm_rob\n\n\nCall:\nrobust::lmRob(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.1044        0.1388       -0.2071  \n\neval_full_lm\n\n\nCall:\nlm(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.0816        0.1486       -0.1978  \n\n\nComparing the values of the two versions of the model, we can see that the parameter estimates have changed very little, so we might conclude that the unadjusted model was fine.\n\n\n\n\n\n\n\nRobust CIs and p-values\nTo test and adjust for heteroscedastic residuals, we can re-estimate the standard error using a robust method. To do this, we’ll use the parameters::model_parameters() function with the argument vcov = \"HC4\" as recommended in the discovr tutorial. To do this, use the unadjusted model object eval_full_lm as the first argument.\n\n\n\n\n\n\nExercise\n\n\n\nUse parameters::model_parameters() to re-estimate the SEs, CIs, and p-values, and compare the results to the unadjusted model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, vcov = \"HC4\")\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        4.08 | 0.03 | [ 4.02,  4.15] | 125.28 | &lt; .001\nbeauty          |        0.15 | 0.03 | [ 0.08,  0.21] |   4.59 | &lt; .001\ngender [female] |       -0.20 | 0.05 | [-0.30, -0.10] |  -3.94 | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a Wald t-distribution approximation.\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nThe parameter estimates will not change, but the SEs, CIs, and p-values may. Here, the values are nearly identical and there are no major changes - that is, no predictors have become non-significant that were previously significant - so we might again conclude that the unadjusted model was not unduly biased.\n\n\n\n\n\n\n\nBootstrapping\nIf we had a small sample size, a final option would be to bootstrap the confidence intervals. To do this, we will again use parameters::model_parameters(), but this time with bootstrap = TRUE.\nNote: Sample size is not an issue with this dataset (N = 463).\n\n\n\n\n\n\nExercise\n\n\n\nProduce bootstrapped confidence intervals for the two-predictor model and compare to the unadjusted confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, bootstrap = TRUE)\n\nParameter       | Coefficient |         95% CI |      p\n-------------------------------------------------------\n(Intercept)     |        4.08 | [ 4.02,  4.15] | &lt; .001\nbeauty          |        0.15 | [ 0.08,  0.21] | &lt; .001\ngender [female] |       -0.20 | [-0.30, -0.10] | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) are naıve bootstrap intervals.\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nWe could once again note that there are no major changes, as previously, so the evidence of our checks suggests that the original, unadjusted model was not unduly biased."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#quarto",
    "href": "tutorials/01_fundRmentals/03_lm.html#quarto",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Quarto",
    "text": "Quarto\nQuarto documents are a mix of text and code, the next generation of R Markdown documents. For our purposes, we will be using R within Quarto, but Quarto documents support the integration of many different coding languages, including Python, Julia, and Observable. If you’ve previously used Rmd (RMarkdown), Quarto is backwards-compatible and will able to render most documents with no issues.\n\n\n\n\n\n\nHelp with Quarto\n\n\n\nThe official Quarto Guide is extensive, detailed, and extremely helpful. It’s always the best first stop for any questions you have about using Quarto. Quarto also offers detailed tutorials.\nThis quick-reference to Markdown formatting is particularly helpful.\nProf Andy Field has also recorded a series of video guides to using Quarto that are used in UG teaching.\n\n\n\nGetting Started\nTo get some hands-on practice working with Quarto, we will create a new Quarto document from scratch. We will use the analysis code we’ve already written to create a nicely formatted report.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new Quarto document via File &gt; New File &gt; Quarto Document.\nIf you like, you can give it a title; you will be able to change this later.\nThen, click “Create”.\n\n\nBy default, your new Quarto document will already have some settings and content to demonstrate how it works. Most importantly, you can see that there are three main types of information in this document:\n\nThe YAML header at the top, delineated by ---s, which contains information about how the document will be rendered\nThe body text, which contains regular (i.e. non-code) text\nThe code chunks, which contain code - in this case, specifically, R.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nTo complete our setup, take the following steps:\n\nDelete everything in the new Quarto document except for the YAML header (i.e. all the text and code chunks).\nClear your Environment by clicking the broom icon in the Environment tab.\nRestart your R session (via Session &gt; Restart R).\n\n\n\n\n\n\n\nWarning\n\n\n\nMake sure you have completed and saved your worksheet with all of your code before you do this!\n\n\n\n\n\n\n\n\n\n\nVisual vs Source Mode\n\n\n\n\n\nA new feature with Quarto is Visual mode, which is very like using Word or a similar word processing programme. All formatting can be applied and previewed in the document itself, using keyboard shortcuts or the familiar formatting buttons along the top toolbar.\nVisual mode also has an “insert anything” shortcut, /, that allows you to quickly insert elements into your document. If you type / at the start of a new line (or Ctrl/Cmd + / otherwise), a drop-down list of possible elements will appear, which you can navigate by scrolling or search by typing.\nAlternatively, you can toggle to Source mode by clicking the “Source” button at the very top left of the document pane. In Source mode you can edit the document using Markdown formatting. This allows more fine-tuned control of elements, but automatic formatting and the / shortcut don’t work in this mode.\nWhich you use is entirely personal preference - I toggle regularly between them depending on what I’m trying to do, so pick whichever works for you.\n\n\n\n\n\nCreating a Code Chunk\nTo prepare for our analysis, we will need a place to load packages and read in the data. Any executable code - that is, code that you want to run and do something - must be written in a code chunk and NOT in the body text2.\n\n\n\n\n\n\nInserting Code Chunks\n\n\n\nThere are several ways to insert a new code chunk.\n\nIn Visual mode, by typing / and then Enter (since “R Code Chunk” is the first option)\nIn either mode, by:\n\nClicking the green “insert code chunk” button in the top right\nTyping out the literal code fencing: ```{r} ```\nUsing a keyboard shortcut.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk and code that does the following:\n\nLoad all the packages we used in the previous Linear Model section\nRead in the dataset located in the data folder of your project into an object called teach_tib\nCreate the two objects containing the linear models with one predictor and with two predictors.\n\nThen, run the code chunk.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLoad packages:\nIn the previous section, we used the following packages:\n\n{tidyverse}, or specifically {broom}, for tidying up the linear model output\n{ggfortify} for creating diagnostic plots\n{parameters} for standardising bs, re-estimating CIs, and boostrapping\n{robust} for robust parameter estimates\n\nRead in the data:\nIn the Posit Cloud project workspace for this tutorial, there is a teaching.csv object. Look back on Tutorial 02 for more detail about how to read in datasets.\nCreate the models:\nCopy and paste the code from your workbook document, or from the previous sections of this tutorial. You can also find all of the commands you have run your History tab (next to Environment).\nAltogether, your new code chunk should look like this:\n```{r}\nlibrary(tidyverse)\nlibrary(ggfortify)\nlibrary(parameters)\nlibrary(robust)\n\nteach_tib &lt;- readr::read_csv(\"data/teaching_ratings.csv\")\n\neval_lm &lt;- lm(eval ~ beauty, data = teach_tib)\neval_full_lm &lt;- lm(eval ~ beauty + gender, data = teach_tib)\n```\nRun the code chunk by clicking the green “play” arrow, or by pressing Ctrl/Cmd + Shift + Enter while your cursor is inside the chunk.\n\n\n\n\n\n\n\nHeadings and Text\n\nHeadings\nTo begin, we’ll use headings to map out our document. Properly formatted headings are strongly recommended for any documents you write, for a variety of reasons:\n\nThey automatically create the outline (to the right) and navigation menu (to the bottom) of your document for easy navigation\nThey can be automatically converted into a table of contents\nThey are a crucial accessibility feature for navigating the document via keyboard/screenreader, as well as providing clear visual structure.\n\n\n\n\n\n\n\nInserting Headings\n\n\n\nThere are several ways to insert a new heading.\n\nIn Visual mode, by:\n\nUsing the text formatting dropdown. Click on “Normal” and select the heading level.\nUsing a keyboard shortcut, Ctrl + Alt + the number of the heading (e.g. 3 for a level 3 heading)\n\nIn either mode, by:\n\nTyping hashes at the start of a new line, followed by a space (e.g. ### creates a level 3 heading)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate 2-3 level 2 headings in your document for the brief report of the linear model. You can choose anything you like, but the three I will refer to will be called “Model Comparison” (constructing and comparing the two models), “Assumptions Checks”, and “The Final Model” (reporting the final model in full).\n\n\n\n\nBody Text\nAny new-line text will automatically be plain text. This can be anything you like, although in our current document, we are writing a mock-formal results section.\n\n\n\n\n\n\nFormatting Text\n\n\n\nHow to format body text depends on the mode you are in.\n\nIn Visual mode, by:\n\nUsing familiar keyboard shortcuts (e.g. Ctrl/Cmd + B for bold, Ctrl/Cmd + I for italics, etc.)\nUsing the formatting toolbar at the top of the document.\n\nIn Source mode, by using Markdown formatting.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUnder the first heading (which I have called “Model Comparison”), write a brief, journal-style description of the variables the two models contain.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf you aren’t inclined to write your own, here’s a brief sample text to use.\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (R2 = ???, F(???, ???) = ???, p = ???). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (R2 = ???, F(???, ???) = ???, p = ???). An ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(???, ???) = ???, p = ???).\n\n\n\n\n\n\n\n\n\nDynamic Reporting\nThat last sentence should report which of the two models was better, based on the result of our F-test, rather than question marks. We could produce the output of this test, read it ourselves with our very own eyes/ears, and then type out the results by hand…but that is definitely not what we are going to do! Instead, we’ll look at a couple options for reporting the results dynamically. (We’ll come back to the model R2s in a moment.)\n\nInline Code\nOur first option is to use inline code to report the numbers. In order to do this, we first need to know what information we have available in the test output, so we can make use of it.\n\n\n\n\n\n\nTip\n\n\n\nThis section will make extensive use of $ subsetting, which was covered in Tutorial 02, and [] subsetting, which was covered in Tutorial 01.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, use the broom::tidy() function to get a nice tibble of the anova() comparison between the two models, and save it in a new object called tidy_f. Then, print out this object in the Console.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe are creating the tidy_f object in a code chunk because we will want to use it again in our report.\nWe are calling this object in the Console because viewing its contents is only for our information/reference, and not something we want to appear or use directly in our finished document.\n\n## In a code chunk\ntidy_f &lt;- broom::tidy(anova(eval_lm, eval_full_lm))\n\n## In the Console\ntidy_f\n\n# A tibble: 2 × 7\n  term                   df.residual   rss    df sumsq statistic   p.value\n  &lt;chr&gt;                        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 eval ~ beauty                  461  137.    NA NA         NA   NA       \n2 eval ~ beauty + gender         460  133.     1  4.35      15.1  0.000120\n\n\n\n\n\n\n\nThe tibble we get here is quite different from the “Analysis of Variance Table” text output that we saw earlier when we printed out the results of the anova() function on its own. We now have all the values we need to report these results in a conveniently subsettable tibble with nice R-friendly names.\nSo, let’s have a go getting at some of those values.\n\n\n\n\n\n\nExercise\n\n\n\nGet out the F-ratio of 15.0554899 from this object, and round it to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst, we need to get out the statistic variable, which we can do with $.\n\ntidy_f$statistic\n\n[1]       NA 15.05549\n\n\nThis returns a vector of two values, NA and 15.0554899. To index the second of these values, we need [] subsetting and the index number of the correct value.\n\ntidy_f$statistic[2]\n\n[1] 15.05549\n\n\nFinally, we can use the round() function to round to two decimal places.\n\nround(tidy_f$statistic[2], 2)\n\n[1] 15.06\n\n\n\n\n\n\n\nWe now have a bit of R code that produces a single number that we want to report in the text3. The issue is that code chunks contain code, and body text contains text, but we would like the code that we’ve written to print out its value in the text!\nThe solution is inline code, a small bit of R code written in the body text (“inline”) that will, when the document is rendered, automatically insert the right number. Inline code is written as follows, in the text: `r some_r_code`\nFor our reporting, we will need to insert the inline code in exactly the spot where we would like the output of the code to appear. This particular bit of code produces the F-statistic, so we can replace the “???”s in our reporting where the value of the F-statistic should go:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(???, ???) = `r round(tidy_f$statistic[2], 2)`, p = ???).\n\nYou can check whether this has worked in two ways:\n\nPlace your cursor inside the backticks and press Ctrl/Cmd + Enter, as you would inside a code chunk. This will run the code and a small pop-up will show you what that code will produce when rendered.\nRender your document and see what appears!\n\n\n\n\n\n\n\nExercise\n\n\n\nUse inline code to replace all of the ???s in the F-test reporting to produce a final report in APA style.\nHint: Rounding p-values is a bit tricky. Check out the {papaja} package to see if you can find a function besides round() that will produce the p-value with the correct formatting.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAll of the other numbers should be straightforward, except for the p-value. Rounding to three decimal places with round() will result in a value of 0, which is not what we want. Instead, since the p-value is below .001, we want “&lt; .001”.\n{papaja} has the printp() function, which will do this exactly was we like (as well as containing a lot of other useful functions for rounding and printing in APA style!)\nYour final text may look like this:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(`r tidy_f$df[2]`, `r tidy_f$df.residual[2]`) = `r round(tidy_f$statistic[2], 2)`, p `r papaja::printp(tidy_f$p.value[2]`).\n\nNote that there’s no need for a “&lt;” symbol because papaja::printp() includes it automatically.\nThis will render as:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(1, 460) = 15.06, p &lt; .001).\n\n\n\n\nCHALLENGE: Create a bit of inline code that will either report a significant or non-significant result depending on the value of p.\nHint: You may need to check out the ifelse() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf we really want our reporting to be resilient, we want to remove or replace all the places where we have to manually remember to update the code if our results change. In this case, our reporting reads:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit…\n\nBut if we wanted to reuse this code for another report, we would have to remember to update this depending on the actual value of p. OR, we can have R do it for us.\nFirst, we need to write a bit of R code that will evaluate whether the value of p is above or below a particular threshold, and then output the correct text. We could do this with ifelse(), a handy little base R function with three arguments. The first is a test returning a logical value (either TRUE or FALSE). If the test returns TRUE, the second argument is executed; if the test returns FALSE, the final argument is executed.\n\nifelse(\n1  tidy_f$p.value[2] &lt; .05,\n2  \"significant\",\n3  \"non-significant\"\n)\n\n\n1\n\nThe test: is the p-value for our F-test less than .05? (If you have a different \\(\\alpha\\)-threshold, you could hard-code it here or use an object you’ve defined previously for this comparison.)\n\n2\n\nWhat to do if the test returns TRUE: print “significant”.\n\n3\n\nWhat to do if the test returns FALSE: print “non-significant”.\n\n\n\n\n[1] \"significant\"\n\n\nWe can then take this command and replace the word “significant” in our report with this inline code:\n\nAn ANOVA comparing the models indicated a `r ifelse(tidy_f$p.value[2] &lt; .05, \"significant\", \"non-significant\")` improvement in model fit…\n\nNow we don’t have to worry about getting this right: our document, when rendered, will automatically insert the right word depending on the data.\n\n\n\n\n\n\n\nAutomatic Reporting\nAs helpful as inline code is (and I would recommend reporting all values dynamically/automatically wherever possible, so it is very useful!), you may have noticed that there was a lot of repetitive typing that also made the text itself quite difficult to read, as well lots of opportunities make typos or mistakes. Surely there’s a simpler way to do this sort of thing!\nThere are, in fact, many simpler ways to do common tasks like this, which take advantage of the fact that an object created by a particular function will always have the same structure. One option is to make further use of the {papaja} package, which is designed for just this purpose.\n\n\n\n\n\n\nExercise\n\n\n\nUse the {papaja} documentation to fill in the statistical reporting for each of the linear models (i.e., R2, F, and p) using only one piece of inline code for each.\nWhen you’re done, render your document to see the results!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe {papaja} documentation illustrates the process using t.test(), which works the same way as lm(). The key here is to use the original objects containing the models you want to report.\nLet’s have a look at the first of the two models and see what the papaja::apa_print() function gives us.\n\npapaja::apa_print(eval_lm)\n\n$estimate\n$estimate$Intercept\n[1] \"$b = 4.00$, 95\\\\% CI $[3.95, 4.05]$\"\n\n$estimate$beauty\n[1] \"$b = 0.13$, 95\\\\% CI $[0.07, 0.20]$\"\n\n$estimate$modelfit\n$estimate$modelfit$r2\n[1] \"$R^2 = .04$\"\n\n$estimate$modelfit$r2_adj\n[1] \"$R^2_{adj} = .03$\"\n\n$estimate$modelfit$aic\n[1] \"$\\\\mathrm{AIC} = 756.65$\"\n\n$estimate$modelfit$bic\n[1] \"$\\\\mathrm{BIC} = 769.06$\"\n\n\n\n$statistic\n$statistic$Intercept\n[1] \"$t(461) = 157.73$, $p &lt; .001$\"\n\n$statistic$beauty\n[1] \"$t(461) = 4.13$, $p &lt; .001$\"\n\n$statistic$modelfit\n$statistic$modelfit$r2\n[1] \"$F(1, 461) = 17.08$, $p &lt; .001$\"\n\n\n\n$full_result\n$full_result$Intercept\n[1] \"$b = 4.00$, 95\\\\% CI $[3.95, 4.05]$, $t(461) = 157.73$, $p &lt; .001$\"\n\n$full_result$beauty\n[1] \"$b = 0.13$, 95\\\\% CI $[0.07, 0.20]$, $t(461) = 4.13$, $p &lt; .001$\"\n\n$full_result$modelfit\n$full_result$modelfit$r2\n[1] \"$R^2 = .04$, $F(1, 461) = 17.08$, $p &lt; .001$\"\n\n\n\n$table\nA data.frame with 6 labelled columns:\n\n       term estimate     conf.int statistic  df p.value\n1 Intercept     4.00 [3.95, 4.05]    157.73 461  &lt; .001\n2    Beauty     0.13 [0.07, 0.20]      4.13 461  &lt; .001\n\nterm     : Predictor \nestimate : $b$ \nconf.int : 95\\\\% CI \nstatistic: $t$ \ndf       : $\\\\mathit{df}$ \np.value  : $p$ \nattr(,\"class\")\n[1] \"apa_results\" \"list\"       \n\n\nWe’ve got a huge number of options here, but for this exercise we wanted R2, F, and p. All three are given under $full_result$modelfit$r2. We will need to save the output from apa_print() into an object, then we can subset it using inline code:\n\neval_lm_out &lt;- papaja::apa_print(eval_lm)\neval_full_lm_out &lt;- papaja::apa_print(eval_full_lm)\n\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (`r eval_lm_out$full_result$modelfit$r2`). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (`r eval_full_lm_out$full_result$modelfit$r2`).\n\nWhich will render as:\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (\\(R^2 = .04\\), \\(F(1, 461) = 17.08\\), \\(p &lt; .001\\)). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (\\(R^2 = .07\\), \\(F(2, 460) = 16.33\\), \\(p &lt; .001\\)).\n\n\n\n\n\n\n\n\nTable Formatting\nNext, we will jump to the “Final Model” heading and have a look at how to turn our final model output into a nicely formatted table. Once again, {papaja} provides a quick and beautiful solution for reporting, so let’s use it again.\n\n\n\n\n\n\nExercise\n\n\n\nUsing the {papaja} help documentation, produce a nicely formatted table of the final model, presenting the parameter estimates, p-values etc. for each predictor under the third (“Final Model”) heading.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe already have the necessary object, eval_full_lm_out, from the previous task. We just need to subset it as described in the help documentation.\nThis command should go in a new code chunk, wherever you want the table to appear in your document.\n\npapaja::apa_table(eval_full_lm_out$table)\n\n\n(#tab:unnamed-chunk-19)\n\n\nPredictor\n\\(b\\)\n95% CI\n\\(t\\)\n\\(\\mathit{df}\\)\n\\(p\\)\n\n\n\n\nIntercept\n4.08\n[4.02, 4.15]\n123.94\n460\n&lt; .001\n\n\nBeauty\n0.15\n[0.09, 0.21]\n4.65\n460\n&lt; .001\n\n\nGenderfemale\n-0.20\n[-0.30, -0.10]\n-3.88\n460\n&lt; .001\n\n\n\n\n\n\n\n\nCHALLENGE: {papaja} isn’t the only package to provide easy formatting for commonly reported tests. Have a go creating this table again using the nice_table() function from the {rempsyc} package, which allows a bit more flexibility in\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe nice_table() function can be for tables generally, but it can apply specialised formatting for model tables created with broom, if we use the broom = argument to tell the function what formatting template to apply.\n\nrempsyc::nice_table(broom::tidy(eval_full_lm, conf.int = TRUE), broom = \"lm\")\n\n\nTermbSEtp95% CI(Intercept)4.080.03123.94&lt; .001***[4.02, 4.15]beauty0.150.034.65&lt; .001***[0.09, 0.21]genderfemale-0.200.05-3.88&lt; .001***[-0.30, -0.10]\n\n\n\n\n\n\n\n\n\nCross-Referencing\nAs anyone who has had to create a long document with lots of tables and figures knows, keeping track of the numbering is a huge pain, especially when, for instance, a reviewer asks you to add something partway through and then everything has to be renumbered4.\nThe good news is that Quarto can take care of figure and table numbering automatically. There are two steps to this:\n\nInclude a label in the relevant code chunk, using the prefix fig- for figures and tbl- for tables.\nRefer to the figure or table in the text using @.\n\n\n\n\n\n\n\nExercises\n\n\n\nUsing the Quarto help documentation, write a short introductory sentence under the “Final Model” heading and refer to the final model table with a cross-reference.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst, add a label and caption to the code chunk from the previous task that produces the model table.\n```{r}\n#| label: tbl-final-model\n#| tbl-cap: \"The final model predicting teaching evaluation ratings from instructor beauty and gender.\"\n\npapaja::apa_table(eval_full_lm_out$table,\n                  caption = \"The final model predicting teaching evaluation ratings from instructor beauty and gender.\")\n```\nYou can of course write whatever you like, or borrow the text below, but use “Table 1” (or whatever label your gave the table code chunk) to refer to the table.\n\nThe final model with two predictors is presented in full in @tbl-final-model.\n\nAltogether, it should render as follows:\n\nThe Final Model\nThe final model with two predictors is presented in full in Table 1.\n\n\npapaja::apa_table(eval_full_lm_out$table)\n\n\n\nTable 1: The final model predicting teaching evaluation ratings from instructor beauty and gender.\n\n\nPredictor\n\\(b\\)\n95% CI\n\\(t\\)\n\\(\\mathit{df}\\)\n\\(p\\)\n\n\n\n\nIntercept\n4.08\n[4.02, 4.15]\n123.94\n460\n&lt; .001\n\n\nBeauty\n0.15\n[0.09, 0.21]\n4.65\n460\n&lt; .001\n\n\nGenderfemale\n-0.20\n[-0.30, -0.10]\n-3.88\n460\n&lt; .001\n\n\n\n\n\n\n\n\n\nCHALLENGE: Complete the final “Assumptions Checks” section summarising the checks and using figure cross-referencing to insert and refer to the diagnostic plots.\nHint: To report the exact maximum value of Cook’s distance, you will also need to refer to discovr_08 for how to use broom::augment().\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou can write whatever you like, but here’s a suggestion with the plot included.\n\nAssumptions Checks\nWe next assessed the model with two predictors for any evidence of bias. Residual plots (@fig-diag-plots) did not indicate any outstanding issues with normality, linearity, or heteroscedasticity. There was also no evidence of influential cases, as the max value of Cook’s distance was `r round(max(broom::augment(eval_full_lm)$.cooksd), 2)`. Robust models were also fitted as sensitivity checks. Robust parameter estimates estimated using the {robust} package were minimally different from the unadjusted parameter estimates. Similarly, robust HC4 standard errors estimated using the {parameters} package yielded confidence intervals and p-values very similar to the unadjusted values. Therefore, we will proceed with the unadjusted two-predictor model as our final model.\n\n```{r}\n#| label: fig-diag-plots\n#| fig-cap: \"Diagnostic plots for the two-predictor model.\"\n\nggplot2::autoplot(eval_full_lm, which = c(1, 3, 2, 4))\n```\n\n\n\n\n\n\n\n\nRendering\nAfter all this work to analyse, interpret, and report, it’s finally time to produce the final document. The process of turning a Quarto document into some output format - including running all the code and applying all the formatting - is called rendering (previously knitting with RMarkdown).\n\n\n\n\n\n\nExercise\n\n\n\nRender your report document using the “Render” button at the top of the document, or by using the keyboard shortcut Ctrl/Cmd + Shift + K5.\n\n\n\nGlobal Options\nAt the moment, your report may not be as clean as we’d like it to be: there are likely messages from R floating around and code all over the place, whereas for a formal report, we of course only want to show the final output. This is where the YAML header comes in.\nThe default YAML header contains only a few explicit settings, and if you haven’t changed anything, probably looks like this:\n---\ntitle: \"Untitled\"\nformat: html\neditor: visual\n---\nBy adding options to the YAML header, we can determine how the document as a whole is rendered. Here are the common ones that I use on the regular:\n\n---\ntitle: \"Linear Model Report\"\nformat:\n  html:\n1    toc: true\neditor: visual\n2self-contained: true\n3execute:\n4  echo: false\n5  warning: false\n6  message: false\n---\n\n\n1\n\nAutomatically produce a table of contents (ToC) from the document headings.\n\n2\n\nCombine all the files, images, stylesheets etc. into a single output document. Necessary if you want to send an HTML file to someone else and have it look as it should!\n\n3\n\nSet default behaviour for all code chunks as follows\n\n4\n\nRun code and show output, but do not show the code itself.\n\n5\n\nDo not show any warnings produced by code.\n\n6\n\nDo not show any messages produced by code.\n\n\n\n\nThe requirements for each document will change depending on its purpose, so you will likely find that\n\n\n\n\n\n\nTip\n\n\n\nThe Quarto help documentation, as usual, has a complete list of YAML options, including how to set default behaviour for figures and other settings.\n\n\n\n\nCode Chunk Options\nGlobal options apply to the entire document, but you may want to change these settings for individual code chunks to override the default settings in the YAML.\nFor example, you may have a code chunk containing some processing code that you used to view and clean your data. If your global execution option is set to echo: false, the code output would still appear, although the code itself would be hidden. If, for this particular code chunk, you don’t want the output to appear either, you can override the global option with a local option for that chunk only.\nLocal code chunk options appear as “hashpipe” (#|) comments, as we have seen earlier with labels. They use the same syntax as YAML, but the settings only apply to individual code chunks. Any settings that aren’t explicitly changed within the chunk are inherited from the YAML settings.\nFor this example, we could set a local code chunk option include: false which will prevent the output from appearing in the document.6\n```{r}\n#| include: false\n\nsome_code_doing_cleaning_and_processing\n```\n\n\nOutput Formats\nFor these tutorials, we will generally stick to HTML, as it’s the most painless of the rendering options. However, you will likely find yourself wanting to produce some other type of document, which you can easily7 do from the same Quarto document.\nTo render to a different format, change the YAML format: setting to a different output.\n\n\n\n\n\n\nTip\n\n\n\nAs per, the Quarto guide on output formats has all the information you need!\n\n\n\n\n\n\n\n\nExercise\n\n\n\nRender your linear model report to a Word document.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSimply update the format: html YAML option to format: docx and render your document. Note that the format options are usually named after the file extension rather than the name of the programme necessarily."
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#quarto-options",
    "href": "tutorials/01_fundRmentals/03_lm.html#quarto-options",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Quarto Options",
    "text": "Quarto Options\n\nYAML Options\nThe first thing your new Quarto document contains is a block at the top that looks like this:\n---\ntitle: \"Untitled\"\nformat: html\neditor: visual\n---\nThis block delineated by the ---s is the YAML header. The options here are\n\n\nCode Chunk Options\n\n\nInline Code\n\n\nRendering\n\nDebugging Errors\nHeadings and code chunks Code chunk options Rendering $ subsetting and inline code Maybe another test? With real data to practice? Probably chi-squared, it’s short lol Reading in datasets"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#footnotes",
    "href": "tutorials/01_fundRmentals/03_lm.html#footnotes",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSomewhat confusingly, this is not the function we teach UGs to perform ANOVAs! See discovr tutorials 11, 12, 15, and 16 for a detailed guide through the afex package for running linear models with categorical predictors.↩︎\nMostly true, except for inline code!↩︎\nGenerally, inline code should only ever produce a single value, otherwise the formatting can get interesting. This value, however, could longer than a single number, if you want to get creative with your dynamic reporting!↩︎\n↩︎\nIt seems obvious that this should be R instead of K, but remember this made perfect sense when it was called “knitting”!↩︎\nFor writing tutorials, I make extensive use of eval: false, which includes the code in the output but does not attempt to run the code. This allows me to write all kinds of nonsense code without R getting stroppy and throwing errors all of the place!↩︎\nDepends crucially on what you consider to be “easy”, especially when dealing with PDFs!↩︎"
  },
  {
    "objectID": "docs/other/03_report.html",
    "href": "docs/other/03_report.html",
    "title": "Linear Model Report",
    "section": "",
    "text": "Two linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (\\(R^2 = .04\\), \\(F(1, 461) = 17.08\\), \\(p &lt; .001\\)). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (\\(R^2 = .07\\), \\(F(2, 460) = 16.33\\), \\(p &lt; .001\\)).\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(1, 460) = 15.06, p &lt; .001)."
  },
  {
    "objectID": "docs/other/03_report.html#model-comparison",
    "href": "docs/other/03_report.html#model-comparison",
    "title": "Linear Model Report",
    "section": "",
    "text": "Two linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (\\(R^2 = .04\\), \\(F(1, 461) = 17.08\\), \\(p &lt; .001\\)). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (\\(R^2 = .07\\), \\(F(2, 460) = 16.33\\), \\(p &lt; .001\\)).\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(1, 460) = 15.06, p &lt; .001)."
  },
  {
    "objectID": "docs/other/03_report.html#assumptions-checks",
    "href": "docs/other/03_report.html#assumptions-checks",
    "title": "Linear Model Report",
    "section": "Assumptions Checks",
    "text": "Assumptions Checks\nWe next assessed the model with two predictors for any evidence of bias. Residual plots (Figure 1) did not indicate any outstanding issues with normality, linearity, or heteroscedasticity. There was also no evidence of influential cases, as the max value of Cook’s distance was 0.03.\nRobust models were also fitted as sensitivity checks. Robust parameter estimates estimated using the {robust} package were minimally different from the unadjusted parameter estimates. Similarly, robust HC4 standard errors estimated using the {parameters} package yielded confidence intervals and p-values very similar to the unadjusted values. Therefore, we will proceed with the unadjusted two-predictor model as our final model.\n\n\n\n\n\nFigure 1: Diagnostic plots for the two-predictor model"
  },
  {
    "objectID": "docs/other/03_report.html#the-final-model",
    "href": "docs/other/03_report.html#the-final-model",
    "title": "Linear Model Report",
    "section": "The Final Model",
    "text": "The Final Model\nThe final model with two predictors is presented in full in Table 1.\n\n\n\n\nTable 1: The final model predicting teaching evaluation ratings from instructor beauty and gender.\n\n\nPredictor\n\\(b\\)\n95% CI\n\\(t\\)\n\\(\\mathit{df}\\)\n\\(p\\)\n\n\n\n\nIntercept\n3.88\n[3.81, 3.96]\n100.47\n460\n&lt; .001\n\n\nBeauty\n0.15\n[0.09, 0.21]\n4.65\n460\n&lt; .001\n\n\nGendermale\n0.20\n[0.10, 0.30]\n3.88\n460\n&lt; .001"
  },
  {
    "objectID": "tutorials/01_fundRmentals/03_lm.html#well-done",
    "href": "tutorials/01_fundRmentals/03_lm.html#well-done",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Well done!",
    "text": "Well done!\nAnd there we have it! You now have a complete example of a linear model report, rendered into both HTML and Word, to refer to. It’s amazing how much you’re able to do after just a few weeks!\nThis is the end of the FundRmentals section of the course. If you’re so inclined, we’ll see you in the Essentials section, which will cover data wrangling and cleaning, and running and reporting many more statistical analyses."
  },
  {
    "objectID": "tutorials/index/fxs_index.html",
    "href": "tutorials/index/fxs_index.html",
    "title": "Index of Functions",
    "section": "",
    "text": "Looking for a function you can’t quite remember how to use? You’re in the right place! The table below is arranged alphabetically by function name, and the linked full name (including relevant package calls) will take you to the help documentation. 31b8e172-b470-440e-83d8-e6b185028602:dAB5AHAAZQA6AE8AQQBCAGwAQQBHAFkAQQBOAFEAQgBoAEEARABjAEEATgB3AEEAeQBBAEMAMABBAFoAQQBCAGsAQQBEAFkAQQBNAHcAQQB0AEEARABRAEEATgBnAEEAeQBBAEQASQBBAEwAUQBBADQAQQBEAFEAQQBZAGcAQgBtAEEAQwAwAEEAWQBRAEIAbQBBAEQARQBBAE8AUQBBADUAQQBEAFUAQQBZAFEAQQB4AEEARwBJAEEATQBnAEIAaQBBAEQAawBBAAoAcABvAHMAaQB0AGkAbwBuADoATQBnAEEANABBAEQAWQBBAAoAcAByAGUAZgBpAHgAOgAKAHMAbwB1AHIAYwBlADoAUABBAEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBJAEEAQgBqAEEARwB3AEEAWQBRAEIAegBBAEgATQBBAFAAUQBBAGkAQQBIAFEAQQBZAFEAQgBpAEEARwB3AEEAWgBRAEEAaQBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAdABBAEcARQBBAGMAZwBCAG4AQQBHAGsAQQBiAGcAQQB0AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AZwBBAGcAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEATwB3AEEAZwBBAEcAMABBAFkAUQBCAHkAQQBHAGMAQQBhAFEAQgB1AEEAQwAwAEEAYwBnAEIAcABBAEcAYwBBAGEAQQBCADAAQQBEAG8AQQBJAEEAQgBoAEEASABVAEEAZABBAEIAdgBBAEQAcwBBAEkAZwBBACsAQQBBAG8AQQBJAEEAQQA4AEEASABRAEEAYQBBAEIAbABBAEcARQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYQBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIARwBBAEgAVQBBAGIAZwBCAGoAQQBIAFEAQQBhAFEAQgB2AEEARwA0AEEASQBBAEIATwBBAEcARQBBAGIAUQBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYQBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBnAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAVABBAEIAcABBAEcANABBAGEAdwBBAGcAQQBIAFEAQQBiAHcAQQBnAEEARQBnAEEAWgBRAEIAcwBBAEgAQQBBAEkAQQBCAEUAQQBHADgAQQBZAHcAQgAxAEEARwAwAEEAWgBRAEIAdQBBAEgAUQBBAFkAUQBCADAAQQBHAGsAQQBiAHcAQgB1AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGEAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAZwBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFYAUQBCAHoAQQBHAFUAQQBaAEEAQQBnAEEARQBrAEEAYgBnAEEAdQBBAEMANABBAEwAZwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBnAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAGcAQQBaAFEAQgBoAEEARwBRAEEAUABnAEEASwBBAEQAdwBBAGQAQQBCAGkAQQBHADgAQQBaAEEAQgA1AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBZAHcAQgB5AEEARwA4AEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAEwAZwBCADAAQQBHAGsAQQBaAEEAQgA1AEEASABZAEEAWgBRAEIAeQBBAEgATQBBAFoAUQBBAHUAQQBHADgAQQBjAGcAQgBuAEEAQwA4AEEAYwBnAEIAbABBAEcAWQBBAFoAUQBCAHkAQQBHAFUAQQBiAGcAQgBqAEEARwBVAEEATAB3AEIAaABBAEcATQBBAGMAZwBCAHYAQQBIAE0AQQBjAHcAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAFEAQQBjAEEAQgBzAEEASABrAEEAYwBnAEEANgBBAEQAbwBBAFkAUQBCAGoAQQBIAEkAQQBiAHcAQgB6AEEASABNAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAYgBnAEIAdgBBAEgAWQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAegBBAEgAUQBBAFkAUQBCADAAQQBIAE0AQQBMAHcAQgBoAEEARwA0AEEAYgB3AEIAMgBBAEcARQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAaABBAEcANABBAGIAdwBCADIAQQBHAEUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEcARQBBAGMAQQBCAGgAQQBGADgAQQBjAEEAQgB5AEEARwBrAEEAYgBnAEIAMABBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgB5AEEARwBRAEEAYwBnAEIAeQBBAEMANABBAGEAUQBCAHYAQQBDADgAQQBjAEEAQgByAEEARwBjAEEATAB3AEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQB2AEEARwAwAEEAWQBRAEIAdQBBAEMAOABBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgB3AEEASABJAEEAYQBRAEIAdQBBAEgAUQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQA2AEEARABvAEEAWQBRAEIAdwBBAEcARQBBAFgAdwBCAHcAQQBIAEkAQQBhAFEAQgB1AEEASABRAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQATQBBAE8AZwBBAGcAQQBGAEkAQQBaAFEAQgB3AEEARwA4AEEAYwBnAEIAMABBAEcAawBBAGIAZwBCAG4AQQBDAEEAQQBUAEEAQgBwAEEARwA0AEEAWgBRAEIAaABBAEgASQBBAEkAQQBCAE4AQQBHADgAQQBaAEEAQgBsAEEARwB3AEEAYwB3AEEAZwBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBJAEEAQgBSAEEASABVAEEAWQBRAEIAeQBBAEgAUQBBAGIAdwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBjAEEAQgBoAEEARgA4AEEAZABBAEIAaABBAEcASQBBAGIAQQBCAGwAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBZAFEAQgB3AEEARwBFAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEANgBBAEQAbwBBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgAwAEEARwBFAEEAWQBnAEIAcwBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAFoAdwBCAG4AQQBIAEEAQQBiAEEAQgB2AEEASABRAEEATQBnAEEAdQBBAEgAUQBBAGEAUQBCAGsAQQBIAGsAQQBkAGcAQgBsAEEASABJAEEAYwB3AEIAbABBAEMANABBAGIAdwBCAHkAQQBHAGMAQQBMAHcAQgB5AEEARwBVAEEAWgBnAEIAbABBAEgASQBBAFoAUQBCAHUAQQBHAE0AQQBaAFEAQQB2AEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAGMAQQBaAHcAQgB3AEEARwB3AEEAYgB3AEIAMABBAEQASQBBAE8AZwBBADYAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEAYwBBAEIAcwBBAEcAOABBAGQAQQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWQB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAegBBAEQAbwBBAEkAQQBCAFMAQQBHAFUAQQBjAEEAQgB2AEEASABJAEEAZABBAEIAcABBAEcANABBAFoAdwBBAGcAQQBFAHcAQQBhAFEAQgB1AEEARwBVAEEAWQBRAEIAeQBBAEMAQQBBAFQAUQBCAHYAQQBHAFEAQQBaAFEAQgBzAEEASABNAEEASQBBAEIAMwBBAEcAawBBAGQAQQBCAG8AQQBDAEEAQQBVAFEAQgAxAEEARwBFAEEAYwBnAEIAMABBAEcAOABBAFAAQQBCAGkAQQBIAEkAQQBQAGcAQQB3AEEARABVAEEATwBnAEEAZwBBAEUAMABBAGQAUQBCADAAQQBHAEUAQQBkAEEAQgBsAEEAQwBBAEEAWQBRAEIAdQBBAEcAUQBBAEkAQQBCAFQAQQBIAFUAQQBiAFEAQgB0AEEARwBFAEEAYwBnAEIAcABBAEgATQBBAFoAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAEEAQgBoAEEASABNAEEAYwB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBCAHMAQQBHAEUAQQBjAHcAQgB6AEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBZAHcAQgBzAEEARwBFAEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAHcAQgB1AEEASABRAEEAWQBRAEIAcABBAEcANABBAGMAdwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAZABBAEIAcABBAEcAUQBBAGUAUQBCAHoAQQBHAFUAQQBiAEEAQgBsAEEARwBNAEEAZABBAEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgB5AEEASABRAEEAYwB3AEIAZgBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAGsAQQBIAEEAQQBiAEEAQgA1AEEASABJAEEATwBnAEEANgBBAEcATQBBAGIAdwBCAHUAQQBIAFEAQQBZAFEAQgBwAEEARwA0AEEAYwB3AEEAbwBBAEMAawBBAFAAQQBBAHYAQQBHAEUAQQBQAGcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAQQBBAE4AUQBBADYAQQBDAEEAQQBUAFEAQgAxAEEASABRAEEAWQBRAEIAMABBAEcAVQBBAEkAQQBCAGgAQQBHADQAQQBaAEEAQQBnAEEARgBNAEEAZABRAEIAdABBAEcAMABBAFkAUQBCAHkAQQBHAGsAQQBjAHcAQgBsAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAMQBBAEgAUQBBAGEAUQBCAHMAQQBIAE0AQQBMAHcAQgBrAEEARwBFAEEAZABBAEIAaABBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgB3AEIAcwBBAEcARQBBAGIAZwBCAGoAQQBHAFUAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAYwBBAFoAUQBCAHUAQQBHAFUAQQBjAGcAQgBwAEEARwBNAEEAYwB3AEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAG4AQQBHAHcAQQBZAFEAQgB1AEEARwBNAEEAWgBRAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwBJAEEAYwBnAEIAdgBBAEcAOABBAGIAUQBBADYAQQBEAG8AQQBaAHcAQgBzAEEARwBFAEEAYgBnAEIAagBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEgASQBBAFoAQQBCAHkAQQBIAEkAQQBMAGcAQgBwAEEARwA4AEEATAB3AEIAeQBBAEMAOABBAFkAZwBCAGgAQQBIAE0AQQBaAFEAQQB2AEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHMAQQBHAGsAQQBZAGcAQgB5AEEARwBFAEEAYwBnAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBQAEEAQgBpAEEASABJAEEAUABnAEEAdwBBAEQAUQBBAE8AZwBBAGcAQQBFAFkAQQBhAFEAQgBzAEEASABRAEEAWgBRAEIAeQBBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBADgAQQBHAEkAQQBjAGcAQQArAEEARABBAEEATgBRAEEANgBBAEMAQQBBAFQAUQBCADEAQQBIAFEAQQBZAFEAQgAwAEEARwBVAEEASQBBAEIAaABBAEcANABBAFoAQQBBAGcAQQBGAE0AQQBkAFEAQgB0AEEARwAwAEEAWQBRAEIAeQBBAEcAawBBAGMAdwBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBiAEEAQgB0AEEAQwBnAEEASwBRAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAHcAQQBZAFEAQQBnAEEARwBnAEEAYwBnAEIAbABBAEcAWQBBAFAAUQBBAGkAQQBHAGcAQQBkAEEAQgAwAEEASABBAEEAYwB3AEEANgBBAEMAOABBAEwAdwBCAHkAQQBHAFEAQQBjAGcAQgB5AEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAZwBBAHYAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdgBBAEcAdwBBAGIAUQBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcAdwBBAGIAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBBAEIAdABBAEYASQBBAGIAdwBCAGkAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHkAQQBHADgAQQBZAGcAQgAxAEEASABNAEEAZABBAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBiAEEAQgB0AEEARgBJAEEAYgB3AEIAaQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEcASQBBAGQAUQBCAHoAQQBIAFEAQQBPAGcAQQA2AEEARwB3AEEAYgBRAEIAUwBBAEcAOABBAFkAZwBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBRAEIAbABBAEcARQBBAGIAZwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBiAFEAQgBsAEEARwBFAEEAYgBnAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwAwAEEAWgBRAEIAaABBAEcANABBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB0AEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAFgAdwBCAHcAQQBHAEUAQQBjAGcAQgBoAEEARwAwAEEAWgBRAEIAMABBAEcAVQBBAGMAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAbABBAEcARQBBAGMAdwBCADUAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdQBBAEcAYwBBAGEAUQBCADAAQQBHAGcAQQBkAFEAQgBpAEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEYAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAE8AZwBBADYAQQBHADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAZgBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwA0AEEAYQBRAEIAagBBAEcAVQBBAFgAdwBCADAAQQBHAEUAQQBZAGcAQgBzAEEARwBVAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAEwAZwBCAHkAQQBHAFUAQQBiAFEAQgBwAEEAQwAwAEEAZABBAEIAbwBBAEcAVQBBAGMAZwBCAHAAQQBHAEUAQQBkAFEAQgBzAEEASABRAEEATABnAEIAagBBAEcAOABBAGIAUQBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAGcAQgBwAEEARwBNAEEAWgBRAEIAZgBBAEgAUQBBAFkAUQBCAGkAQQBHAHcAQQBaAFEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAE8AZwBBADYAQQBHADQAQQBhAFEAQgBqAEEARwBVAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEgAQQBBAGEAUQBCAGoAQQBHAHMAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAUQBBAGMAQQBCAHMAQQBIAGsAQQBjAGcAQQB1AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGQAZwBCAGwAQQBIAEkAQQBjAHcAQgBsAEEAQwA0AEEAYgB3AEIAeQBBAEcAYwBBAEwAdwBCAHkAQQBHAFUAQQBaAGcAQgBsAEEASABJAEEAWgBRAEIAdQBBAEcATQBBAFoAUQBBAHYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEASABJAEEAYgB3AEIAMQBBAEcANABBAFoAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBVAGcAQgB2AEEASABVAEEAYgBnAEIAawBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEgAVQBBAGIAZwBCAGsAQQBDAGcAQQBLAFEAQQA4AEEAQwA4AEEAWQBRAEEAKwBBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBNAEEAQQB4AEEARABvAEEASQBBAEIASgBBAEcANABBAGQAQQBCAFMAQQBHADgAQQBaAEEAQgAxAEEARwBNAEEAZABBAEIAcABBAEcAOABBAGIAZwBCAHoAQQBDAEEAQQBTAFEAQQA4AEEARwBJAEEAYwBnAEEAKwBBAEQAQQBBAE0AdwBBADYAQQBDAEEAQQBVAGcAQgBsAEEASABBAEEAYgB3AEIAeQBBAEgAUQBBAGEAUQBCAHUAQQBHAGMAQQBJAEEAQgBNAEEARwBrAEEAYgBnAEIAbABBAEcARQBBAGMAZwBBAGcAQQBFADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAegBBAEMAQQBBAGQAdwBCAHAAQQBIAFEAQQBhAEEAQQBnAEEARgBFAEEAZABRAEIAaABBAEgASQBBAGQAQQBCAHYAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBjAGcAQgB2AEEASABjAEEAVABRAEIAbABBAEcARQBBAGIAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBnAEEAdgBBAEcASQBBAFkAUQBCAHoAQQBHAFUAQQBMAHcAQgBqAEEARwA4AEEAYgBBAEIAVABBAEgAVQBBAGIAUQBCAHoAQQBDADQAQQBhAEEAQgAwAEEARwAwAEEAYgBBAEEAaQBBAEQANABBAGMAZwBCAHYAQQBIAGMAQQBUAFEAQgBsAEEARwBFAEEAYgBnAEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAegBBAEcAUQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABJAEEAWgBBAEIAeQBBAEgASQBBAEwAZwBCAHAAQQBHADgAQQBMAHcAQgB5AEEAQwA4AEEAYwB3AEIAMABBAEcARQBBAGQAQQBCAHoAQQBDADgAQQBjAHcAQgBrAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBjAHcAQgBrAEEAQwBnAEEASwBRAEEAOABBAEMAOABBAFkAUQBBACsAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB6AEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAWgBBAEIAdwBBAEcAdwBBAGUAUQBCAHkAQQBDADQAQQBkAEEAQgBwAEEARwBRAEEAZQBRAEIAMgBBAEcAVQBBAGMAZwBCAHoAQQBHAFUAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAE0AQQBaAFEAQgBzAEEARwBVAEEAWQB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAGMAZwBCAGsAQQBIAEkAQQBjAGcAQQB1AEEARwBrAEEAYgB3AEEAdgBBAEgASQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgAwAEEASABNAEEATAB3AEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAFEAQQBMAGcAQgAwAEEARwBVAEEAYwB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBIAFEAQQBhAFEAQgBrAEEASABrAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBHAGMAQQBaAFEAQgB1AEEARwBVAEEAYwBnAEIAcABBAEcATQBBAGMAdwBBAHUAQQBIAEkAQQBMAFEAQgBzAEEARwBrAEEAWQBnAEEAdQBBAEcAOABBAGMAZwBCAG4AQQBDADgAQQBjAGcAQgBsAEEARwBZAEEAWgBRAEIAeQBBAEcAVQBBAGIAZwBCAGoAQQBHAFUAQQBMAHcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWQBnAEIAeQBBAEcAOABBAGIAdwBCAHQAQQBEAG8AQQBPAGcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgAzAEEARwBnAEEAWgBRAEIAeQBBAEcAVQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAeQBBAEMAMABBAGIAQQBCAHAAQQBHAEkAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGQAdwBCAG8AQQBHAFUAQQBjAGcAQgBsAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBaAEEAQgB3AEEARwB3AEEAZQBRAEIAeQBBAEQAbwBBAE8AZwBCADMAQQBHAGcAQQBaAFEAQgB5AEEARwBVAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBpAEEARwA4AEEAWgBBAEIANQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBoAEEARwBJAEEAYgBBAEIAbABBAEQANABBAAoAcwB1AGYAZgBpAHgAOgA=:31b8e172-b470-440e-83d8-e6b185028602"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "This tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset.\n\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html#overview",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html#overview",
    "title": "05: Mutate and Summarise",
    "section": "",
    "text": "This tutorial covers two essential dplyr functions: mutate() and summarise(). Very similar in structure, the two functions primarily differ in output. mutate() makes changes within a given dataset, whereas summarise() uses the information in a given dataset to create a new, separate summary dataset.\n\n\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html#mutate",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html#mutate",
    "title": "05: Mutate and Summarise",
    "section": "Mutate",
    "text": "Mutate\nThe mutate() function is one of the most essential functions from the dplyr package. Its primary job is to easily and transparently make changes within a dataset - in particular, a tibble.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::mutate(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\nUsage\nvariable_name is the name of the variable that will be changed by mutate(). This can be any name that follow’s R’s object naming rules. There are two main options for this name:\n\nIf the dataset does not already contain a variable called variable_name, a new variable will be added to the dataset.\nIf the dataset does already contain a variable called variable_name, the new variable will silently1 replace (i.e. overwrite) the existing variable with the same name.\n\ninstructions_for_creating_the_variable tells the function how to create variable_name. These instructions can be any valid R code, from a single value or constant, to complicated calculations or combinations of other variables. You can think of these instructions exactly the same way as the vector calculations we covered earlier, and they must return a series of values that is the same length as the existing dataset.\n\n\nExample\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    group = \"control\",\n    score = \n  )\n\n\n1\n\nTake the dataset\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAlthough creating or modifying variables will likely be the most frequent way you use mutate(), it has other handy features such as:\n\nDeleting variables\nDeciding where newly created variables appear in the dataset\nDeciding which variables appear in the output, depending on which you’ve used\n\nSee the help documentation for more by running help(mutate) or ?mutate in the Console.\n\n\n\n\n\nComposite Scores\n\nRow-wise magic is good magic. -Hadley Wickham\n\nA very common mutate() task is to create a composite score from multiple variables - for example, an overall anxiety score from a questionnaire with ten items on anxiety. Imagine we wanted to create an overall score that is the mean of the ratings on each of those ten items, for each participant.\nTo do this, we need two new functions.\n\nThe first new function, dplyr::c_across(), provides an efficient way to select multiple variables to contribute to the calculation - namely, by using &lt;tidyselect&gt; semantics.\nThe second new function is actually a pair of functions, dplyr::rowwise() and dplyr::ungroup(). These two respectively impose and remove an internal structure to the dataset, such that each row is treated like its own group, and any operations are done within those row-wise groups.\n\nLet’s see the combination of these two in action.\n\n\n\n\n\n\nImportant\n\n\n\nThe code below assumes a dataset structured so there is information from each participant on only and exactly one row in the dataset, i.e “wide” format.\nIf your data is tidy with observations from the same participants on multiple rows, you will need to reshape your data or otherwise adapt the code to suit your data structure.\n\n\n\n1my_tibble |&gt;\n2  dplyr::rowwise() |&gt;\n3  dplyr::mutate(\n    anxiety_score = mean(c_across(starts_with(\"anxiety\")),\n                        na.rm = TRUE)\n  ) |&gt;\n4  dplyr::ungroup()\n\n\n1\n\nTake the dataset, and then -\n\n2\n\nGroup the dataset by row. This means that any subsequent calculations will be done for each row separately.\n\n3\n\nCreate the new anxiety_mean variable. The new function c_across() works quite similar to c() - namely, creating a vector of variables for mean() to take the mean of. However, it has the advantage of allowing &lt;tidyselect&gt; for choosing the variables, instead of having to type them out one by one.\n\n4\n\nRemove the by-row grouping that was created by rowwise(). Otherwise, all other subsequent operations on this dataset will continue to be performed within each row. (This isn’t typically the desired behaviour for this task, but it can be quite useful in other scenarios!)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor lots more details and examples on rowwise() and rowwise operations with dplyr - including which other scenarios in which a row-wise dataset would be useful - run vignette(\"rowwise\") in the Console.\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWhat would the above code produce without the rowwise()...ungroup() steps (i.e. with only the mutate() command)? Make a prediction, then try it.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe can see what happens without rowwise()...ungroup() just by commenting them out of the pipe. To do this, either type # before each line, or highlight them and press CTRL/CMD + SHIFT + C.\n\nmy_tibble |&gt; \n  # dplyr::rowwise() |&gt; \n  dplyr::mutate(\n    anxiety_score = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) # |&gt; don't forget to comment out this pipe or you'll get an error\n  # dplyr::ungroup()\n\nThis code still runs successfully, but the result isn’t what we wanted. Have a look at the anxiety_mean variable: all the values are the same. Instead of calculating the mean for each person, this code instead calculated the overall mean of all of the anxiety variables, and then assigned that single value to the anxiety_mean variable. Not what we wanted in this case - but it could be useful in other scenarios!\n\n\n\nThe above code is definitely not the only way to obtain the same output. Try producing the the same anxiety_mean variable with the following methods. What are the benefits and drawbacks of each methods? Hint: Use vignette(\"rowwise\") to help if you get stuck.\n\nUsing a dedicated by-row function, rowMeans()\nUsing the basic structure of mutate() only\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf we wanted to avoid, or didn’t remember, the rowwise()...ungroup() sequence, there are other options to produce the same result, but neither are easier to read or implement.\n1. Using rowMeans\nThe base function rowMeans() calculates the mean of each row without any additional jiggery pokery to worry about. The problem is specifying which variables to include, especially because we have ten in this example to work with.\nHowever, rowMeans() is an independent function who doesn’t need no dplyr, and as such does not work the same way, for instance, mean() does, with no straightforward workaround.\n\n## Reasonable but just doesn't work!\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(c(anxiety_1, anxiety_2, anxiety_3..., anxiety_10))\n  )\n\nError in dplyr::mutate(my_tibble, anxiety_score = rowMeans(c(anxiety_1, : object 'my_tibble' not found\n\n\nThis is because rowMeans() is expecting a whole dataset, not just a subset of columns. You can solve this by select()ing within the rowMeans() function:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(dplyr::select(my_tibble, anxiety_1, anxiety_2...))\n  )\n\n…which has the major issue that if you update the name of your dataset, you must update it in TWO places - at the start of the pipe and inside rowMeans(), along with just being a huge mess.\nAlternatively, you can use dplyr::pick() with &lt;tidyselect&gt; semantics to make this less, well, terrible:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = rowMeans(pick(contains(\"anxiety\")))\n  )\n\n…which didn’t seem fair because we haven’t talked about pick(), and also defeated the purpose of using rowMeans() to avoid having to learn new dplyr functions. So, dplyr wins this one either way.\nIf you’re keen to never have to learn a jot more dplyr than absolutely necessary (I bet you are not having a good time so far!), this Stack Overflow post offers some other, non-dplyr solutions…that also depend on using the magrittr pipe %&gt;%! Sorry.\n2. Use basic mutate()\nThe most straightforward method - although perhaps not the most obvious - is to express the calculation you want as arithmetic using the relevant variables. In this instance, to calculate a mean, we sum the scores together and then divide by the number of scores:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    anxiety_score = (anxiety_1 + anxiety_2 + ... + anxiety_10)/10\n  )\n\nThis method, although very transparent, has some critical downsides.\n\nIt’s clunky and prone to error. This style works best for 2-3 variables contributing to the composite. For more variables, we end up with a lot of repetitive typing, which also means increased likelihood of typos, accidental omissions, or other errors - especially with a large number of variables, as we have here.\nIt’s not robust. Imagine that, on review of the anxiety scale, we find that anxiety_9 is a badly worded/unreliable item and decide to drop it from our analysis. We then either have to (remember to) manually update our code both to remove anxiety_9 and to change the denominator from 10 to 9 (not a good time), or debug the resulting error if we don’t remember.\n\nWe do teach this method to UGs specifically to reduce the number of functions they have to learn, but for real-life usage, in most cases, the rowwise() solution is likely preferable.\n\n\n\n\n\n\n\nConditionals\nThere are many functions out there for recoding variables, but the following method, using dplyr::case_when(), is recommended because it is so versatile. It can be used to recode the values from one variable into new one, but it can also combine information across variables and handle multiple conditionals. It essentially allows a series of if-else statements without having to actually have lots of if-else statements.\nThe generic format of case_when() can be stated as follows:\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    new_variable = dplyr::case_when(\n      logical_assertion ~ value,\n      logical_assertion ~ value,\n      .default = value_to_use_for_cases_with_no_matches\n    )\n  )\n\n\nUsage\nlogical_assertion is any R code that returns TRUE and FALSE values.\nvalue is the value to assign to new_value for the cases for which logical_assertion returns TRUE.\nThe assertions are evaluated sequentially (from first to last in the order they are written in the function), and the first match determines the value. This means that the assertions must be ordered from most specific to least specific.\n\n\n\n\n\n\nTesting Assertions\n\n\n\n\n\nThe assertions for case_when() are the same as the ones we used previously in filter(). In fact, if you need to test the assertion you are writing to ensure that your code will work as you want, you can try the same assertion in filter() to check whether the cases it returns are only and exactly the once you want to change.\n\n\n\nLet’s look at two examples of how dplyr::case_when() might come in handy.\n\nOne-Variable Input\nWe’ve created our composite anxiety_mean variable previously, and now we may want to change this continuous score into a categorical variable indicating whether or not participants display clinical levels of anxiety. So, we can use case_when() to recode anxiety_mean into a new anxiety_cat variable.\n\n1anxiety_cutoff &lt;- 35\n\n2my_tibble |&gt;\n3  dplyr::mutate(\n4    anxiety_cat = dplyr::case_when(\n5      anxiety_score &gt;= anxiety_cutoff ~ \"anx\",\n6      anxiety_score &lt; anxiety_cutoff ~ \"control\",\n7      .default = NA\n    )\n  )\n\n\n1\n\nCreate a new object, anxiety_cutoff, containing the threshold value for separating clinical from non-clinical anxiety. This one is from REFERENCE.\n\n2\n\nTake the dataset, and then…\n\n3\n\nMake a change to it by…\n\n4\n\nCreating a new variable, anxiety_cat, by applying the following rules:\n\n5\n\nFor cases where the value of anxiety_mean is greater than or equal to anxiety_cutoff, assign the value “anx” to anxiety_cat\n\n6\n\nFor cases where the value of anxiety_mean is less than anxiety_cutoff, assign the value “control” to anxiety_cat\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign NA to anxiety_cat\n\n\n\n\n\n\n\n\n\n\nWhy the new anxiety_cutoff object?\n\n\n\n\n\nIn the code above, the cutoff value is stored in a new object, anxiety_cutoff, which is then used in the subsequent case_when() conditions. Why take this extra step?\nThis is a matter of style, since the output of this code would be entirely identical if I wrote the cutoff value into the case_when() assertions directly (e.g. anxiety_mean &gt;= 35). I have done it this way for a few reasons:\n\nThe threshold value is easy to find, in case I need to remind myself which one I used, and it’s clearly named, so I know what it represents.\nMost importantly, it’s easy to change, in case I need to update it later. I would only have to change the value in the object once, at the beginning of the code chunk, and all of the subsequent code using that object would be similarly updated.\n\nIn short, it makes the code easier to navigate, more resilient to later updates, and more transparent in its meaning.\n\n\n\n\n\nMulti-Variable Input\nWe might also like to create a useful coding variable to help keep track of the number of cases we’ve removed, and for what reasons. We can draw on input from multiple variables to create this single new variable.\n\n1my_tibble |&gt;\n  dplyr::mutate(\n    remove = dplyr::case_when(\n2      distribution == \"Preview\" ~ \"preview\",\n3      info_consent != \"Yes\" ~ \"no_consent\",\n4      age &lt; 18 ~ \"age_young\",\n5      is.na(age) | age &gt; 100 ~ \"age_bad\",\n6      !grepl(\"eng\", tolower(fluent_lang)) ~ \"english_no\",\n7      .default = \"keep\"\n    )\n  )\n\n\n1\n\nTake the dataset my_tibble and make a change to it by a creating a new variable, remove, by applying the following rules\n\n2\n\nFor cases where the distribution variable contains exactly and only “Preview”, assign the value \"preview\". This is a common task for Qualtrics surveys to remove practice runs.\n\n3\n\nFor cases where the info_consent variable does NOT contain exactly and only the value “Yes”, assign the value \"no_consent\". This includes anyone who did not actively consent - both people who chose options OTHER than “Yes” (e.g. “No”), and people who did not respond.\n\n4\n\nFor cases where the numerical value in age is less than 18, assign the value \"age_young\".\n\n5\n\nFor cases where the value is age is NA, or is greater than 100, assign the value \"age_bad\".\n\n6\n\nFor cases where the value in fluent_lang, once converted to lowercase, does NOT contain the letters “engl”, assign the value \"english_no\". This searches open text responses to a question like “What languages do you speak fluently?” for the string “engl”.\n\n7\n\nFor cases that don’t match any of the preceding criteria, assign the value \"keep\".\n\n\n\n\nBecause the first match for each case is the value it is assigned, each case will receive only one value, even if they match multiple criteria. For example, if you had a participant who gave their age as 17 and their fluent languages as Finnish and German, they would be coded as age_young rather than english_no because the assertion about age comes before the assertion about language. (This is sensible behaviour, because being 18 or older is an ethical requirement, whereas speaking English fluently likely isn’t.)\nFrom here, you can easily use this variable to summarise exclusions, and to filter out excluded cases for your final dataset.\n\n1my_tibble |&gt;\n  dplyr::count(remove)\n\n2final_tibble &lt;- my_tibble |&gt;\n  dplyr::filter(remove == \"keep\")\n\n\n1\n\nTake my_tibble and count the number of times each unique value occurs in the remove variable.\n\n2\n\nCreate a new object, final_tibble, by taking my_tibble and then retaining only the cases for which the remove variable has only and exactly the value \"keep\" - effectively dropping all other cases.\n\n\n\n\n\n\n\n\n\n\nRecoding Factors\n\n\n\n\n\nWhat about recoding or relabeling factors? For example, imagine a dataset where gender has been collected as 1, 2, and 3, with 1 corresponding to “Female”, 2 to “Male”, and 3 to “Nonbinary/third gender”. You\n\n\n\n\n\n\n\nIteration\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\n\nmy_tibble |&gt; \n  dplyr::mutate(\n    dplyr::across(&lt;tidyselect&gt;, function_to_apply)\n  )"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html#summarise",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html#summarise",
    "title": "05: Mutate and Summarise",
    "section": "Summarise",
    "text": "Summarise\nThe summarise() function looks almost exactly like mutate, with almost identical syntax. However, its primary job is to quickly generate summary tables from datasets.\n\nBasic Structure\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n\n\n\n\n\n\n\nImportant\n\n\n\nYou may notice that the basic structure of summarise looks identical to the basic structure of mutate, above. The difference is that mutate creates or replaces variables within the same dataset, while summarise creates a new summary dataset without changing the original.\n\n\n\nUsage\nvariable_name is the name of a variable that will created in the new summary tibble. This can be any name that follow’s R’s object naming rules.\ninstructions_for_creating_the_variable tells the function how to create variable_name. The instrutions can refer to variables in the piped-in dataset, but should output a single value, rather than a vector of values (as we saw in mutate()).\n\n\nExample\n\nmy_tibble |&gt; \n  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\n\n\n\nBy Group\nBasic summary tables are fine, but the real power of summarise() is in combination with the helper function dplyr::group_by() to split up the summary calculations by the values of a grouping variable.\nSimilar to what we saw with rowwise(), group_by() creates internal structure in the dataset - a new group for each unique value in the grouping variable. Any subsequent calculations done with the dataset are done within those groups.\n\nExample\n\n1my_tibble |&gt;\n  dplyr::group_by(anxiety_cat) |&gt;\n2  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\nmy_tibble |&gt;\n3  dplyr::group_by(anxiety_cat, gender) |&gt;\n  dplyr::summarise(\n    mean_anx = mean(anxiety_mean, na.rm = TRUE),\n    sd_anx = sd(anxiety_mean, na.rm = TRUE)\n  )\n\n\n1\n\nTake the dataset, and then group by the values in the anxiety_cat variable that we created earlier.\n\n2\n\nProduce a summary table of the mean and SD of the anxiety_mean variable. Compare this to the ungrouped summary in the previous section - it’s the same columns, but a new row for each group.\n\n3\n\nGroup by multiple grouping variables, separated by a comma.\n\n\n\n\n\n\n\n\n\n\nReshaping Summary Tables\n\n\n\n\n\nThe second summary table, grouped by both anxiety diagnosis and gender, would likely be easier to read with one variable on separate rows and the other in separate columns. To learn how to reshape a summary table, see Tutorial 10.\n\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIteration\n\n\n\n\n\n\nWarning\n\n\n\nThis material isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\nDespite the versatility of summarise(), you may have already noticed that the code covered so far is very typing-intensive if you want information about more than one variable. This is neither efficient nor particularly enjoyable:\n\n## Down with this sort of thing!\nmy_tibble |&gt;\n  dplyr::group_by(anxiety_cat) |&gt; \n  dplyr::summarise(\n    mean_anx = mean(anxiety_score, na.rm = TRUE),\n    sd_anx = sd(anxiety_score, na.rm = TRUE),\n    mean_autism = mean(autism_score, na.rm = TRUE),\n    sd_autism = sd(autism_score, na.rm = TRUE),\n    mean_ext = mean(extroversion_score, na.rm = TRUE),\n    sd_ext = sd(extroversion_score, na.rm = TRUE)\n  )\n\nIf we wanted to also include, for instance, range and CIs, this code would quickly become unmanageably long and difficult to read, not to mention increasingly prone to errors.\nThere are two main solutions to this issue, and which you choose depends on what you want the output to contain and how much work you want to put into reading the help documentation of various functions.\n\nOption 1: Use an Existing Function\n\n\n\n\n\n\nChoose this option if:\n\n\n\n\nYou just want the basic descriptives and don’t need grouped summaries\nYou don’t mind reading up in the help documentation to get the right combination of arguments, and/or trying out a few different functions/packages to find the one that works for you.\n\n\n\nAs we saw in Tutorial 03: Datasets, there are existing functions that output pre-made summaries across multiple variables. If you revisit datawizard::describe_distribution(), you will find in the help documentation that it can utilise &lt;tidyselect&gt; syntax to select the variables you want, and the output can even be forced into a tibble for further wrangling.\n\n\nOption 2: Function List + across()\n\n\n\n\n\n\nChoose this option if:\n\n\n\n\nYou want custom or complex summary information and/or you want grouped summaries\nLike me, you just want to do everything yourself so you know it’s exactly right.\n\n\n\nThe big, inefficient multi-variable summarise() command above has two main issues to resolve.\n\nWe had to type the same functions over and over (i.e. mean() and sd() are repeated for each variable). Instead, we’ll create a list of functions to use, so we only have to type out each function once.\nWe had to manually type in each variable name we want to use. Instead, we’re going to utilise dplyr::across() to apply the list of functions from the first step to variables selected with &lt;tidyselect&gt;.\n\n\n\n\n\n\n\nTip\n\n\n\nFor more explanation about dplyr::across(), see the section on iteration with mutate() earlier on. For a much more in-depth explanation, run vignette(\"colwise\") in the Console.\n\n\n\n\nExample\n\n1fxs &lt;- list(\n2  mean = ~ mean(.x, na.rm = TRUE),\n  sd = ~ sd(.x, na.rm = TRUE)\n)\n\npeng |&gt; \n  dplyr::group_by(island) |&gt; \n  dplyr::summarise(\n3    across(where(is.numeric), fxs)\n  )\n\n\n1\n\nTo begin, create a new object containing a list. I’ve called mine fxs, short for “functions”, but you can of course call it anything you like.\n\n2\n\nThe elements inside the list have a special format. The first bit, e.g. mean =, gives each element a name. This name will be appended to the relevant column in the summarise() output, so choose something informative. The second bit, e.g. ~ mean(.x, na.rm = TRUE), is the function we want to apply to each variable. The two things to note are the ~, which denotes “this is a function to apply”, and .x, which is a placeholder for each of the variables that the function will be applied to.\n\n3\n\nInstead of using the familiar name = instructions format, we’re instead using across(). Generally, across() has two arguments. The first selects which variables to use using &lt;tidyselect&gt;; in this case, I’ve selected all of the numeric-type variables in the dataset (since it will be difficult to calculate the mean and SD otherwise!). The second provides a list of function(s) to apply to all of the selected variables. So, I’ve put in the list I made in the previous steps that contains all the functions I want to use.\n\n\n\n\n# A tibble: 3 × 11\n  island    bill_length_mm_mean bill_length_mm_sd bill_depth_mm_mean\n  &lt;fct&gt;                   &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt;\n1 Biscoe                   45.3              4.77               15.9\n2 Dream                    44.2              5.95               18.3\n3 Torgersen                39.0              3.03               18.4\n# ℹ 7 more variables: bill_depth_mm_sd &lt;dbl&gt;, flipper_length_mm_mean &lt;dbl&gt;,\n#   flipper_length_mm_sd &lt;dbl&gt;, body_mass_g_mean &lt;dbl&gt;, body_mass_g_sd &lt;dbl&gt;,\n#   year_mean &lt;dbl&gt;, year_sd &lt;dbl&gt;\n\n\nThis function list + across() method is extremely versatile. If you are using a lesser-known statistical technique, or even functions of your own making, you can easily add them to your list of functions and apply them with across()."
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html#next-steps",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html#next-steps",
    "title": "05: Mutate and Summarise",
    "section": "Next Steps",
    "text": "Next Steps\nThe next tutorial applies everything we’ve covered so far to the creation of beautiful and professional data visualisations.\n\n\n\n\n\n\nFor more on…\n\n\n\n\nReshaping summaries into nicely formatted, publication-worth tables, see Tutorial 10: Reshaping and Merging\nUsing &lt;tidyselect&gt;, see Tutorial 04: Filter and Select\nRow-wise and column-wise operations, run vignette(\"rowwise\") and vignette(\"colwise\") respectively in the Console.\n\n\n\n\n# eval: false\n\npeng &lt;- palmerpenguins::penguins\n\npeng |&gt;\n  dplyr:: select(contains(\"bill\")) |&gt;\n  dplyr::mutate(\n    bill_mm_mean = mean(c(bill_length_mm, bill_depth_mm), na.rm = TRUE)\n  )\n\n# A tibble: 344 × 3\n   bill_length_mm bill_depth_mm bill_mm_mean\n            &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1           39.1          18.7         30.5\n 2           39.5          17.4         30.5\n 3           40.3          18           30.5\n 4           NA            NA           30.5\n 5           36.7          19.3         30.5\n 6           39.3          20.6         30.5\n 7           38.9          17.8         30.5\n 8           39.2          19.6         30.5\n 9           34.1          18.1         30.5\n10           42            20.2         30.5\n# ℹ 334 more rows\n\npeng |&gt;\n  dplyr::rowwise() |&gt;\n  dplyr::mutate(\n    bill_mm_mean = mean(pick(contains(\"bill\")), na.rm = TRUE)\n  )\n\n# A tibble: 344 × 9\n# Rowwise: \n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, bill_mm_mean &lt;dbl&gt;\n\npeng |&gt;\n  dplyr::mutate(\n    bill_mm_mean = rowMeans(dplyr::select(peng, bill_length_mm, bill_depth_mm))\n  )\n\n# A tibble: 344 × 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, bill_mm_mean &lt;dbl&gt;\n\n# peng |&gt;\n#   dplyr::mutate(\n#     bill_mm_mean = mean(c_across(contains(\"bill\")), )\n#   )"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/05_changes.html#footnotes",
    "href": "tutorials/psychrlogy/02_essentials/05_changes.html#footnotes",
    "title": "05: Mutate and Summarise",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere, “silently” means that R overwrites the existing variable without flagging that it is doing this or asking you if you are sure, so it’s important to be aware of this behaviour (and to know what variables already exist in your dataset).↩︎"
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html",
    "title": "01: IntRoductions I",
    "section": "",
    "text": "The Console is deceptively simple: just the &gt; symbol with a flashing cursor after it, waiting for you to type something. However, the Console is the heart of R, where anything you want to do actually happens. Every command that you type, anything you want R to do, goes through here.\nSo - let’s get cracking."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#making-mistakes",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#making-mistakes",
    "title": "01: IntRoductions I",
    "section": "Making Mistakes",
    "text": "Making Mistakes\nBefore we go any further, an affirmation: you will, inevitably, make typos and errors using R. You will write commands that make sense to you that R doesn’t understand; and you will write commands that don’t make sense to you, that R does understand. You will make lots of mistakes, so let’s start there: with errors.\n\n\n\n\n\n\nExercises\n\n\n\nType literally any gibberish, words, keysmashes etc. into the code chunk on the worksheet and press Run (or Ctrl/Cmd + Shift + Enter).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Keysmash!\naslavb;lj aew aljvb\n\nError: &lt;text&gt;:2:11: unexpected symbol\n1: ## Keysmash!\n2: aslavb;lj aew\n             ^\n\n\n\n## Words!\nAm I a coward? Who calls me villain?\n\nError: &lt;text&gt;:2:4: unexpected symbol\n1: ## Words!\n2: Am I\n      ^\n\n\n\n## Emojis! \n¯\\_(ツ)_/¯\n\nError: &lt;text&gt;:2:1: unexpected input\n1: ## Emojis! \n2: ¯\n   ^\n\n\n\n\n\n\n\nWell, that went about as well as expected.\nIf you haven’t tried this yet, and your code chunk is just ominously staring at you, I’m serious - smash your head into the keyboard if you have to, or let your cat walk on it, or play it as if it were a piano, and press Enter. There’s two important things to learn from this:\n\nTo ask R to do something, you must write them out somewhere (in a code chunk, in the Console) and then run them.\nEventually, inevitably, something that you type WILL produce an error.\n\nFrom our keysmashing above, you will have seen that aslavb;lj aew aljvb, Am I a coward? Who calls me villain?, and ¯\\_(ツ)_/¯ are not valid commands in R. In other words, although each of these has a communicative function for humans, R can’t understand them. In order to get the answer that we want, we have to ask R to do something in a way it can understand, by writing commands it can parse (i.e. decipher) using the R language.\n\n\n\n\n\n\nGlossoRlia\n\n\n\nJust like learning any other language, learning to communicate with R takes time and practice, and it can be very frustrating when you and R can’t seem to understand each other. However, one advantage of learning to talk to R vs learning to speak a human language is that R always works the same way. It doesn’t get angry or sullen or sarcastic; it won’t ignore you or get impatient even if you ask it the same question a thousand times; and even if the response it gives doesn’t make sense to you, there’s always a logical reason for what it does.\nAlthough it certainly is complex, and occasionally quite frustrating, R is just a system for doing computational and analytical tasks. It’s powerful, and the very fact that you can do so much with it also means there’s a lot to learn. But it is comprehensible, and ultimately it’s just a tool to help you do your work well."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#types-of-data",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#types-of-data",
    "title": "01: IntRoductions I",
    "section": "Types of Data",
    "text": "Types of Data\nOne key concept for using R is the different ways it categorises data. “Data” here means any piece of information you put into R - a word, a number, the result of a command or calculation, a dataset, etc. Depending on the type of data you have, R will treat it differently, and some operations only work on certain types of data. So, let’s have a look at how R encodes and deals with different types of data. Here’s well cover three of the most common and important: numeric, character, and logical.\n\nNumeric\nThe first, and most obvious, type of data in R is numbers. Once again, let’s create a new code chunk and see what happens.\n\n\n\n\n\n\nExercise\n\n\n\nType any single number and run the code.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Pick any number at random\n\n3958\n\n[1] 3958\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that you can run all the code in a code chunk by pressing Ctrl/Cmd + Shift + Enter on your keyboard, or by clicking the green “play” arrow in the top right corner of the chunk.\nYou can also run only a particular line of code, or something that you’ve highlighted, by pressing Ctrl/Cmd + Enter.\n\n\nThis might be what you’d expect. We’ve essentially asked R, “Give me 3958” (or whatever number you put in) and R obliges. The only thing that might be a surprise is the [1] marker, called an index. Basically, R has replied, “The first thing ([1]) that you asked me for is 3958.” We’ll come back to this in a moment.\n\n\n\n\n\n\nExercise\n\n\n\nHow does R handle commas within a number (e.g. to separate the thousands place from the hundreds)? How about full stops for decimals?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3,958\n\nError: &lt;text&gt;:1:2: unexpected ','\n1: 3,\n     ^\n\n\n\n3.958\n\n[1] 3.958\n\n\n\n\n\n\n\nSo, commas within numbers throw an error. This is because commas have an important role to play in functions, so long numbers must be inputted into R without any punctuation. However, full stops to mark decimal places are just fine.\n\n\n\n\n\n\nGrammar Check\n\n\n\n\n\nTry for a moment switching to Source mode by clicking the Source button in the upper left hand of your Quarto document. You can see that RStudio helpfully marks out the part of the code that isn’t parsable (not in “grammatical” R) with a red ❌ next to the line number, and squiggly red underlining, likely familiar from word processing programmes, under the part of the code that’s causing the issue. It won’t do this for every error, but it’s very helpful for finding “grammatical” errors like extra or missing brackets or misplaced commas.\n\n\n\nNext, let’s try doing some basic maths.\n\n\n\n\n\n\nExercise\n\n\n\nAdd together your shoe size and the number of windows in the room you’re currently in.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 + 8\n\n[1] 48\n\n\n\n\n\n\n\nImportant to note here is that we don’t need to type an = to get the answer, just the equation we want to solve and press Enter. Again, we’ve asked R, “Give me 40 + 8” (or whatever numbers you chose) and R replies with the answer.\nYou will not be surprised to learn that you can use R as a calculator to subtract, divide, and multiply as well.\n\n\n\n\n\n\nExercise\n\n\n\nTry subtracting, dividing, and multiplying the same two numbers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n40 - 8\n\n[1] 32\n\n40 * 8\n\n[1] 320\n\n40 / 8\n\n[1] 5\n\n\n\n\n\n\n\n\nVectors\nLet’s imagine I want to generate some simple participant ID numbers to keep track of the order that they completed my study, and I had 50 in total. I could do this by typing every number out one by one, but this is exactly the kind of tedious nonsense that computers are great at. Instead, we’ll use the operator :, which means “every whole number between”.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out every whole number between 1 and 50.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n1:50\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n\n\n\n\n\n\n\nNotice that the indices mentioned earlier have come up again. The first element after the [n] index is the nth element. Let’s have a look at this some more.\n\n\n\n\n\n\nExercise\n\n\n\nPrint out all the numbers 12 through 30; all of the numbers 23 through 55; and 36, all in one command.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\n\n\n\n\n\nYou may have tried something like this:\n\n12:30\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n\n23:55\n\n [1] 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\n[26] 48 49 50 51 52 53 54 55\n\n36\n\n[1] 36\n\n\nAs you can see from the markers, this is three separate commands, because the numbered indices start over from [1] each time. However, we want all those numbers in a single command. To do this, I’m going to use a function called c().\nThis is our first contact with functions in R, and we’ll explore how they work more later on. To use this one, type it out, then inside the brackets, put the numbers you want to collect (or concatenate, or combine), with different groups separated by commas.\n\nc(12:30, 23:55, 36)\n\n [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53\n[51] 54 55 36\n\n\nAs you can see from the numbered indices this time, when I put the numbers I want inside the function c(), separated by commas, R collects all of the numbers into a single series of elements, called a vector.\nActually, we’ve been looking at vectors this whole time. Any series of pieces of information in R is a vector (but see Tip box on vectors and elements). When we were looking at single numbers (like 3958 above), we were still getting a vector back from R, but it was a vector with only one element, and thus only [1].\nIf I want the nth element in the vector we’ve just created, (say, the 88th), I can get it out using the numbered markers by indexing with square brackets.\n\nc(12:30, 23:55, 36)[33]\n\n[1] 36\n\n\nWhat I’ve essentially asked R is, “Put all of these numbers into a single vector, and then give me the 33th element in that vector.” As it turns out, the 33th element in that vector of numbers is 36.\n\n\n\n\n\n\nDefinition: Vectors\n\n\n\nA vector is essentially a series of pieces of data, or elements. It is a key basic piece of how data is stored in R. When R returns a vector as the output from a command, each element is numbered in square brackets. These square brackets can also be used to index the vector to get the nth element.\nFor atomic vectors created with c() or similar operations, there are some important rules:\n\nEach element must be scalar (i.e. of length 1)\nAll of the elements must have the same data type (or will be coerced)\n\nFor a complete explanation of vectors (and their more versatile siblings, lists) that’s beyond the scope of this tutorial, see:\n\nThis excellent explainer on vectors and lists\nR for Data Science chapter 20\n\n\n\n\n\nVector Calculations\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector of every whole number between 37 and 63, and subtract 7 from each one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(37:63) - 7\n\n [1] 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54\n[26] 55 56\n\n\n\n\n\n\n\nThis could be a very tedious process, but here we have an example of a vectorised operation. By default, the operation “subtract 7” is automatically applied to each individual element of the vector.\nWe can do a lot more than this with numbers and data in R, but this is an excellent start. Just one note before we move on about the order in which R performs its calculations.\n\n\n\n\n\n\nOrder of Operations\n\n\n\nMathematical expressions are evaluated in a certain order of priority. You can use brackets to tell R which part of a longer calculation to do first, e.g.:\n\n59 * (401 + 5)\n\n[1] 23954\n\n\nWithout the brackets, the expression is evaluated from left to right, which in this case would give a different answer:\n\n59 * 401 + 5\n\n[1] 23664\n\n\nWhenever there’s any chance for ambiguity, always use brackets to make sure the calculation is performed correctly.\n\n\n\n\n\nCharacter\nCharacters are a more general data category that also includes letters and words. In R, strings of letters or words must be enclosed in either ‘single’ or “double” quotes, otherwise R will try to read them as code:\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^\n\n\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nAs you can see here, the first command without quotes throws an error, whereas the second prints out our command just like it did with the single numbers before.\nAn important thing to note is that R sees everything inside a pair of quotes as a single element, regardless of how long it is. You can see this in the indices we saw before:\n\n\"Hi!\"\n\n[1] \"Hi!\"\n\n\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n[1] \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness...\"\n\n\nThe [1] markers also tell us that each of the two strings above already constitute vectors, each of length 1. Just like we saw with numbers, above, any number of character strings can be combined into a vector. You can also use the numbered markers to extract the nth element in that vector.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a vector containing the first five animals you think of, then print the 3rd one.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nc(\"bumblebee\", \"squid\", \"falcon\", \"flea\", \"seagull\")[3]\n\n[1] \"falcon\"\n\n\n\n\n\n\n\nThe placement of the quotes is very important - they can’t include the commas. As we said before, R uses commas to separate different elements. So, if you didn’t enclose each word in quotes separately with commas in between, you would have had this odd message:\n\nc(\"bumblebee, squid, falcon, flea, seagull\")[3]\n\n[1] NA\n\n\nNA is a special value in R. It indicates that something is not available, and it usually represents missing data, or that a calculation has gone wrong or can’t be performed properly.\nHere, we asked R for the third element in a vector that, as far as R can tell, only contained one. This is because there’s only one pair of quotes, so all five animals and the commas between them are considered to be one element. Since there isn’t a third element, R has informed us so accordingly - the answer to our query is NA, doesn’t exist. This isn’t what we wanted, but R is not in the wrong here, because it’s done precisely what we told it to do.\n\n\nLogical\nThe final type of data that we’ll look at for now is logical data. In addition to performing calculations and printing out words, R can also tell you whether a particular statement is TRUE or FALSE. To do this, we can use logical operators to form an assertion, and then R will tell us the result.\n\n\n\n\n\n\nExercise\n\n\n\nWrite the following assertions in R:\n\n5 is greater than 10\n6 is less than 12\n27 is less than or equal to 27\n49 does not equal 93\n420 equals 42\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n5 &gt; 10\n\n[1] FALSE\n\n6 &lt; 12\n\n[1] TRUE\n\n27 &lt;= 27\n\n[1] TRUE\n\n49 != 93\n\n[1] TRUE\n\n420 == 42\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsserting Equivalence\n\n\n\nThe last couple statements above may have caused you some trouble if the notation is unfamiliar.\nFor “does not equal”, ! is common notation in R for “not”, or the reverse of something. So != can be read as “not-equals”.\nFor “equals”, if you tried this with a single equals sign, you would have had a strange error:\n\n420 = 42\n\nError in 420 = 42: invalid (do_set) left-hand side to assignment\n\n\nThe problem is that in R, the single equals sign = is equivalent to the assignment operator &lt;-, which we’ll learn how to use shortly. Single = also has an important and specific role to play in function arguments. Essentially = is a special operator that doesn’t assert equivalance. Instead, “exactly equals” in R is “double-equals” (or “exactly and only”), ==.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse a single command to ask R whether the numbers 2 through 10 are less than or equal to 6.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n2:10 &lt;= 6\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\nHere R prints out a value of TRUE or FALSE for each comparison it’s asked to make. So, the first element in the output (TRUE) corresponds to the statement 2 &lt;= 6, the second to 3 &lt;= 6, and so on. This is a vectorised calculation again, as we saw with numeric data before. These vectorised assertions will be absolutely essential to selecting and filtering data that meet particular requirements, or checking our data to find problems."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#class-and-coercion",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#class-and-coercion",
    "title": "01: IntRoductions I",
    "section": "Class and Coercion",
    "text": "Class and Coercion\nWith these short examples, it may be obvious just by looking that 25 is a number and porcupine is a word. However, this isn’t always so straightforward, and there are some situations - such as data checking/cleaning, or debugging - where we might want to check what type of data a certain thing is. To do this, we’ll need another new function, class(). This function will print out, as a character, the name of the data type of whatever is put into the brackets.\n\n\n\n\n\n\nExercise\n\n\n\nUse the class() function to get R to print the values \"numeric\", \"logical\", and \"character\".\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Any numeric vector will do\nclass(216907)\n\n[1] \"numeric\"\n\n## You can also use a longer vector of numbers\n## as long as they are all numbers!\nclass(c(4:291, -1, 38.7, 100000000))\n\n[1] \"numeric\"\n\n## Logical has two options\n## Create a vector of TRUEs and FALSEs\nclass(TRUE)\n\n[1] \"logical\"\n\n## Create a vector that outputs logical values (now you're thinking with functions!)\nclass(c(6 &gt; 4, 10 == 37, 3 != 8))\n\n[1] \"logical\"\n\n## Character\nclass(\"antidisestablishmentarianism\")\n\n[1] \"character\"\n\n\n\n\n\nWhat data type does R give you if you combine numbers and characters in c()?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Again, anything will do\n\nclass(c(93, -1905, \"avocado\"))\n\n[1] \"character\"\n\n\n\n\n\n\n\nSomething interesting has happened here. Recall that atomic vectors created with c() must all have the same data type. Here, we combined two types of data: numeric and character. We didn’t get an error - instead, without warning or telling us, R quietly converted the entire vector to character type. This forcible conversion is called coersion.\n\n\n\n\n\n\nCoersion\n\n\n\nCoersion is when a piece of data is forcibly changed from one data type to another. This is sometimes intentional, but it can happen unintentionally (and without any warning or fanfare!), so is a common source of errors.\nCoersion follows a hierarchy; data types on the left can be coerced into the types further along to the right.\nlogical ==&gt; integer ==&gt; double (numeric) ==&gt; character\nAs we saw previously, you can check the data type of a vector with class(). You can also check if a vector is a particular type (and receive a logical vector in response) with the is.*() family of functions. (The * notation refers to a placeholder for many different options, such as is.numeric, is.character, etc.)\nYou can similarly (try to) coerce a vector into a particular data type with the as.*() family of functions.\n\n\nThis explains why our vector from the last exercise was a character vector - since the vector contained at least one character element, everything else in the vector was coerced to the same type. This can cause problems when, for example, numeric data is coerced into character data, even though it still looks like numbers.\nEven though we can do mathematical operations on numbers, we can’t do them on characters; it should be clear that asking e.g. what is \"tomato\" - 7 is nonsense. However, this is the case even if all of the data are numerals! For example:\n\n## No problem here; all numbers\nc(2:20, 45) - 7\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 38\n\n## Doesn't work\nc(2:20, \"45\") - 7\n\nError in c(2:20, \"45\") - 7: non-numeric argument to binary operator\n\n\nEven though “45” looks like a number, because it’s in quotes, R thinks that it’s a character, and will refuse to do the calculation, in the same way that it would refuse to do it with “tomato”."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#objects",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#objects",
    "title": "01: IntRoductions I",
    "section": "Objects",
    "text": "Objects\nR is a programming language, but (being created by speakers of natural language) it has many features similar or analogous to natural languages. In this section, we’ll cover the basic “grammar” of R, including how R understands what you ask it to do.\nIn a similar way that the basic unit of many languages is the word1, the basic unit of the R programming language is the object. This section will explore the basics of what an object is and some of their key features in R.\n\n\n\n\n\n\nDefinition: Objects\n\n\n\nObjects are the basic elements that R is built around - the equivalent of words. An “object” in R is any bit of information that is stored with a particular name. Objects can hold anything, from a single number or word to huge datasets with thousands of data points or complex graphs. These named objects are the main way you, the programmer, can store, retrieve, and interact with information in R.\n\n\n\nCreating an Object\nAlthough we have done quite a bit in R so far - creating vectors, doing calculations, etc. - you may notice that we haven’t stored this information anywhere. To store the output of code for further use, it needs to be assigned to an object using the assignment operator, &lt;-. Once an object is created, it will appear in the Environment pane.\n\n\n\n\n\n\nClear Your Environment\n\n\n\nAt the moment your Environment should be empty. As a reminder, Environment is by default the first (leftmost) tab in one of your four main windows in RStudio, probably the one on the top right.\nIf this window is blank except for “Environment is empty”, you’re ready to go. If for some reason it isn’t empty, click the broom icon to clear everything from your Environment before you get started, as indicted in the image below. (There will be a very ominous-sounding “Are you sure?” pop-up, but just click “Yes”.)\n\n\n\nFirst, let’s look at the foundational structure of almost everything you will do in R:\nobject &lt;- instructions\nThis is “pseudo-code”, or a “general format” for a command in R. It isn’t valid R code, but is rather intended as a midpoint between natural language and R to help make it clear how the code works. You can read this code as, “An object is created from (&lt;-) some instructions.”\n\nobject: Objects can be named almost anything (although see Naming, below). The object name is a label so you, the analyst, can find, refer to, and use the information you need.\n&lt;-: The assignment operator &lt;- has single job: to assign output to names, or in other words, to create objects.\ninstructions: Any amount of code that produces some output, which is what object will contain.\n\n\n\n\n\n\n\nNaming Objects\n\n\n\n\n\nCOMING SOON\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nThink of a research scenario familiar to you with two independent groups. You’re welcome to draw from your own research or expertise, but you should choose something with numerical scores. Some ideas include:\n\nReaction times on a button-pressing task from a control and an experimental intervention group\nStatistics anxiety scores from first and second year UG students\nQuiz marks from students with practicals scheduled 9am and students with practicals at 6pm\n\nMake a note of the scenario you chose. Then, create two new objects: one that contains a vector of seven scores from the first of the two groups, and the second that has seven different scores from the second group.\nHint: Just make up some numbers!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nChoosing scenario 3, this vector contains some hypothetical quiz marks from each class.\n\nquiz_9am &lt;- c(75, 58, 62, 14, 33, 67, 55)\nquiz_6pm &lt;- c(45, 90, 27, 65, 39, 77, 48)\n\nLet’s have a look at this command. On the left side I’ve written the name I want my new object to have, which I’ve called quiz_9am[^1]. Next, the assignment operator &lt;- assigns whatever comes after it to the object label quiz_scores_9am. Finally, I’ve written instructions for what I want this object to contain: in this case, a vector of numbers that I’ve made up, but that reasonably look like quiz scores.\n[^1]: I could have called it anything, like the_first_example_of_an_object_InThisSection.so.far or made_upQuizScores.fornineamclass or anything else that follows R’s naming conventions. However, it’s a good idea to name your objects something brief and obvious, so you can remember what they contain.\nIf you haven’t done this yet, do so now, even if you’ve looked at the solution rather than trying it for yourself first. Once you’ve typed the command, there’s a final step to actually create the object: you have to run the command in order for it to take effect. As a reminder, you can do this by clicking the green ▶️ button in the upper right corner of the code chunk, or by pressing Ctrl/Cmd + Enter when your cursor is blinking on the same line as the code you want to run.\n\n\n\n\n\nAssuming your code is valid, you should see a green bar appear along the left-hand side of the code chunk when you run the code, but you might notice that there’s no printout that appears under the code chunk, as there was previously. In fact, if the code ran successfully, it might look like nothing happened at all. To find out what did happen, look your Environment pane. You should now see a new section, “Values”, and underneath the name of your new object and what it contains. Success!\n\n\nCalling an Object\nFor any object, from the most simple to the most complex, you can always see what’s in it by calling the object. This simply means that you type the name of the object and run the code. R will print out whatever is stored in the object.\n\n\n\n\n\n\nExercise\n\n\n\nCall both of the objects you just created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nReplace with the name of the object you created, if you did something different.\n\nquiz_9am\n\n[1] 75 58 62 14 33 67 55\n\nquiz_6pm\n\n[1] 45 90 27 65 39 77 48\n\n\n\n\n\n\n\nThis output looks just like what we saw earlier, when we just asked R to print out a vector of numbers. In essence, the object names are just labels for storing and referring to the information they contain.\n\n\n\n\n\n\nCreating vs Calling\n\n\n\nThese two actions are the essential basis of everything you will do in R. All of your code will, at base, either create an object, or call an object. (Changing an existing object, as we’ll see shortly, is the exact same procedure as creating one from scratch.)\nWhen you create an object using the assignment operator (&lt;-), the object is created but is not printed out. This is because R always does only and exactly what you ask it to do, and using the assignment operator only tells R to assign something to an object, not to print it out.\nWhen you call an object, the current contents of that object are printed out, but that object is not changed - you only reproduce a copy of its contents for review. To create or change an object, you must use the assignment operator to assign the output to a new (or existing) object name.\n\n\nLet’s make all of this a bit more concrete by seeing how we can use objects effectively.\n\n\nUsing Objects\nSince objects are convenient reference labels for the information they contain, we can work with them as if they were the information they contain. In this case, our objects contain numbers, so we can use them for numerical calculations.\nFor instance, we might want to know what the mean mark was for this sample of quiz marks. To do this, we could make use of a very handy function, mean(), as follows:\n\nmean(quiz_9am)\n\n[1] 52\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCalculate the mean of each of the two sets of scores you created.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhether you save the output of the mean() command is up to you!\n\nmean(quiz_9am)\n\n[1] 52\n\nmean(quiz_6pm)\n\n[1] 55.85714\n\n\n\n\n\nCalculate the difference in the mean of each of the two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nHere are two options for accomplishing this.\nThe first option is to save each mean value in a new object (if you didn’t do that already), then subtract one mean from the other. This is very easy to read, but a bit inefficient.\n\nmean_9am &lt;- mean(quiz_9am)\nmean_6pm &lt;- mean(quiz_6pm)\n\nmean_9am - mean_6pm\n\n[1] -3.857143\n\n\nThe second option is to do everything in one command, which takes a bit more effort to parse but is more succinct.\n\nmean(quiz_9am) - mean(quiz_6pm)\n\n[1] -3.857143\n\n\n\n\n\nWhat is the class of these objects?\n\n\n\n\n\n\nSolution\n\n\n\n\n\nEither one will do.\n\nclass(quiz_9am)\n\n[1] \"numeric\"\n\n\nSo, an object has the class of the data it contains.\n\n\n\n\n\n\n\n\n\n\n\nObject Names vs Strings\n\n\n\nYou may have been surprised to see that the class of these objects is numeric, rather than character - even though the name of the object is a character string. To find out the class of the object, R looks at what that object contains, not at the name of the object itself. We already saw that quiz_9am (or whatever your object is called) contains only numbers; so, R tells us that it’s a numeric vector.\nOne more example to emphasize this point, because it’s often a source of confusion when starting out with R. If we want to ask R the class of the string “quiz_9am”, we would need to put it in quotes, and we’d get a different answer:\n\nclass(\"quiz_9am\")\n\n[1] \"character\"\n\n\nThe key thing here is that objects have the class of the data they contain, and are not character data; and whenever you want to use an object, you must not use quotation marks. On the other hand, if you want to input character data into R, you must use quotation marks. Otherwise, R will look for an object or function with that name, which will likely produce a “cannot find object” error.\n\n\nBecause we’ve used the assignment operator, R doesn’t print out the years. Instead, the output of our calculation is saved as the object birth_year. Hmm - didn’t we already have an object called birth_year, though? What happened to it?\n\n\n\n\n\n\nImportant: Overwriting Objects\n\n\n\nYou might notice that we already had an object called birth_year that we created above. R, again, does only and exactly what you ask it to do. Unlike, say, a word processer, that will give you a warning if you try to save two documents in the same folder with the same name, R won’t ask you if you’re sure you want to overwrite an existing object with new information - it will just do it. If you have a look in your Environment, you will see that the previous version of birth_year, containing only your birth year, has been quietly replaced with the new one containing the vector of birth years you just created.\nThis can be a good thing, because you can easily update the information stored in an object with changes, edits, or new information. However, it also means that you can overwrite or replace data when you don’t want to, if you use the same object name.\nThis is why it is so important to keep track of all of the commands and changes you make to your data. If you accidentally replace your dataset with, say, a single word or number with an error in your code, you can easily retrace your steps and avoid redoing work.\nIf you are interested in understanding this process of assigning and replacing the contents of objects better, the aside below explains it in more depth.\n\n\n\n\n\n\nCan you actually change an object?\n\n\n\n\n\nThink of objects as boxes. The names of the objects are only labels, and you can store anything you like inside them. However, unlike in the physical world, objects in R cannot truly change. You can put stuff in and take stuff out, and that’s pretty much it. Unlike boxes, though, when you take stuff out of objects, you only take out a copy of its contents. The original contents of the box remain intact. Of course, you can do whatever you want (within limits) to the stuff once you’ve taken it out of the box, but you are only modifying the copy. The key thing to remember is that unless you put that modified stuff into a box, R will forget about it as soon as it’s done with it. In other words, if you want to “save” any changes you make, you must assign them to an object in order to keep them.\nNow, as you probably know, you can call your boxes (objects) whatever you want (again, within certain limits). This means that that you can call the new box the same as the old one, as we saw with birth_year above. When that happens, R basically takes the label off the old box, pastes it on the new one, and burns the old box. So even though some operations in R may look like they change objects, what’s actually happening is that R copies their content, modifies it, stores the result in a different object, puts the same label on it, and discards the original object. Understanding this mechanism will make things much easier!\nPutting the above into practice, this is how you “change” an R object:\n\n# put 1 into an object (box) called a\na &lt;- 1\n\n# copy the content of a, add 1 to it and store it in an object b\nb &lt;- a + 1\n\n# copy what's inside b and put it in a new object called a\n# discarding (\"overwriting\") the old object a\na &lt;- b\n\n# now see what's inside of a\n# (by copying its content and pasting it in the console)\na\n\n[1] 2\n\n\nOf course, you can just cut out the middleman (creating an object b). So to increment a by another 1, we can do:\n\na &lt;- a + 1\n\na\n\n[1] 3\n\n\n\n\n\n\n\nWe will talk further about using scripts and writing multiple commands below; but first, we’ll need to have a look at a very important type of object in R: the function."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#functions",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#functions",
    "title": "01: IntRoductions I",
    "section": "Functions",
    "text": "Functions\nFunctions are like verbs in the R language - they’re how R does anything. In order to use them, you need to “translate” the command you want to give R into a verb (function) it can understand.\n\nBasics and Help\nLet’s look at an example of how this translation might work. For this example, I’m going to use a number I generated earlier: the mean of the quiz_6pm group, which was 55.8571429, which I’d like to round to two decimal places - a common task for reporting results in APA style.\nIf we want R to do this for us, we have to write this command in a way that R can understand. First, we need to know what function corresponds to the English verb “round” - that is, what function will do the same action that we want R to perform. We’re lucky in this case: the function in R is also called round().\nWe know that we’re looking at a function in R because functions often have a name followed by brackets (and nothing else in R does). That is, they have the general form function_name(). Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.\n\n\n\n\n\n\nExercise\n\n\n\nTry running the round() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nround()\n\nError in eval(expr, envir, enclos): 0 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nUnsurprisingly, R has given us an error. This is an informative error, though - that is, the error gives of some sort of intelligible clue about what’s gone wrong. Namely, it tells us that round() can’t just work without additional information (i.e. “required arguments”). Imagine, for instance, if you wanted a colleague to round 55.8571429 to two decimal places, and in order to ask them to do that, you just shouted “ROUND!” at them. Similarly, R has objected to this, telling you that it needs more information in order to do what you’ve asked it to.\n\n\n\n\n\nWhat we want to do, “Round the number 55.8571429 to two decimal places”, has two more important pieces of information that we need to tell R: what number we want to round (55.8571429) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let’s look at the help documentation.\n\n\n\n\n\n\nExercise\n\n\n\nOpen the help documentation for the round() function by running ?round() or help(round) in the Console.\n\n\n\n\n\n\n\n\nHelp Documentation\n\n\n\nHelp documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it’s a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running ?function_name or help(function_name) in the Console, or by clicking on the “Help” tab in the Files section of RStudio and using the Find box to search for the function.\n\n\nThe first section, “Description”, varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function including in this document, we can see that we have a useful description of round() that tells us that it rounds numbers (that’s a good sign) to a certain number of decimal places. That’s exactly what we want, so how do we use it?\nLet’s scroll down to “Usage”, which gives examples of what the function looks like. You can see that the basic structure of this function is round(x, digits = 0). It seems like we need to add some more information in the brackets of our function - but how do we interpret x and digits = 0?\n\n\nArguments\nThe information inside a function’s brackets to give it the information it needs to work are called arguments. Each argument in a function is separated by a comma, so we can see from round(x, digits = 0) that the round() function can take two arguments. How many arguments a function has depends on the function; some (like Sys.Date()) don’t need any arguments to run. One of the most useful parts of a function’s help documentation is the “Arguments” section, which tells you what each of the function’s arguments are and how to use them.\nThere are two main types of arguments: named and unnamed arguments. Conveniently, the arguments of round() give us one example of each.\n\nUnnamed Arguments\nThe first argument to round() is simply x. Just like in maths, x is a placeholder for some number or numbers (a “numeric vector”, which should sound familiar now) that you want to pass to the function. This is common notation in many functions: x, often the first argument in a function, is often the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that’s what we should replace with x.\nThis argument has no default so it must be provided, or the function won’t run.\n\n\nNamed Arguments\nThe second argument of round() is a named argument, digits = 0. You can think of named arguments like settings that change the way a function works, often with only certain allowable values. Here we can see that the name of the argument is digits; the name before the = sign tells R which setting we want to change.\nThe help documentation tells us that digits should be an “integer indicating the number of decimal places…to be used.” We can also see in “Usage” that this argument has a default value, digits = 0. That means that if we don’t explicitly include the argument digits when we use the function, by default the round() function will round the number you give it to 0 decimal places. Named arguments frequently, but not always, have a default, and it’s important to check so the function doesn’t quietly do something unexpected.\nDefault values of arguments are really useful, because the default is usually the most frequently used setting. It means you don’t have to specify every single aspect of a function every time you use it, as long as you want the function to work that way! In our case, we actually wanted round() to round to two decimal places, not 0. So, in our command, we should change the setting from the default, 0, to 2.\n\n\n\nUsing Functions\nNow that we know what both of these arguments mean, we can change them to actually translate the English sentence “Round the number 55.8571429 to two decimal places” into a command that R can work with. We’ll explicitly write out each argument so we know what they are doing.\n\n\n\n\n\n\nExercise\n\n\n\nUse the round() function to round 55.8571429 to two decimal places.\nIf you prefer, you can do this with one of the means you calculated for your own scores earlier.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## Using the actual value from my earlier calculation\nround(55.85714, 2)\n\n[1] 55.86\n\n## Using a nested function - that is, calculating the mean and then rounding it!\nround(mean(quiz_6pm), 2)\n\n[1] 55.86\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\n\n\n\nIf you want to, you can achieve the same result by changing the order of the arguments. Because we have written the names of both arguments, R can still do what we want it to do:\n\nround(digits = 2, x = 55.85714)\n\n[1] 55.86\n\n\nWe can also, to some degree, drop the names of the arguments, as long as R can still understand what we’re trying to do:\n\nround(digits = 2, 55.85714)\n\n[1] 55.86\n\n\nHere I left out the x =. R can still understand this because round() only takes two arguments, and we explicitly told it what value belongs to digits, so it assumes the second number must be x.\n\nround(55.85714, 2)\n\n[1] 55.86\n\n\nThis time I dropped both argument names. R can still understand this because when you don’t specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 55.85714 to x and 2 to digits, which is what we wanted.\nAs I use R more and more, I find that I name arguments more consistently, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That’s because when I come back from lunch, or the next day, or six months later to revisit the same code, it’s much easier to recall what it all means when it’s well-annotated. So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:\n\nround(2, 55.85714)\n\n[1] 2\n\n\nHere, since we didn’t specify, R assumed that 2 was the number we wanted to round. This isn’t what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.\n\n\n\n\nPassing Multiple Values to Arguments\nA last important aspect of using functions is to remember that each argument in a function can only take a single object or value as input. For example, we saw above that we put the single value 55.85714 into the x argument of round(). But what if we wanted to round more than one number? We don’t want to have to write a new round() command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:\n\nround(55.85714, 2)\n\n[1] 55.86\n\n## ughhhh\nround(59.54, 2)\n\n[1] 59.54\n\n## noooooo :(\nround(0.198, 2)\n\n[1] 0.2\n\n## thanks I hate it\n\n\n\n\n\n\n\nExercise\n\n\n\nBefore you go on, have a go using a single round() command to round all three numbers at once.\nHint: Refer to Vectors.\n\n\nSo what happens if we try to put all of those numbers into round()? We might first try this:\n\nround(55.85714, 59.54, 0.198, 2)\n\nError in eval(expr, envir, enclos): 4 arguments passed to 'round' which requires 1 or 2 arguments\n\n\nOnce again, R tells us that this doesn’t work by throwing an error. R has tried to do what we wanted, but the round() function only allows a max of two arguments, and we’ve given it four. Behind the scenes, R has tried to run round(x = 55.85714, digits = 59.54... and can’t proceed from there because it doesn’t know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first x argument together. If only there was a way to concatenate them together…\nYou may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a single object, and then pass that object to round() as the x argument. We already saw that we can combine any number of things together into a single vector using the c() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n## Create an intermediate object to contain the numbers\nnumbers &lt;- c(55.85714, 59.54, 0.198)\nround(numbers, digits = 2)\n\n[1] 55.86 59.54  0.20\n\n## Put the vector of numbers into round() directly\nround(c(55.85714, 59.54, 0.198), digits = 2)\n\n[1] 55.86 59.54  0.20\n\n\n\n\nHere we can see a good example of a function inside another function. You can stack, or “nest”, functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it’s doing. (There’s a great solution to this problem that we’ll make extensive use of in the future: the pipe operator.)\nThat’s looking like some proper R code! Very nicely done.\n\n\n\n\n\n\nHelp Documentation, Revisited\n\n\n\nBefore we leave the round() function altogether, let’s take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the “Details” section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn’t doing what you expect it to, this is a good place to look for an explanation.\nFinally, at the end of the documentation you can find the “Examples” section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the “Run examples” link, which will run the code in the Examples section for you so you can see what the function will do."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#lets-get-testing",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#lets-get-testing",
    "title": "01: IntRoductions I",
    "section": "Let’s Get Testing",
    "text": "Let’s Get Testing\nLet’s put all of this together and have a look at what we can already do with the skills in this tutorial. R has many, many uses, but one of its core purposes is statistical analysis - and we already know more than enough to do this.\n\nComparing Groups with t-test\nWe’ve created two objects that contain scores from two different groups - scores we made up, but we will get to real data soon (in the next tutorial!). For now, one common statistical test we could run on data like this is a t-test, which is a hypothesis test essentially quantifying whether scores come from the same or different populations.\nThe function to run a t-test in R is t.test(), so let’s have a go!\n\n\n\n\n\n\nExercise\n\n\n\nBring up the help documentation for t.test() and use it to run a t-test comparing your two sets of scores.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nt.test(quiz_9am, quiz_6pm)\n\n\n    Welch Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 11.969, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23978  21.52550\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\n\n\n\n\n\nThere are a lot of options in the t.test() function, which can be used, through different arguments, to run almost any variety of t-test you can think of. In this case, though, the code is quite simple, because we want all the default settings (for a two-sample, independent test), so we only need to provide x and y, our two numeric vectors.\nNote that the output mentions “Welch Two Sample t-test”, which is a robust version of the test that does not assume equal variances. This is the version that is taught to undergraduates, because we have not at this point introduced the process of assumption testing. If you definitely know that the variances are equal and you definitely want Student’s t-test, you can instead change the default setting:\n\nt.test(quiz_9am, quiz_6pm, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  quiz_9am and quiz_6pm\nt = -0.33119, df = 12, p-value = 0.7462\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -29.23255  21.51826\nsample estimates:\nmean of x mean of y \n 52.00000  55.85714 \n\n\nIn the next tutorial, we’ll see how to turn this rather ugly R output automatically into beautifully formatted reporting like this:\n\nWe compared mean scores between two groups, one who took the quiz in a 9am practical session (M = 52) and the other who took the quiz in a 6pm practical session (M =55.86, Mdiff = -3.86). There was no statistically significant difference in scores between timing groups (t(12) = -0.33, p = 0.746, 95% CI [-29.23, 21.52])."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#footnotes",
    "href": "tutorials/psychrlogy/01_fundRmentals/01_intro.html#footnotes",
    "title": "01: IntRoductions I",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs a linguist I have to note, one, words don’t exist, and two, the closest linguistic term for what an object is is probably “lexeme”. “Word” will get you in the right vicinity, though, conceptually. If you’d like to dive down this rabbit hole (rabbit-hole?) this Crash Course video on morphology is a good place to start.↩︎"
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html",
    "href": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html",
    "title": "02: Datasets",
    "section": "",
    "text": "Libraries\nReading in, viewing and summarising datasets\nSubsetting with `$`, `pull()`\nUseful verbs: count, tally, mean, sd, min, max, etc.\nQuarto: chunk options, inline code, automatic numbering, rendering\nBase R visualisations"
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#overview",
    "href": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#overview",
    "title": "02: Datasets",
    "section": "Overview",
    "text": "Overview\nThis tutorial is focused on working with datasets, and on writing up the findings from those datasets using Quarto documents. The tutorial covers key functions and tips for reading in, viewing, summarising, and working with datasets, and then walks through the process of setting up and producing a Quarto report, including how to dynamically report results and render a final document to a variety of formats.\nTo kick off, however, we’ll start with an essential piece of R code: the pipe."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#the-pipe",
    "href": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#the-pipe",
    "title": "02: Datasets",
    "section": "The Pipe",
    "text": "The Pipe\nIn the previous tutorial, we saw some examples of “nested” code - functions within functions, as below:\nFor one or two levels of nesting, this is still legible, but can quickly become very difficult to track. One solution is to use the pipe operator, |&gt;. The pipe “chains” commands one after the other by taking the output of the preceding command and “piping it into” the next command, allowing a much more natural and readable sequence of steps. The pipe version of the above might look like this:\n\n\n\n\n\n\nDefinition: Pipe\n\n\n\nThe pipe operator may appear in two formats.\n\nThe native pipe, |&gt;. This is the pipe we will use throughout these tutorials. It is called the “native” pipe because it is inbuilt into R and doesn’t require any specific package to use.\nThe {magrittr} pipe, %&gt;%. This pipe comes from {tidyverse}, and in particular requires the {magrittr} package to use. You will very commonly see this pipe in scripts, Stack Overflow posts, from ChatGPT, etc. as the native pipe was only introduced to R in 2022.\n\nIn most use-cases, including almost all of the code we will learn in these tutorials, the two pipes are interchangeable and will result in the same output.\nConceptually, the pipe works by putting whatever is put into it into the first argument of whatever comes after it. Many functions - both packages and functions from the {tidyverse} and not - are already set up so that the first argument is the data, and {tidyverse} functions are explicitly designed this way in order to work best with the pipe. For functions where this is not the case, you can explicitly determine where the piped-in object should go using a “placeholder”.The most noticeable difference is that the native pipe placeholder is _, while the magrittr pipe placeholder is ..\n\n\n\n\n\n\nPipe Example\n\n\n\n\n\nImagine we wanted to bake a Victoria sponge cake using R. Translating the steps into R, we might get something like this:\n\ningredients |&gt; \n  mix(order = c(\"wet\", \"dry\")) |&gt; \n  pour(shape = \"round\", number = 2, lining = TRUE) |&gt; \n  bake(temp = 190, time = 20) |&gt; \n  cool() |&gt; \n  assemble(filling = c(\"buttercream\", \"jam\"), topping = \"icing_sugar\") |&gt; \n  devour()\n\nError in devour(assemble(cool(bake(pour(mix(ingredients, order = c(\"wet\", : could not find function \"devour\"\n\n\nAt each step, |&gt; takes whatever the previous step produces and passes it on to the next step. So, we begin with ingredients - presumably an object that contains our flour, sugar, eggs, etc - which is “piped into” the mix() function. The output of that function might be all our ingredients mixed together in a bowl, which is then piped into the pour() function, and so on.\nNotice for example, the function cool(), which doesn’t appear to have anything in it. It actually does: the cool() function would apply to whatever the output of the bake() function was above it."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#datasets",
    "href": "tutorials/psychrlogy/01_fundRmentals/02_datasets.html#datasets",
    "title": "02: Datasets",
    "section": "Datasets",
    "text": "Datasets\n\nReading In\nThe first step in any data analysis process will be getting a hold of some data! This can be a complex procedure, so to keep it as streamlined as possible, we will always recommend the following steps:\n\nAlways use a project file.\nAlways use the same folder structure.\n\n\n\n\nViewing\n\n\nArranging\n\n\nOverall Summaries\n\nBase R\nThe quickest and easiest check for a whole dataset is the base R function summary(). This function doesn’t do anything fancy (at all) but it does give you a very quick look at how all the variables have been read in, and an early indication if there’s anything wonky going on.\n\nExample\n\nsummary(my_tibble)\n\nHere, for example, notice the age variable. This should be a numeric variable, but clearly something has gone pear-shaped, because it instead seems like a character variable. Compare this to, for example, OTHER EXAMPLE, which has some descriptive information about the distribution of values in the variable, which indicates that it has been successfully read as numeric.\nWe will ignore the age issue for now until we cover how to make changes to the dataset in Tutorial 5\n\n\n\n{datawizard}\nBesides the basic summary, there are many ready-made options in various packages to quickly produce summary tables. At the UG level, students are introduced datawizard::describe_distribution(), which is one such function. To use it, simply put the name of the dataset object inside the brackets.\n\n\n\n\n\n\nTip\n\n\n\nBesides its default settings, the output can be further customised to add or remove particular statistics; see the help documentation.\n\n\n\nExample\n\ndatawizard::describe_distribution(my_tibble)\n\n\n\n\n\nVariables\nOnce we’ve had a look at the whole dataset, it’s time to drill down into individual variables. We may want to calculate quick descriptives or investigate what’s going on with particular variables that seem to have issues (as we saw with age above). For any of these tasks, we’ll look at variables one at a time by subsetting or otherwise pulling them out of the dataset, then calculating some information about them.\n\nSubsetting\n\n\nCounting\n\n\nDescriptives\n\n\nVisualisations"
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#overview",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#overview",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "",
    "text": "This tutorial covers how to run, inspect, and report a linear model in R. For the report portion, we will cover some key features of dynamic reporting in Quarto and how to write and render professionally formatted documents."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#the-linear-model",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#the-linear-model",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "The Linear Model",
    "text": "The Linear Model\nIn this section, we will walk through the process of fitting, comparing, and reporting hierarchical linear models in R. This is not a statistics tutorial, so there will be minimal detail about how to understand or interpret the output of these commands. Instead, refer to Prof Andy Field’s discovr tutorials, which are the primary teaching materials for the same content in UG teaching. All of the code and interpretation in the following section is from discovr_08, the GLM.\n\nThere are two key goals for this linear model walkthrough:\n\nCreate a detailed “cheatsheet” for a linear model analysis for future reference\nGet familiar with the discovr tutorials\n\nOf the two, the first is more important. I’d strongly recommend you open the relevant discovr tutorial and skim through it as you go so you’re familiar with what it contains. However, the following sections of this tutorial will present the same code and information with very abbreviated text, to serve as a quick reference.\nYou can also have them both open at once and refer to each!\n\n\n\n\n\n\n\nUsing the discovr tutorials\n\n\n\n\n\nProf Andy Field’s discovr tutorials provide detailed walkthroughs of both the R code and the statistical concepts of a variety of statistical analyses. They are a good place to look first to understand what your UG supervisees or advisees have been taught on a particular topic.\nThe tutorials are built in {learnr}, an interactive platform for learning and running R code. So, unlike the tutorial you’re currently reading, they must be run inside an R session. We have already installed all of the tutorials in your Posit Cloud workspace.\nTo open a tutorial, open any project and click on the Tutorial tab in the Environment pane. You can run any tutorial from here, but the relevant one for the linear modelling we are working on now is discovr_08, “the GLM”. Scroll down to this tutorial and click the “Start Tutorial ▶️” button to load the tutorial.\nBecause discovr tutorials run within R, you don’t need to use any external documents; you can write and run R code within the tutorial itself. However, I strongly recommend that whenever you work with these tutorials, you write and run your code in a separate document, otherwise you will have no record of the code and output.\n\n\n\n\nData and Codebook\nToday’s data is a truncated version of the TeachingRatings dataset from the {AER} package. You can load the codebook in the Help viewer by running the following in the Console:\n?AER::TeachingRatings\n\n\nOne Predictor\nNow that we have some data, we can fit our first model with a single predictor. We will do this with the very hardworking lm() function in R, standing for “linear model”.\nThe lm() function has a lot of options (as you might expect, given the versatility and ubiquity of linear models!), but its basic format to fit a linear model with a single predictor is very simple:\nlm(outcome ~ predictor, data = our_dataset)\nIn this function, outcome ~ predictor is a formula expressing a (simplified version of) the linear model equation. Here, outcome is the name of the variable in our_dataset that contains the outcome or dependent variable y, and predictor is the name of the variable that contains the predictor or independent variable x.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk and use the Codebook and the lm() function to fit a linear model predicting teaching evaluation score from beauty ratings. Save the resulting model in a new object called eval_lm.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm &lt;- lm(eval ~ beauty, data = teach_tib)\n\nThat’s it!\n\n\n\n\n\n\nModel Information\nNow we have a new object that contains all the information about our model. We could simply call the name of this object, but the output doesn’t tell us anything besides the actual value of the b estimates. Instead, we’ll use some useful functions from the {tidyverse} package {broom} to get the information we need.\n\n\nModel Fit\nTo get some common measures of model fit, we can use the function broom::glance(). The output includes \\(R^2\\), adjusted \\(R^2\\), and F and accompanying statistics in comparison to the null model (the mean of the outcome alone).\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::glance() to get model fit statistics.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::glance(eval_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic   p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0357        0.0336 0.545      17.1 0.0000425     1  -375.  757.  769.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\n\n\n\n\n\nHelpfully, broom::glance() (and many other {tidyverse} functions) output tibbles, which means we can work with them as we already know how to do. In Tutorials 4 and 5, we’ll also learn more about changing and filtering tibbles that will make this very more useful. For now, we can simply note the information we get out of this function for future use.\n\n\nModel Parameters\nTo get information about the b estimates for individual predictors, we can use the function broom::tidy(). We could run this function without any other information, as we did with glance() above, but we’ll change one argument here in order to get 95% confidence intervals for b in the output as well.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, put the eval_lm object into broom::tidy(). Use the argument conf.int = TRUE to obtain confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nbroom::tidy(eval_lm, conf.int = TRUE)\n\n# A tibble: 2 × 7\n  term        estimate std.error statistic   p.value conf.low conf.high\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)    4.00     0.0253    158.   0           3.95       4.05 \n2 beauty         0.133    0.0322      4.13 0.0000425   0.0698     0.196\n\n\n\n\n\n\n\n\n\n\nHierarchial Models\nNext, we may want to test the addition of further predictors in the model. We can then compare the more complex multi-predictor model to the single-predictor model.\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, fit a linear model with teaching evaluations as the outcome, and both beauty ratings and gender as predictors. Save the model output in a new object called eval_full_lm.\nThen, obtain model fit statistics and parameters as before.\nHint: to add a new predictor, you will need to literally add it (+) to the formula.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_full_lm &lt;- lm(eval ~ beauty + gender, data = teach_tib)\n\nbroom::glance(eval_full_lm)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic     p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1    0.0663        0.0622 0.537      16.3 0.000000141     2  -368.  744.  760.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\nbroom::tidy(eval_full_lm)\n\n# A tibble: 3 × 5\n  term         estimate std.error statistic    p.value\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0         \n2 beauty          0.149    0.0320      4.65 0.00000434\n3 genderfemale   -0.198    0.0510     -3.88 0.000120  \n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat About Interactions?\n\n\n\n\n\nThe models we’re describing here contain only additions, not interactions. So, you may be wondering, “What if I want to model more complex relationships between predictors?” If that’s what you’re trying to do now, you may want to jump ahead to discovr_10 for moderation and mediation.\nOtherwise, we will get there in this course eventually!\n\n\n\n\nComparing Models\nNow we have two models, one simpler with only a single predictor, and the other with two predictors. We might next want to test whether the more complex, two-predictor model is a significant improvement over the simpler model, in order to decide which model to retain. We can do this with the anova() function1 to compare the two models.\n\n\n\n\n\n\nWarning\n\n\n\nThe anova() function will only work for model comparison for particular models.\n\nThe models must be hierarchical. That is, the more complex model(s) must contain all of the predictor(s) present in the less complex model(s).\nAll models must be fit to the same dataset. If, for example, your first predictor has no missing values, but your second predictor had one, the model with using the second predictor would have been fit to a dataset of a different size than the model using only the first, and the anova() function will throw an error to this effect.\n\nIf you encounter this issue, you may need to inspect and clean your dataset before you proceed with analysis!\n\n\n\n\n\n\n\n\nExercise\n\n\n\nPut both model objects into the anova() function to find out which model to retain.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nanova(eval_lm, eval_full_lm)\n\nAnalysis of Variance Table\n\nModel 1: eval ~ beauty\nModel 2: eval ~ beauty + gender\n  Res.Df    RSS Df Sum of Sq      F    Pr(&gt;F)    \n1    461 137.16                                  \n2    460 132.81  1    4.3467 15.056 0.0001196 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nSignificance Codes\n\n\n\n\n\nThe output from many base-R {stats} functions, like anova(), include a line labeled Signif. codes that provide a key for understanding the notation given for significance levels in p-values.\nReading the key from left to right, we can see that a result is given three asterisks (***) when the p-value is between 0 and .001; two asterisks between .001 and .01; and so on.\nThis can be a useful visual check, especially because p-values that are very, very small are frequently expressed in scientific notation, which can make them more difficult to spot.\n\n\n\nThe F-test is significant, indicating that the more complex two-predictor model is a significant improvement over the one-predictor model, so we will proceed with the two-predictor model.\n\n\nStandardised Bs\nYou may have noticed that the output we’ve seen so for only contains unstandardised model parameter estimates. If we want standardised Bs expressing the relationship between predictor(s) and outcome in standard deviation units, we can make use of the model_parameters() function from the {parameters} package to standardise our bs.\n\n\n\n\n\n\nExercise\n\n\n\nUse the standarize = \"refit\" argument in the parameters::model_parameters() function to obtain standardised Bs.\n\n\n\n\n\n\nWarning\n\n\n\nNote the spelling of standardize with a “z”! Spelling it with an “s” will not rescale the parameter estimates.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, standardize = \"refit\")\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        0.15 | 0.06 | [ 0.03,  0.27] |   2.53 | 0.012 \nbeauty          |        0.21 | 0.05 | [ 0.12,  0.30] |   4.65 | &lt; .001\ngender [female] |       -0.36 | 0.09 | [-0.54, -0.18] |  -3.88 | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a Wald t-distribution approximation.\n\n\n\n\n\n\n\n\n\n\nAssumptions Checks\nAt Sussex, we teach a range of model diagnostics and robust model sensitivity tests in order to test model assumptions. We will look briefly at each of these in turn.\n\n\n\n\n\n\nTip\n\n\n\nRemember, there are more examples and longer explanations in the discovr_08 tutorial!\n\n\n\nResidual Plots\nTo begin, we can generate nicely formatted, customisable residual plots using the function ggplot2::autoplot(). However, it is essential to load the {ggfortify} package in order for this to work!\n\n\n\n\n\n\nExercise\n\n\n\nLoad the {ggfortify} package and use the autoplot() function to generate residual plots for eval_full_lm. Set the which argument to c(1, 3, 2, 4).\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(ggfortify)\n\nWarning: package 'ggfortify' was built under R version 4.3.1\n\n\nLoading required package: ggplot2\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\nggplot2::autoplot(eval_full_lm, which = c(1, 3, 2, 4))\n\n\n\n\nIf you’re wondering what’s up with which, the plot() function that autoplot() is based on has a total of six plots available. Here I’ve chosen the two residual plots, the normal Q-Q and the Cook’s distance plot. Plots 5 and 6 have to do with leverage, which we don’t teach at UG level. To see them, simply add them to the which = argument.\n\n\n\n\n\nIf you want to customise the theme or look of these plots further, they are built with {ggplot2} so you can add or change anything about them using that package. We will come round to a detailed exploration of data visualisations with {ggplot2} in Tutorial 06.\n\n\nDistribution of Standardised Residuals\nIn the UG core statistics modules at Sussex, we teach that normality is the least important of the assumptions of the linear model - the most important being additivity and linearity - so we do not generally worry too much about normally distributed standardised residuals, especially in large sample sizes. However, we do teach them how to evaluate the proportion of standardised residuals with values above $$1.96 (approximately 5%), $$2.56 (approximately 1%), and above $$3 (likely an outlier). For details on how to use broom::augment() to obtain standardised residuals and other model diagnostic measures like Cook’s distance, see the discovr_08 tutorial.\n\n\nRobust Models\nAt UG level, we teach robust models for two purposes:\n\nAs sensitivity tests to check assumptions. If a robust technique that adjusts for a particular issue, such as heteroscedasticity, results in a model that is substantially different from the unadjusted model, we might conclude that the unadjusted model did in fact have that particular issue.\nAs robust alternatives to the unadjusted model.\n\n\nRobust Parameter Estimates\nOur first robust model re-estimates the parameter estimates using robust techniques withe the robust::lmRob() function. We can then compare the robust parameter estimates to the unadjusted ones obtained with lm() to find out if our estimates were biased, and report the robust parameter estimates if they were.\n\n\n\n\n\n\nExercise\n\n\n\nFit the same two-predictor model again with robust::lmRob() and compare the results to the unadjusted two-predictor model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\neval_lm_rob &lt;- robust::lmRob(eval ~ beauty + gender, data = teach_tib)\n\neval_lm_rob\n\n\nCall:\nrobust::lmRob(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.1044        0.1388       -0.2071  \n\neval_full_lm\n\n\nCall:\nlm(formula = eval ~ beauty + gender, data = teach_tib)\n\nCoefficients:\n (Intercept)        beauty  genderfemale  \n      4.0816        0.1486       -0.1978  \n\n\nComparing the values of the two versions of the model, we can see that the parameter estimates have changed very little, so we might conclude that the unadjusted model was fine.\n\n\n\n\n\n\n\nRobust CIs and p-values\nTo test and adjust for heteroscedastic residuals, we can re-estimate the standard error using a robust method. To do this, we’ll use the parameters::model_parameters() function with the argument vcov = \"HC4\" as recommended in the discovr tutorial. To do this, use the unadjusted model object eval_full_lm as the first argument.\n\n\n\n\n\n\nExercise\n\n\n\nUse parameters::model_parameters() to re-estimate the SEs, CIs, and p-values, and compare the results to the unadjusted model.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, vcov = \"HC4\")\n\nParameter       | Coefficient |   SE |         95% CI | t(460) |      p\n-----------------------------------------------------------------------\n(Intercept)     |        4.08 | 0.03 | [ 4.02,  4.15] | 125.28 | &lt; .001\nbeauty          |        0.15 | 0.03 | [ 0.08,  0.21] |   4.59 | &lt; .001\ngender [female] |       -0.20 | 0.05 | [-0.30, -0.10] |  -3.94 | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a Wald t-distribution approximation.\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nThe parameter estimates will not change, but the SEs, CIs, and p-values may. Here, the values are nearly identical and there are no major changes - that is, no predictors have become non-significant that were previously significant - so we might again conclude that the unadjusted model was not unduly biased.\n\n\n\n\n\n\n\nBootstrapping\nIf we had a small sample size, a final option would be to bootstrap the confidence intervals. To do this, we will again use parameters::model_parameters(), but this time with bootstrap = TRUE.\nNote: Sample size is not an issue with this dataset (N = 463).\n\n\n\n\n\n\nExercise\n\n\n\nProduce bootstrapped confidence intervals for the two-predictor model and compare to the unadjusted confidence intervals.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nparameters::model_parameters(eval_full_lm, bootstrap = TRUE)\n\nParameter       | Coefficient |         95% CI |      p\n-------------------------------------------------------\n(Intercept)     |        4.08 | [ 4.01,  4.14] | &lt; .001\nbeauty          |        0.15 | [ 0.08,  0.21] | &lt; .001\ngender [female] |       -0.20 | [-0.30, -0.10] | &lt; .001\n\n\n\nUncertainty intervals (equal-tailed) are naıve bootstrap intervals.\n\nbroom::tidy(eval_full_lm, conf.int = TRUE)\n\n# A tibble: 3 × 7\n  term         estimate std.error statistic    p.value conf.low conf.high\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)     4.08     0.0329    124.   0            4.02      4.15  \n2 beauty          0.149    0.0320      4.65 0.00000434   0.0858    0.211 \n3 genderfemale   -0.198    0.0510     -3.88 0.000120    -0.298    -0.0976\n\n\nWe could once again note that there are no major changes, as previously, so the evidence of our checks suggests that the original, unadjusted model was not unduly biased."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#quarto",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#quarto",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Quarto",
    "text": "Quarto\nQuarto documents are a mix of text and code, the next generation of R Markdown documents. For our purposes, we will be using R within Quarto, but Quarto documents support the integration of many different coding languages, including Python, Julia, and Observable. If you’ve previously used Rmd (RMarkdown), Quarto is backwards-compatible and will able to render most documents with no issues.\n\n\n\n\n\n\nHelp with Quarto\n\n\n\nThe official Quarto Guide is extensive, detailed, and extremely helpful. It’s always the best first stop for any questions you have about using Quarto. Quarto also offers detailed tutorials.\nThis quick-reference to Markdown formatting is particularly helpful.\nProf Andy Field has also recorded a series of video guides to using Quarto that are used in UG teaching.\n\n\n\nGetting Started\nTo get some hands-on practice working with Quarto, we will create a new Quarto document from scratch. We will use the analysis code we’ve already written to create a nicely formatted report.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new Quarto document via File &gt; New File &gt; Quarto Document.\nIf you like, you can give it a title; you will be able to change this later.\nThen, click “Create”.\n\n\nBy default, your new Quarto document will already have some settings and content to demonstrate how it works. Most importantly, you can see that there are three main types of information in this document:\n\nThe YAML header at the top, delineated by ---s, which contains information about how the document will be rendered\nThe body text, which contains regular (i.e. non-code) text\nThe code chunks, which contain code - in this case, specifically, R.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nTo complete our setup, take the following steps:\n\nDelete everything in the new Quarto document except for the YAML header (i.e. all the text and code chunks).\nClear your Environment by clicking the broom icon in the Environment tab.\nRestart your R session (via Session &gt; Restart R).\n\n\n\n\n\n\n\nWarning\n\n\n\nMake sure you have completed and saved your worksheet with all of your code before you do this!\n\n\n\n\n\n\n\n\n\n\nVisual vs Source Mode\n\n\n\n\n\nA new feature with Quarto is Visual mode, which is very like using Word or a similar word processing programme. All formatting can be applied and previewed in the document itself, using keyboard shortcuts or the familiar formatting buttons along the top toolbar.\nVisual mode also has an “insert anything” shortcut, /, that allows you to quickly insert elements into your document. If you type / at the start of a new line (or Ctrl/Cmd + / otherwise), a drop-down list of possible elements will appear, which you can navigate by scrolling or search by typing.\nAlternatively, you can toggle to Source mode by clicking the “Source” button at the very top left of the document pane. In Source mode you can edit the document using Markdown formatting. This allows more fine-tuned control of elements, but automatic formatting and the / shortcut don’t work in this mode.\nWhich you use is entirely personal preference - I toggle regularly between them depending on what I’m trying to do, so pick whichever works for you.\n\n\n\n\n\nCreating a Code Chunk\nTo prepare for our analysis, we will need a place to load packages and read in the data. Any executable code - that is, code that you want to run and do something - must be written in a code chunk and NOT in the body text2.\n\n\n\n\n\n\nInserting Code Chunks\n\n\n\nThere are several ways to insert a new code chunk.\n\nIn Visual mode, by typing / and then Enter (since “R Code Chunk” is the first option)\nIn either mode, by:\n\nClicking the green “insert code chunk” button in the top right\nTyping out the literal code fencing: ```{r} ```\nUsing a keyboard shortcut.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new code chunk and code that does the following:\n\nLoad all the packages we used in the previous Linear Model section\nRead in the dataset located in the data folder of your project into an object called teach_tib\nCreate the two objects containing the linear models with one predictor and with two predictors.\n\nThen, run the code chunk.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLoad packages:\nIn the previous section, we used the following packages:\n\n{tidyverse}, or specifically {broom}, for tidying up the linear model output\n{ggfortify} for creating diagnostic plots\n{parameters} for standardising bs, re-estimating CIs, and boostrapping\n{robust} for robust parameter estimates\n\nRead in the data:\nIn the Posit Cloud project workspace for this tutorial, there is a teaching.csv object. Look back on Tutorial 02 for more detail about how to read in datasets.\nCreate the models:\nCopy and paste the code from your workbook document, or from the previous sections of this tutorial. You can also find all of the commands you have run your History tab (next to Environment).\nAltogether, your new code chunk should look like this:\n```{r}\nlibrary(tidyverse)\nlibrary(ggfortify)\nlibrary(parameters)\nlibrary(robust)\n\nteach_tib &lt;- readr::read_csv(\"data/teaching_ratings.csv\")\n\neval_lm &lt;- lm(eval ~ beauty, data = teach_tib)\neval_full_lm &lt;- lm(eval ~ beauty + gender, data = teach_tib)\n```\nRun the code chunk by clicking the green “play” arrow, or by pressing Ctrl/Cmd + Shift + Enter while your cursor is inside the chunk.\n\n\n\n\n\n\n\nHeadings and Text\n\nHeadings\nTo begin, we’ll use headings to map out our document. Properly formatted headings are strongly recommended for any documents you write, for a variety of reasons:\n\nThey automatically create the outline (to the right) and navigation menu (to the bottom) of your document for easy navigation\nThey can be automatically converted into a table of contents\nThey are a crucial accessibility feature for navigating the document via keyboard/screenreader, as well as providing clear visual structure.\n\n\n\n\n\n\n\nInserting Headings\n\n\n\nThere are several ways to insert a new heading.\n\nIn Visual mode, by:\n\nUsing the text formatting dropdown. Click on “Normal” and select the heading level.\nUsing a keyboard shortcut, Ctrl + Alt + the number of the heading (e.g. 3 for a level 3 heading)\n\nIn either mode, by:\n\nTyping hashes at the start of a new line, followed by a space (e.g. ### creates a level 3 heading)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate 2-3 level 2 headings in your document for the brief report of the linear model. You can choose anything you like, but the three I will refer to will be called “Model Comparison” (constructing and comparing the two models), “Assumptions Checks”, and “The Final Model” (reporting the final model in full).\n\n\n\n\nBody Text\nAny new-line text will automatically be plain text. This can be anything you like, although in our current document, we are writing a mock-formal results section.\n\n\n\n\n\n\nFormatting Text\n\n\n\nHow to format body text depends on the mode you are in.\n\nIn Visual mode, by:\n\nUsing familiar keyboard shortcuts (e.g. Ctrl/Cmd + B for bold, Ctrl/Cmd + I for italics, etc.)\nUsing the formatting toolbar at the top of the document.\n\nIn Source mode, by using Markdown formatting.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUnder the first heading (which I have called “Model Comparison”), write a brief, journal-style description of the variables the two models contain.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf you aren’t inclined to write your own, here’s a brief sample text to use.\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (R2 = ???, F(???, ???) = ???, p = ???). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (R2 = ???, F(???, ???) = ???, p = ???). An ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(???, ???) = ???, p = ???).\n\n\n\n\n\n\n\n\n\nDynamic Reporting\nThat last sentence should report which of the two models was better, based on the result of our F-test, rather than question marks. We could produce the output of this test, read it ourselves with our very own eyes/ears, and then type out the results by hand…but that is definitely not what we are going to do! Instead, we’ll look at a couple options for reporting the results dynamically. (We’ll come back to the model R2s in a moment.)\n\nInline Code\nOur first option is to use inline code to report the numbers. In order to do this, we first need to know what information we have available in the test output, so we can make use of it.\n\n\n\n\n\n\nTip\n\n\n\nThis section will make extensive use of $ subsetting, which was covered in Tutorial 02, and [] subsetting, which was covered in Tutorial 01.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nIn a new code chunk, use the broom::tidy() function to get a nice tibble of the anova() comparison between the two models, and save it in a new object called tidy_f. Then, print out this object in the Console.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe are creating the tidy_f object in a code chunk because we will want to use it again in our report.\nWe are calling this object in the Console because viewing its contents is only for our information/reference, and not something we want to appear or use directly in our finished document.\n\n## In a code chunk\ntidy_f &lt;- broom::tidy(anova(eval_lm, eval_full_lm))\n\n## In the Console\ntidy_f\n\n# A tibble: 2 × 7\n  term                   df.residual   rss    df sumsq statistic   p.value\n  &lt;chr&gt;                        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 eval ~ beauty                  461  137.    NA NA         NA   NA       \n2 eval ~ beauty + gender         460  133.     1  4.35      15.1  0.000120\n\n\n\n\n\n\n\nThe tibble we get here is quite different from the “Analysis of Variance Table” text output that we saw earlier when we printed out the results of the anova() function on its own. We now have all the values we need to report these results in a conveniently subsettable tibble with nice R-friendly names.\nSo, let’s have a go getting at some of those values.\n\n\n\n\n\n\nExercise\n\n\n\nGet out the F-ratio of 15.0554899 from this object, and round it to two decimal places.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst, we need to get out the statistic variable, which we can do with $.\n\ntidy_f$statistic\n\n[1]       NA 15.05549\n\n\nThis returns a vector of two values, NA and 15.0554899. To index the second of these values, we need [] subsetting and the index number of the correct value.\n\ntidy_f$statistic[2]\n\n[1] 15.05549\n\n\nFinally, we can use the round() function to round to two decimal places.\n\nround(tidy_f$statistic[2], 2)\n\n[1] 15.06\n\n\n\n\n\n\n\nWe now have a bit of R code that produces a single number that we want to report in the text3. The issue is that code chunks contain code, and body text contains text, but we would like the code that we’ve written to print out its value in the text!\nThe solution is inline code, a small bit of R code written in the body text (“inline”) that will, when the document is rendered, automatically insert the right number. Inline code is written as follows, in the text: `r some_r_code`\nFor our reporting, we will need to insert the inline code in exactly the spot where we would like the output of the code to appear. This particular bit of code produces the F-statistic, so we can replace the “???”s in our reporting where the value of the F-statistic should go:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(???, ???) = `r round(tidy_f$statistic[2], 2)`, p = ???).\n\nYou can check whether this has worked in two ways:\n\nPlace your cursor inside the backticks and press Ctrl/Cmd + Enter, as you would inside a code chunk. This will run the code and a small pop-up will show you what that code will produce when rendered.\nRender your document and see what appears!\n\n\n\n\n\n\n\nExercise\n\n\n\nUse inline code to replace all of the ???s in the F-test reporting to produce a final report in APA style.\nHint: Rounding p-values is a bit tricky. Check out the {papaja} package to see if you can find a function besides round() that will produce the p-value with the correct formatting.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nAll of the other numbers should be straightforward, except for the p-value. Rounding to three decimal places with round() will result in a value of 0, which is not what we want. Instead, since the p-value is below .001, we want “&lt; .001”.\n{papaja} has the printp() function, which will do this exactly was we like (as well as containing a lot of other useful functions for rounding and printing in APA style!)\nYour final text may look like this:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(`r tidy_f$df[2]`, `r tidy_f$df.residual[2]`) = `r round(tidy_f$statistic[2], 2)`, p `r papaja::printp(tidy_f$p.value[2]`).\n\nNote that there’s no need for a “&lt;” symbol because papaja::printp() includes it automatically.\nThis will render as:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit for the second model compared to the first (F(1, 460) = 15.06, p &lt; .001).\n\n\n\n\nCHALLENGE: Create a bit of inline code that will either report a significant or non-significant result depending on the value of p.\nHint: You may need to check out the ifelse() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf we really want our reporting to be resilient, we want to remove or replace all the places where we have to manually remember to update the code if our results change. In this case, our reporting reads:\n\nAn ANOVA comparing the models indicated a significant improvement in model fit…\n\nBut if we wanted to reuse this code for another report, we would have to remember to update this depending on the actual value of p. OR, we can have R do it for us.\nFirst, we need to write a bit of R code that will evaluate whether the value of p is above or below a particular threshold, and then output the correct text. We could do this with ifelse(), a handy little base R function with three arguments. The first is a test returning a logical value (either TRUE or FALSE). If the test returns TRUE, the second argument is executed; if the test returns FALSE, the final argument is executed.\n\nifelse(\n1  tidy_f$p.value[2] &lt; .05,\n2  \"significant\",\n3  \"non-significant\"\n)\n\n\n1\n\nThe test: is the p-value for our F-test less than .05? (If you have a different \\(\\alpha\\)-threshold, you could hard-code it here or use an object you’ve defined previously for this comparison.)\n\n2\n\nWhat to do if the test returns TRUE: print “significant”.\n\n3\n\nWhat to do if the test returns FALSE: print “non-significant”.\n\n\n\n\n[1] \"significant\"\n\n\nWe can then take this command and replace the word “significant” in our report with this inline code:\n\nAn ANOVA comparing the models indicated a `r ifelse(tidy_f$p.value[2] &lt; .05, \"significant\", \"non-significant\")` improvement in model fit…\n\nNow we don’t have to worry about getting this right: our document, when rendered, will automatically insert the right word depending on the data.\n\n\n\n\n\n\n\nAutomatic Reporting\nAs helpful as inline code is (and I would recommend reporting all values dynamically/automatically wherever possible, so it is very useful!), you may have noticed that there was a lot of repetitive typing that also made the text itself quite difficult to read, as well lots of opportunities make typos or mistakes. Surely there’s a simpler way to do this sort of thing!\nThere are, in fact, many simpler ways to do common tasks like this, which take advantage of the fact that an object created by a particular function will always have the same structure. One option is to make further use of the {papaja} package, which is designed for just this purpose.\n\n\n\n\n\n\nExercise\n\n\n\nUse the {papaja} documentation to fill in the statistical reporting for each of the linear models (i.e., R2, F, and p) using only one piece of inline code for each.\nWhen you’re done, render your document to see the results!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe {papaja} documentation illustrates the process using t.test(), which works the same way as lm(). The key here is to use the original objects containing the models you want to report.\nLet’s have a look at the first of the two models and see what the papaja::apa_print() function gives us.\n\npapaja::apa_print(eval_lm)\n\n$estimate\n$estimate$Intercept\n[1] \"$b = 4.00$, 95\\\\% CI $[3.95, 4.05]$\"\n\n$estimate$beauty\n[1] \"$b = 0.13$, 95\\\\% CI $[0.07, 0.20]$\"\n\n$estimate$modelfit\n$estimate$modelfit$r2\n[1] \"$R^2 = .04$\"\n\n$estimate$modelfit$r2_adj\n[1] \"$R^2_{adj} = .03$\"\n\n$estimate$modelfit$aic\n[1] \"$\\\\mathrm{AIC} = 756.65$\"\n\n$estimate$modelfit$bic\n[1] \"$\\\\mathrm{BIC} = 769.06$\"\n\n\n\n$statistic\n$statistic$Intercept\n[1] \"$t(461) = 157.73$, $p &lt; .001$\"\n\n$statistic$beauty\n[1] \"$t(461) = 4.13$, $p &lt; .001$\"\n\n$statistic$modelfit\n$statistic$modelfit$r2\n[1] \"$F(1, 461) = 17.08$, $p &lt; .001$\"\n\n\n\n$full_result\n$full_result$Intercept\n[1] \"$b = 4.00$, 95\\\\% CI $[3.95, 4.05]$, $t(461) = 157.73$, $p &lt; .001$\"\n\n$full_result$beauty\n[1] \"$b = 0.13$, 95\\\\% CI $[0.07, 0.20]$, $t(461) = 4.13$, $p &lt; .001$\"\n\n$full_result$modelfit\n$full_result$modelfit$r2\n[1] \"$R^2 = .04$, $F(1, 461) = 17.08$, $p &lt; .001$\"\n\n\n\n$table\nA data.frame with 6 labelled columns:\n\n       term estimate     conf.int statistic  df p.value\n1 Intercept     4.00 [3.95, 4.05]    157.73 461  &lt; .001\n2    Beauty     0.13 [0.07, 0.20]      4.13 461  &lt; .001\n\nterm     : Predictor \nestimate : $b$ \nconf.int : 95\\\\% CI \nstatistic: $t$ \ndf       : $\\\\mathit{df}$ \np.value  : $p$ \nattr(,\"class\")\n[1] \"apa_results\" \"list\"       \n\n\nWe’ve got a huge number of options here, but for this exercise we wanted R2, F, and p. All three are given under $full_result$modelfit$r2. We will need to save the output from apa_print() into an object, then we can subset it using inline code:\n\neval_lm_out &lt;- papaja::apa_print(eval_lm)\neval_full_lm_out &lt;- papaja::apa_print(eval_full_lm)\n\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (`r eval_lm_out$full_result$modelfit$r2`). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (`r eval_full_lm_out$full_result$modelfit$r2`).\n\nWhich will render as:\n\nTwo linear models were constructed to investigate the influences on teaching evaluation ratings. The first model contained only instructor beauty ratings as a predictor, and teaching evaluation ratings as the outcome (\\(R^2 = .04\\), \\(F(1, 461) = 17.08\\), \\(p &lt; .001\\)). The second model added instructor gender as a second predictor with no interaction, both again predicting teaching evaluation ratings (\\(R^2 = .07\\), \\(F(2, 460) = 16.33\\), \\(p &lt; .001\\)).\n\n\n\n\n\n\n\n\nTable Formatting\nNext, we will jump to the “Final Model” heading and have a look at how to turn our final model output into a nicely formatted table. Once again, {papaja} provides a quick and beautiful solution for reporting, so let’s use it again.\n\n\n\n\n\n\nExercise\n\n\n\nUsing the {papaja} help documentation, produce a nicely formatted table of the final model, presenting the parameter estimates, p-values etc. for each predictor under the third (“Final Model”) heading.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe already have the necessary object, eval_full_lm_out, from the previous task. We just need to subset it as described in the help documentation.\nThis command should go in a new code chunk, wherever you want the table to appear in your document.\n\npapaja::apa_table(eval_full_lm_out$table)\n\n\n(#tab:unnamed-chunk-19)\n\n\nPredictor\n\\(b\\)\n95% CI\n\\(t\\)\n\\(\\mathit{df}\\)\n\\(p\\)\n\n\n\n\nIntercept\n4.08\n[4.02, 4.15]\n123.94\n460\n&lt; .001\n\n\nBeauty\n0.15\n[0.09, 0.21]\n4.65\n460\n&lt; .001\n\n\nGenderfemale\n-0.20\n[-0.30, -0.10]\n-3.88\n460\n&lt; .001\n\n\n\n\n\n\n\n\nCHALLENGE: {papaja} isn’t the only package to provide easy formatting for commonly reported tests. Have a go creating this table again using the nice_table() function from the {rempsyc} package, which allows a bit more flexibility in\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe nice_table() function can be for tables generally, but it can apply specialised formatting for model tables created with broom, if we use the broom = argument to tell the function what formatting template to apply.\n\nrempsyc::nice_table(broom::tidy(eval_full_lm, conf.int = TRUE), broom = \"lm\")\n\n\nTermbSEtp95% CI(Intercept)4.080.03123.94&lt; .001***[4.02, 4.15]beauty0.150.034.65&lt; .001***[0.09, 0.21]genderfemale-0.200.05-3.88&lt; .001***[-0.30, -0.10]\n\n\n\n\n\n\n\n\n\nCross-Referencing\nAs anyone who has had to create a long document with lots of tables and figures knows, keeping track of the numbering is a huge pain, especially when, for instance, a reviewer asks you to add something partway through and then everything has to be renumbered4.\nThe good news is that Quarto can take care of figure and table numbering automatically. There are two steps to this:\n\nInclude a label in the relevant code chunk, using the prefix fig- for figures and tbl- for tables.\nRefer to the figure or table in the text using @.\n\n\n\n\n\n\n\nExercises\n\n\n\nUsing the Quarto help documentation, write a short introductory sentence under the “Final Model” heading and refer to the final model table with a cross-reference.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirst, add a label and caption to the code chunk from the previous task that produces the model table.\n```{r}\n#| label: tbl-final-model\n#| tbl-cap: \"The final model predicting teaching evaluation ratings from instructor beauty and gender.\"\n\npapaja::apa_table(eval_full_lm_out$table,\n                  caption = \"The final model predicting teaching evaluation ratings from instructor beauty and gender.\")\n```\nYou can of course write whatever you like, or borrow the text below, but use “Table 1” (or whatever label your gave the table code chunk) to refer to the table.\n\nThe final model with two predictors is presented in full in @tbl-final-model.\n\nAltogether, it should render as follows:\n\nThe Final Model\nThe final model with two predictors is presented in full in Table 1.\n\n\npapaja::apa_table(eval_full_lm_out$table)\n\n\n\nTable 1: The final model predicting teaching evaluation ratings from instructor beauty and gender.\n\n\nPredictor\n\\(b\\)\n95% CI\n\\(t\\)\n\\(\\mathit{df}\\)\n\\(p\\)\n\n\n\n\nIntercept\n4.08\n[4.02, 4.15]\n123.94\n460\n&lt; .001\n\n\nBeauty\n0.15\n[0.09, 0.21]\n4.65\n460\n&lt; .001\n\n\nGenderfemale\n-0.20\n[-0.30, -0.10]\n-3.88\n460\n&lt; .001\n\n\n\n\n\n\n\n\n\nCHALLENGE: Complete the final “Assumptions Checks” section summarising the checks and using figure cross-referencing to insert and refer to the diagnostic plots.\nHint: To report the exact maximum value of Cook’s distance, you will also need to refer to discovr_08 for how to use broom::augment().\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou can write whatever you like, but here’s a suggestion with the plot included.\n\nAssumptions Checks\nWe next assessed the model with two predictors for any evidence of bias. Residual plots (@fig-diag-plots) did not indicate any outstanding issues with normality, linearity, or heteroscedasticity. There was also no evidence of influential cases, as the max value of Cook’s distance was `r round(max(broom::augment(eval_full_lm)$.cooksd), 2)`. Robust models were also fitted as sensitivity checks. Robust parameter estimates estimated using the {robust} package were minimally different from the unadjusted parameter estimates. Similarly, robust HC4 standard errors estimated using the {parameters} package yielded confidence intervals and p-values very similar to the unadjusted values. Therefore, we will proceed with the unadjusted two-predictor model as our final model.\n\n```{r}\n#| label: fig-diag-plots\n#| fig-cap: \"Diagnostic plots for the two-predictor model.\"\n\nggplot2::autoplot(eval_full_lm, which = c(1, 3, 2, 4))\n```\n\n\n\n\n\n\n\n\nRendering\nAfter all this work to analyse, interpret, and report, it’s finally time to produce the final document. The process of turning a Quarto document into some output format - including running all the code and applying all the formatting - is called rendering (previously knitting with RMarkdown).\n\n\n\n\n\n\nExercise\n\n\n\nRender your report document using the “Render” button at the top of the document, or by using the keyboard shortcut Ctrl/Cmd + Shift + K5.\n\n\n\nGlobal Options\nAt the moment, your report may not be as clean as we’d like it to be: there are likely messages from R floating around and code all over the place, whereas for a formal report, we of course only want to show the final output. This is where the YAML header comes in.\nThe default YAML header contains only a few explicit settings, and if you haven’t changed anything, probably looks like this:\n---\ntitle: \"Untitled\"\nformat: html\neditor: visual\n---\nBy adding options to the YAML header, we can determine how the document as a whole is rendered. Here are the common ones that I use on the regular:\n\n---\ntitle: \"Linear Model Report\"\nformat:\n  html:\n1    toc: true\neditor: visual\n2self-contained: true\n3execute:\n4  echo: false\n5  warning: false\n6  message: false\n---\n\n\n1\n\nAutomatically produce a table of contents (ToC) from the document headings.\n\n2\n\nCombine all the files, images, stylesheets etc. into a single output document. Necessary if you want to send an HTML file to someone else and have it look as it should!\n\n3\n\nSet default behaviour for all code chunks as follows\n\n4\n\nRun code and show output, but do not show the code itself.\n\n5\n\nDo not show any warnings produced by code.\n\n6\n\nDo not show any messages produced by code.\n\n\n\n\nThe requirements for each document will change depending on its purpose, so you will likely find that\n\n\n\n\n\n\nTip\n\n\n\nThe Quarto help documentation, as usual, has a complete list of YAML options, including how to set default behaviour for figures and other settings.\n\n\n\n\nCode Chunk Options\nGlobal options apply to the entire document, but you may want to change these settings for individual code chunks to override the default settings in the YAML.\nFor example, you may have a code chunk containing some processing code that you used to view and clean your data. If your global execution option is set to echo: false, the code output would still appear, although the code itself would be hidden. If, for this particular code chunk, you don’t want the output to appear either, you can override the global option with a local option for that chunk only.\nLocal code chunk options appear as “hashpipe” (#|) comments, as we have seen earlier with labels. They use the same syntax as YAML, but the settings only apply to individual code chunks. Any settings that aren’t explicitly changed within the chunk are inherited from the YAML settings.\nFor this example, we could set a local code chunk option include: false which will prevent the output from appearing in the document.6\n```{r}\n#| include: false\n\nsome_code_doing_cleaning_and_processing\n```\n\n\nOutput Formats\nFor these tutorials, we will generally stick to HTML, as it’s the most painless of the rendering options. However, you will likely find yourself wanting to produce some other type of document, which you can easily7 do from the same Quarto document.\nTo render to a different format, change the YAML format: setting to a different output.\n\n\n\n\n\n\nTip\n\n\n\nAs per, the Quarto guide on output formats has all the information you need!\n\n\n\n\n\n\n\n\nExercise\n\n\n\nRender your linear model report to a Word document.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSimply update the format: html YAML option to format: docx and render your document. Note that the format options are usually named after the file extension rather than the name of the programme necessarily."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#well-done",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#well-done",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Well done!",
    "text": "Well done!\nAnd there we have it! You now have a complete example of a linear model report, rendered into both HTML and Word, to refer to. It’s amazing how much you’re able to do after just a few weeks!\nThis is the end of the FundRmentals section of the course. If you’re so inclined, we’ll see you in the Essentials section, which will cover data wrangling and cleaning, and running and reporting many more statistical analyses."
  },
  {
    "objectID": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#footnotes",
    "href": "tutorials/psychrlogy/01_fundRmentals/03_lm.html#footnotes",
    "title": "03: Reporting Linear Models with Quarto",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSomewhat confusingly, this is not the function we teach UGs to perform ANOVAs! See discovr tutorials 11, 12, 15, and 16 for a detailed guide through the afex package for running linear models with categorical predictors.↩︎\nMostly true, except for inline code!↩︎\nGenerally, inline code should only ever produce a single value, otherwise the formatting can get interesting. This value, however, could longer than a single number, if you want to get creative with your dynamic reporting!↩︎\n↩︎\nIt seems obvious that this should be R instead of K, but remember this made perfect sense when it was called “knitting”!↩︎\nFor writing tutorials, I make extensive use of eval: false, which includes the code in the output but does not attempt to run the code. This allows me to write all kinds of nonsense code without R getting stroppy and throwing errors all of the place!↩︎\nDepends crucially on what you consider to be “easy”, especially when dealing with PDFs!↩︎"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/04_filter.html",
    "href": "tutorials/psychrlogy/02_essentials/04_filter.html",
    "title": "04: Filter and Select",
    "section": "",
    "text": "This tutorial covers two important dplyr functions: filter() and select(). Easy to confuse, filter() uses logical assertations to return a subset of rows (cases) in a dataset, while select() returns a subset of the columns (variables) in the dataset.\n\n\n\n\n\n\nTip\n\n\n\nTo remember which does which:\n\nfilter() works on rows, which starts with “r”, so it contains the letter “r”.\nselect() works on columns, which starts with “c”, so it contains the letter “c”.\n\n\n\n\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.3.1\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'tibble' was built under R version 4.3.1\n\n\nWarning: package 'tidyr' was built under R version 4.3.1\n\n\nWarning: package 'readr' was built under R version 4.3.1\n\n\nWarning: package 'purrr' was built under R version 4.3.1\n\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\n\nWarning: package 'stringr' was built under R version 4.3.1\n\n\nWarning: package 'forcats' was built under R version 4.3.1\n\n\nWarning: package 'lubridate' was built under R version 4.3.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/04_filter.html#overview",
    "href": "tutorials/psychrlogy/02_essentials/04_filter.html#overview",
    "title": "04: Filter and Select",
    "section": "",
    "text": "This tutorial covers two important dplyr functions: filter() and select(). Easy to confuse, filter() uses logical assertations to return a subset of rows (cases) in a dataset, while select() returns a subset of the columns (variables) in the dataset.\n\n\n\n\n\n\nTip\n\n\n\nTo remember which does which:\n\nfilter() works on rows, which starts with “r”, so it contains the letter “r”.\nselect() works on columns, which starts with “c”, so it contains the letter “c”.\n\n\n\n\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.3.1\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'tibble' was built under R version 4.3.1\n\n\nWarning: package 'tidyr' was built under R version 4.3.1\n\n\nWarning: package 'readr' was built under R version 4.3.1\n\n\nWarning: package 'purrr' was built under R version 4.3.1\n\n\nWarning: package 'dplyr' was built under R version 4.3.1\n\n\nWarning: package 'stringr' was built under R version 4.3.1\n\n\nWarning: package 'forcats' was built under R version 4.3.1\n\n\nWarning: package 'lubridate' was built under R version 4.3.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/04_filter.html#filter",
    "href": "tutorials/psychrlogy/02_essentials/04_filter.html#filter",
    "title": "04: Filter and Select",
    "section": "Filter",
    "text": "Filter\nThe filter() function’s primary job is to easily and transparently subset the rows within a dataset - in particular, a tibble. filter() takes one or more logical assertions and returns only the rows for which the assertion is TRUE. Columns are not affected by filter()`, only rows.\n\nBasic Structure\nTo make a single, straightforward change to a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::filter(\n    logical_assertion\n  )\n\n\nUsage\nlogical_assertion is a statement that returns logical values, just like the assertions we saw in the first tutorial. The rows where the assertion returns TRUE will be included in the output; those that return FALSE will not. Inside the filter() command, use the names of the variable in the piped dataset to create the logical assertions.\n\n\nExamples\nTo include:\n\nNumerical comparisons, dplyr::between()\n%in%, grepl()\nTASK: Filter on some example\n\n\n\n\n\n\n\nMultiple Conditions\n\nOR | and AND &\nComma defaults to AND\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Cleaning\n\nKeeping only people who consented\nFiltering by age\nDealing with missing data\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\n\n\n\n\nSolution"
  },
  {
    "objectID": "tutorials/psychrlogy/02_essentials/04_filter.html#select",
    "href": "tutorials/psychrlogy/02_essentials/04_filter.html#select",
    "title": "04: Filter and Select",
    "section": "Select",
    "text": "Select\nThe select() function is probably the most straightforward of the core {dplyr} functions. Its primary job is to easily and transparently subset the columns within a dataset - in particular, a tibble. Rows are not affected by select(), only columns.\n\nBasic Structure\nTo subset a tibble, use the general format:\n\nmy_tibble |&gt;\n  dplyr::select(\n    variable_to_keep, !variable_to_drop, \n    keep_this_one:through_this_one,\n    rename_variable = old_name,\n    variable_number\n  )\n\n\nUsage\n\nvariable_to_keep: Choose a variable to include in the output by including its name. Multiple variables can be selected separated by commas.\n!variable_to_drop: Drop a variable from the output by putting an exclamation mark (!) or a minus sign (-) in front of its name. Multiple variables can be dropped, separated by commas with a ! (or -) before each.\nkeep_this_one:through_this_one: Choose a range of variables to include in the output with a colon (:). All the variables between and including the two named will be selected (or dropped, with !(drop_this_one:through_this_one))\nrename_variable: Choose a variable to include in the output, but give it a new name.\nvariable_number: Choose a variable to include in the output by where it appears in the dataset, numbered left to right. For example, “2” will select the second column in the original dataset.\n\nColumns will appear in the output in the order they are selected in select(), so this function can also be used to reorder columns.\n\n\n\n&lt;tidyselect&gt;\nThe real power in select(), and in many other {tidyverse} functions, is in a system of helper functions and notations collectively called &lt;tidyselect&gt;. The overall goal of “&lt;tidyselect&gt; semantics” is to make selecting variables easy, efficient, and clear.\nThese helper functions can be combined with the selection methods above in any combination. Some very convenient options include:\n\neverything() for all columns\nstarts_with(), ends_with(), and contains() for selecting columns by name\nnum_range() for selecting columns with a shared prefix and numerical range, e.g. item_1, item_2, item_3 etc.\nall_of() and any_of() for selecting using character vectors\nwhere() for selecting with a function\nmatches() for selecting with regular expressions (not covered in this tutorial)\n\nRather than list examples of all the helper functions here, it’s best to just try them out for yourself!s\n\n\n\n\n\n\nExercises\n\n\n\nOpen the help documentation by running ?dplyr::select in the Console to see examples of how to use all of the &lt;tidyselect&gt; helper functions.\nSelect the columns that start with\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nSelect all of the columns that contain a score\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nSelect the first ten items of the C and D subscales\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nRedo the exercise from the previous section using &lt;tidyselect&gt; helpers.\n\n\n\nUsing Functions\nLet’s say we want to create a summary table of all of the numeric variables in our dataset. Before we can create our summary in the next tutorial, we may first want to produce a subset of our dataset that only contains numeric variables.\nTo do this, we can use the &lt;tidyselect&gt; helper function where(). This helper function lets us use any function that returns TRUE and FALSE to select columns. Essentially, we don’t have to select columns by name - we can use any criteria we want, as long as we have (or can create!) a function that expresses that criteria.\nEspecially helpful here is the is.*() family of functions in base R. This group of functions all have the same format, where the * is a stand-in for any type of data or object, e.g. is.logical(), is.numeric(), is.factor() etc. (The very useful is.na() that we’ve seen above is also a member of this family.) These functions work like a question about whatever you put into them - for example, is.numeric() can be read as, “Is (whatever’s in the brackets) numeric?”\n\n\n\n\n\n\nTip\n\n\n\nYou can quickly find all of the functions in this family by typing is. in the Console and pressing Tab.\n\n\nPutting these two together, we could accomplish the task of selecting only numeric variables as follows:\n\nmy_tibble |&gt; \n  dplyr::select(\n    where(is.numeric)\n  )\n\nThis command evaluates each column and determines whether they contain numeric data (TRUE) or not (FALSE), and only returns the columns that return TRUE.\n\n\n\n\n\n\nWarning\n\n\n\nThe following material in this section isn’t covered in the Practicum live workshops. It’s included here for reference because it’s extremely useful in real R analysis workflows, but it won’t be essential for any of the Practicum tasks.\n\n\nThe function in where() that determines which columns to keep doesn’t have to be an existing named function. Another option is to use a “purrr-style lambda” or formula (a phrase you may see in help documentation) to write our own criteria on the spot. What we are essentially doing is writing an ad-hoc function.\nFor example, let’s select all of the numeric variables that have a minimum value of 3:\n\nmy_tibble |&gt; \n  dplyr::select(\n    where(is.numeric & ~ min(.x, na.rm = TRUE) &gt;= 3)\n  )\n\nThe second of these criteria is one of these “purrr-style” formulae. Is has two components:\n\nThe ~ (apparently pronounced “twiddle”!) at the beginning, which is a shortcut for the longer function(x) ... notation for creating functions.\nThe .x, which is a placeholder for each of the variables that the function will be applied to.\n\nSo, this command can be read: “Take my tibble and select all the columns where the following is true: the data type is numeric and the minimum value in that column is greater than or equal to 3 (ignoring missing values).”\n\n\n\n\n\n\nOptional Exercises\n\n\n\n\n\n\n\n\n\nSolution"
  },
  {
    "objectID": "tutorials/index/quick_ref.html",
    "href": "tutorials/index/quick_ref.html",
    "title": "Quick Reference",
    "section": "",
    "text": "Looking for a function you can’t quite remember how to use? You’re in the right place! The table below is arranged alphabetically by function name, and the linked full name (including relevant package calls) will take you to the help documentation. 31b8e172-b470-440e-83d8-e6b185028602:dAB5AHAAZQA6AE8AQQBCAGwAQQBHAFkAQQBOAFEAQgBoAEEARABjAEEATgB3AEEAeQBBAEMAMABBAFoAQQBCAGsAQQBEAFkAQQBNAHcAQQB0AEEARABRAEEATgBnAEEAeQBBAEQASQBBAEwAUQBBADQAQQBEAFEAQQBZAGcAQgBtAEEAQwAwAEEAWQBRAEIAbQBBAEQARQBBAE8AUQBBADUAQQBEAFUAQQBZAFEAQQB4AEEARwBJAEEATQBnAEIAaQBBAEQAawBBAAoAcABvAHMAaQB0AGkAbwBuADoATQB3AEEAdwBBAEQAWQBBAAoAcAByAGUAZgBpAHgAOgAKAHMAbwB1AHIAYwBlADoAUABBAEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBJAEEAQgBqAEEARwB3AEEAWQBRAEIAegBBAEgATQBBAFAAUQBBAGkAQQBIAFEAQQBZAFEAQgBpAEEARwB3AEEAWgBRAEEAaQBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAdABBAEcARQBBAGMAZwBCAG4AQQBHAGsAQQBiAGcAQQB0AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AZwBBAGcAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEATwB3AEEAZwBBAEcAMABBAFkAUQBCAHkAQQBHAGMAQQBhAFEAQgB1AEEAQwAwAEEAYwBnAEIAcABBAEcAYwBBAGEAQQBCADAAQQBEAG8AQQBJAEEAQgBoAEEASABVAEEAZABBAEIAdgBBAEQAcwBBAEkAZwBBACsAQQBBAG8AQQBJAEEAQQA4AEEASABRAEEAYQBBAEIAbABBAEcARQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYQBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIARwBBAEgAVQBBAGIAZwBCAGoAQQBIAFEAQQBhAFEAQgB2AEEARwA0AEEASQBBAEIATwBBAEcARQBBAGIAUQBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYQBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBnAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAVABBAEIAcABBAEcANABBAGEAdwBBAGcAQQBIAFEAQQBiAHcAQQBnAEEARQBnAEEAWgBRAEIAcwBBAEgAQQBBAEkAQQBCAEUAQQBHADgAQQBZAHcAQgAxAEEARwAwAEEAWgBRAEIAdQBBAEgAUQBBAFkAUQBCADAAQQBHAGsAQQBiAHcAQgB1AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGEAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAZwBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFYAUQBCAHoAQQBHAFUAQQBaAEEAQQBnAEEARQBrAEEAYgBnAEEAdQBBAEMANABBAEwAZwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBnAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAGcAQQBaAFEAQgBoAEEARwBRAEEAUABnAEEASwBBAEQAdwBBAGQAQQBCAGkAQQBHADgAQQBaAEEAQgA1AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBZAHcAQgB5AEEARwA4AEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAEwAZwBCADAAQQBHAGsAQQBaAEEAQgA1AEEASABZAEEAWgBRAEIAeQBBAEgATQBBAFoAUQBBAHUAQQBHADgAQQBjAGcAQgBuAEEAQwA4AEEAYwBnAEIAbABBAEcAWQBBAFoAUQBCAHkAQQBHAFUAQQBiAGcAQgBqAEEARwBVAEEATAB3AEIAaABBAEcATQBBAGMAZwBCAHYAQQBIAE0AQQBjAHcAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAFEAQQBjAEEAQgBzAEEASABrAEEAYwBnAEEANgBBAEQAbwBBAFkAUQBCAGoAQQBIAEkAQQBiAHcAQgB6AEEASABNAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAYgBnAEIAdgBBAEgAWQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAegBBAEgAUQBBAFkAUQBCADAAQQBIAE0AQQBMAHcAQgBoAEEARwA0AEEAYgB3AEIAMgBBAEcARQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAaABBAEcANABBAGIAdwBCADIAQQBHAEUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEcARQBBAGMAQQBCAGgAQQBGADgAQQBjAEEAQgB5AEEARwBrAEEAYgBnAEIAMABBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgB5AEEARwBRAEEAYwBnAEIAeQBBAEMANABBAGEAUQBCAHYAQQBDADgAQQBjAEEAQgByAEEARwBjAEEATAB3AEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQB2AEEARwAwAEEAWQBRAEIAdQBBAEMAOABBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgB3AEEASABJAEEAYQBRAEIAdQBBAEgAUQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQA2AEEARABvAEEAWQBRAEIAdwBBAEcARQBBAFgAdwBCAHcAQQBIAEkAQQBhAFEAQgB1AEEASABRAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQATQBBAE8AZwBBAGcAQQBGAEkAQQBaAFEAQgB3AEEARwA4AEEAYwBnAEIAMABBAEcAawBBAGIAZwBCAG4AQQBDAEEAQQBUAEEAQgBwAEEARwA0AEEAWgBRAEIAaABBAEgASQBBAEkAQQBCAE4AQQBHADgAQQBaAEEAQgBsAEEARwB3AEEAYwB3AEEAZwBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBJAEEAQgBSAEEASABVAEEAWQBRAEIAeQBBAEgAUQBBAGIAdwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBjAEEAQgBoAEEARgA4AEEAZABBAEIAaABBAEcASQBBAGIAQQBCAGwAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBZAFEAQgB3AEEARwBFAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEANgBBAEQAbwBBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgAwAEEARwBFAEEAWQBnAEIAcwBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAFoAdwBCAG4AQQBIAEEAQQBiAEEAQgB2AEEASABRAEEATQBnAEEAdQBBAEgAUQBBAGEAUQBCAGsAQQBIAGsAQQBkAGcAQgBsAEEASABJAEEAYwB3AEIAbABBAEMANABBAGIAdwBCAHkAQQBHAGMAQQBMAHcAQgB5AEEARwBVAEEAWgBnAEIAbABBAEgASQBBAFoAUQBCAHUAQQBHAE0AQQBaAFEAQQB2AEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAGMAQQBaAHcAQgB3AEEARwB3AEEAYgB3AEIAMABBAEQASQBBAE8AZwBBADYAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEAYwBBAEIAcwBBAEcAOABBAGQAQQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWQB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAegBBAEQAbwBBAEkAQQBCAFMAQQBHAFUAQQBjAEEAQgB2AEEASABJAEEAZABBAEIAcABBAEcANABBAFoAdwBBAGcAQQBFAHcAQQBhAFEAQgB1AEEARwBVAEEAWQBRAEIAeQBBAEMAQQBBAFQAUQBCAHYAQQBHAFEAQQBaAFEAQgBzAEEASABNAEEASQBBAEIAMwBBAEcAawBBAGQAQQBCAG8AQQBDAEEAQQBVAFEAQgAxAEEARwBFAEEAYwBnAEIAMABBAEcAOABBAFAAQQBCAGkAQQBIAEkAQQBQAGcAQQB3AEEARABVAEEATwBnAEEAZwBBAEUAMABBAGQAUQBCADAAQQBHAEUAQQBkAEEAQgBsAEEAQwBBAEEAWQBRAEIAdQBBAEcAUQBBAEkAQQBCAFQAQQBIAFUAQQBiAFEAQgB0AEEARwBFAEEAYwBnAEIAcABBAEgATQBBAFoAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAEEAQgBoAEEASABNAEEAYwB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBCAHMAQQBHAEUAQQBjAHcAQgB6AEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBZAHcAQgBzAEEARwBFAEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAHcAQgB1AEEASABRAEEAWQBRAEIAcABBAEcANABBAGMAdwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAZABBAEIAcABBAEcAUQBBAGUAUQBCAHoAQQBHAFUAQQBiAEEAQgBsAEEARwBNAEEAZABBAEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgB5AEEASABRAEEAYwB3AEIAZgBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAGsAQQBIAEEAQQBiAEEAQgA1AEEASABJAEEATwBnAEEANgBBAEcATQBBAGIAdwBCAHUAQQBIAFEAQQBZAFEAQgBwAEEARwA0AEEAYwB3AEEAbwBBAEMAawBBAFAAQQBBAHYAQQBHAEUAQQBQAGcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAQQBBAE4AUQBBADYAQQBDAEEAQQBUAFEAQgAxAEEASABRAEEAWQBRAEIAMABBAEcAVQBBAEkAQQBCAGgAQQBHADQAQQBaAEEAQQBnAEEARgBNAEEAZABRAEIAdABBAEcAMABBAFkAUQBCAHkAQQBHAGsAQQBjAHcAQgBsAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAMQBBAEgAUQBBAGEAUQBCAHMAQQBIAE0AQQBMAHcAQgBrAEEARwBFAEEAZABBAEIAaABBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgB3AEIAcwBBAEcARQBBAGIAZwBCAGoAQQBHAFUAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAYwBBAFoAUQBCAHUAQQBHAFUAQQBjAGcAQgBwAEEARwBNAEEAYwB3AEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAG4AQQBHAHcAQQBZAFEAQgB1AEEARwBNAEEAWgBRAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwBJAEEAYwBnAEIAdgBBAEcAOABBAGIAUQBBADYAQQBEAG8AQQBaAHcAQgBzAEEARwBFAEEAYgBnAEIAagBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEgASQBBAFoAQQBCAHkAQQBIAEkAQQBMAGcAQgBwAEEARwA4AEEATAB3AEIAeQBBAEMAOABBAFkAZwBCAGgAQQBIAE0AQQBaAFEAQQB2AEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHMAQQBHAGsAQQBZAGcAQgB5AEEARwBFAEEAYwBnAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBQAEEAQgBpAEEASABJAEEAUABnAEEAdwBBAEQAUQBBAE8AZwBBAGcAQQBFAFkAQQBhAFEAQgBzAEEASABRAEEAWgBRAEIAeQBBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBADgAQQBHAEkAQQBjAGcAQQArAEEARABBAEEATgBRAEEANgBBAEMAQQBBAFQAUQBCADEAQQBIAFEAQQBZAFEAQgAwAEEARwBVAEEASQBBAEIAaABBAEcANABBAFoAQQBBAGcAQQBGAE0AQQBkAFEAQgB0AEEARwAwAEEAWQBRAEIAeQBBAEcAawBBAGMAdwBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBiAEEAQgB0AEEAQwBnAEEASwBRAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAHcAQQBZAFEAQQBnAEEARwBnAEEAYwBnAEIAbABBAEcAWQBBAFAAUQBBAGkAQQBHAGcAQQBkAEEAQgAwAEEASABBAEEAYwB3AEEANgBBAEMAOABBAEwAdwBCAHkAQQBHAFEAQQBjAGcAQgB5AEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAZwBBAHYAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdgBBAEcAdwBBAGIAUQBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcAdwBBAGIAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBBAEIAdABBAEYASQBBAGIAdwBCAGkAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHkAQQBHADgAQQBZAGcAQgAxAEEASABNAEEAZABBAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBiAEEAQgB0AEEARgBJAEEAYgB3AEIAaQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEcASQBBAGQAUQBCAHoAQQBIAFEAQQBPAGcAQQA2AEEARwB3AEEAYgBRAEIAUwBBAEcAOABBAFkAZwBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBRAEIAbABBAEcARQBBAGIAZwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBiAFEAQgBsAEEARwBFAEEAYgBnAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwAwAEEAWgBRAEIAaABBAEcANABBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB0AEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAFgAdwBCAHcAQQBHAEUAQQBjAGcAQgBoAEEARwAwAEEAWgBRAEIAMABBAEcAVQBBAGMAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAbABBAEcARQBBAGMAdwBCADUAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdQBBAEcAYwBBAGEAUQBCADAAQQBHAGcAQQBkAFEAQgBpAEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEYAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAE8AZwBBADYAQQBHADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAZgBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwA0AEEAYQBRAEIAagBBAEcAVQBBAFgAdwBCADAAQQBHAEUAQQBZAGcAQgBzAEEARwBVAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAEwAZwBCAHkAQQBHAFUAQQBiAFEAQgBwAEEAQwAwAEEAZABBAEIAbwBBAEcAVQBBAGMAZwBCAHAAQQBHAEUAQQBkAFEAQgBzAEEASABRAEEATABnAEIAagBBAEcAOABBAGIAUQBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAGcAQgBwAEEARwBNAEEAWgBRAEIAZgBBAEgAUQBBAFkAUQBCAGkAQQBHAHcAQQBaAFEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAE8AZwBBADYAQQBHADQAQQBhAFEAQgBqAEEARwBVAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEgAQQBBAGEAUQBCAGoAQQBHAHMAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAUQBBAGMAQQBCAHMAQQBIAGsAQQBjAGcAQQB1AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGQAZwBCAGwAQQBIAEkAQQBjAHcAQgBsAEEAQwA0AEEAYgB3AEIAeQBBAEcAYwBBAEwAdwBCAHkAQQBHAFUAQQBaAGcAQgBsAEEASABJAEEAWgBRAEIAdQBBAEcATQBBAFoAUQBBAHYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEASABJAEEAYgB3AEIAMQBBAEcANABBAFoAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBVAGcAQgB2AEEASABVAEEAYgBnAEIAawBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEgAVQBBAGIAZwBCAGsAQQBDAGcAQQBLAFEAQQA4AEEAQwA4AEEAWQBRAEEAKwBBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBNAEEAQQB4AEEARABvAEEASQBBAEIASgBBAEcANABBAGQAQQBCAFMAQQBHADgAQQBaAEEAQgAxAEEARwBNAEEAZABBAEIAcABBAEcAOABBAGIAZwBCAHoAQQBDAEEAQQBTAFEAQQA4AEEARwBJAEEAYwBnAEEAKwBBAEQAQQBBAE0AdwBBADYAQQBDAEEAQQBVAGcAQgBsAEEASABBAEEAYgB3AEIAeQBBAEgAUQBBAGEAUQBCAHUAQQBHAGMAQQBJAEEAQgBNAEEARwBrAEEAYgBnAEIAbABBAEcARQBBAGMAZwBBAGcAQQBFADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAegBBAEMAQQBBAGQAdwBCAHAAQQBIAFEAQQBhAEEAQQBnAEEARgBFAEEAZABRAEIAaABBAEgASQBBAGQAQQBCAHYAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBjAGcAQgB2AEEASABjAEEAVABRAEIAbABBAEcARQBBAGIAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBnAEEAdgBBAEcASQBBAFkAUQBCAHoAQQBHAFUAQQBMAHcAQgBqAEEARwA4AEEAYgBBAEIAVABBAEgAVQBBAGIAUQBCAHoAQQBDADQAQQBhAEEAQgAwAEEARwAwAEEAYgBBAEEAaQBBAEQANABBAGMAZwBCAHYAQQBIAGMAQQBUAFEAQgBsAEEARwBFAEEAYgBnAEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAegBBAEcAUQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABJAEEAWgBBAEIAeQBBAEgASQBBAEwAZwBCAHAAQQBHADgAQQBMAHcAQgB5AEEAQwA4AEEAYwB3AEIAMABBAEcARQBBAGQAQQBCAHoAQQBDADgAQQBjAHcAQgBrAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBjAHcAQgBrAEEAQwBnAEEASwBRAEEAOABBAEMAOABBAFkAUQBBACsAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB6AEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAWgBBAEIAdwBBAEcAdwBBAGUAUQBCAHkAQQBDADQAQQBkAEEAQgBwAEEARwBRAEEAZQBRAEIAMgBBAEcAVQBBAGMAZwBCAHoAQQBHAFUAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAE0AQQBaAFEAQgBzAEEARwBVAEEAWQB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAGMAZwBCAGsAQQBIAEkAQQBjAGcAQQB1AEEARwBrAEEAYgB3AEEAdgBBAEgASQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgAwAEEASABNAEEATAB3AEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAFEAQQBMAGcAQgAwAEEARwBVAEEAYwB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBIAFEAQQBhAFEAQgBrAEEASABrAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBHAGMAQQBaAFEAQgB1AEEARwBVAEEAYwBnAEIAcABBAEcATQBBAGMAdwBBAHUAQQBIAEkAQQBMAFEAQgBzAEEARwBrAEEAWQBnAEEAdQBBAEcAOABBAGMAZwBCAG4AQQBDADgAQQBjAGcAQgBsAEEARwBZAEEAWgBRAEIAeQBBAEcAVQBBAGIAZwBCAGoAQQBHAFUAQQBMAHcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWQBnAEIAeQBBAEcAOABBAGIAdwBCAHQAQQBEAG8AQQBPAGcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgAzAEEARwBnAEEAWgBRAEIAeQBBAEcAVQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAeQBBAEMAMABBAGIAQQBCAHAAQQBHAEkAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGQAdwBCAG8AQQBHAFUAQQBjAGcAQgBsAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBaAEEAQgB3AEEARwB3AEEAZQBRAEIAeQBBAEQAbwBBAE8AZwBCADMAQQBHAGcAQQBaAFEAQgB5AEEARwBVAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBpAEEARwA4AEEAWgBBAEIANQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBoAEEARwBJAEEAYgBBAEIAbABBAEQANABBAAoAcwB1AGYAZgBpAHgAOgA=:31b8e172-b470-440e-83d8-e6b185028602"
  },
  {
    "objectID": "tutorials/index/quick_ref.html#index-of-functions",
    "href": "tutorials/index/quick_ref.html#index-of-functions",
    "title": "Quick Reference",
    "section": "",
    "text": "Looking for a function you can’t quite remember how to use? You’re in the right place! The table below is arranged alphabetically by function name, and the linked full name (including relevant package calls) will take you to the help documentation. 31b8e172-b470-440e-83d8-e6b185028602:dAB5AHAAZQA6AE8AQQBCAGwAQQBHAFkAQQBOAFEAQgBoAEEARABjAEEATgB3AEEAeQBBAEMAMABBAFoAQQBCAGsAQQBEAFkAQQBNAHcAQQB0AEEARABRAEEATgBnAEEAeQBBAEQASQBBAEwAUQBBADQAQQBEAFEAQQBZAGcAQgBtAEEAQwAwAEEAWQBRAEIAbQBBAEQARQBBAE8AUQBBADUAQQBEAFUAQQBZAFEAQQB4AEEARwBJAEEATQBnAEIAaQBBAEQAawBBAAoAcABvAHMAaQB0AGkAbwBuADoATQB3AEEAdwBBAEQAWQBBAAoAcAByAGUAZgBpAHgAOgAKAHMAbwB1AHIAYwBlADoAUABBAEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBJAEEAQgBqAEEARwB3AEEAWQBRAEIAegBBAEgATQBBAFAAUQBBAGkAQQBIAFEAQQBZAFEAQgBpAEEARwB3AEEAWgBRAEEAaQBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAdABBAEcARQBBAGMAZwBCAG4AQQBHAGsAQQBiAGcAQQB0AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AZwBBAGcAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEATwB3AEEAZwBBAEcAMABBAFkAUQBCAHkAQQBHAGMAQQBhAFEAQgB1AEEAQwAwAEEAYwBnAEIAcABBAEcAYwBBAGEAQQBCADAAQQBEAG8AQQBJAEEAQgBoAEEASABVAEEAZABBAEIAdgBBAEQAcwBBAEkAZwBBACsAQQBBAG8AQQBJAEEAQQA4AEEASABRAEEAYQBBAEIAbABBAEcARQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYQBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIARwBBAEgAVQBBAGIAZwBCAGoAQQBIAFEAQQBhAFEAQgB2AEEARwA0AEEASQBBAEIATwBBAEcARQBBAGIAUQBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYQBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBnAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAVABBAEIAcABBAEcANABBAGEAdwBBAGcAQQBIAFEAQQBiAHcAQQBnAEEARQBnAEEAWgBRAEIAcwBBAEgAQQBBAEkAQQBCAEUAQQBHADgAQQBZAHcAQgAxAEEARwAwAEEAWgBRAEIAdQBBAEgAUQBBAFkAUQBCADAAQQBHAGsAQQBiAHcAQgB1AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGEAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAZwBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFYAUQBCAHoAQQBHAFUAQQBaAEEAQQBnAEEARQBrAEEAYgBnAEEAdQBBAEMANABBAEwAZwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBnAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAGcAQQBaAFEAQgBoAEEARwBRAEEAUABnAEEASwBBAEQAdwBBAGQAQQBCAGkAQQBHADgAQQBaAEEAQgA1AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBZAHcAQgB5AEEARwA4AEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAEwAZwBCADAAQQBHAGsAQQBaAEEAQgA1AEEASABZAEEAWgBRAEIAeQBBAEgATQBBAFoAUQBBAHUAQQBHADgAQQBjAGcAQgBuAEEAQwA4AEEAYwBnAEIAbABBAEcAWQBBAFoAUQBCAHkAQQBHAFUAQQBiAGcAQgBqAEEARwBVAEEATAB3AEIAaABBAEcATQBBAGMAZwBCAHYAQQBIAE0AQQBjAHcAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAFEAQQBjAEEAQgBzAEEASABrAEEAYwBnAEEANgBBAEQAbwBBAFkAUQBCAGoAQQBIAEkAQQBiAHcAQgB6AEEASABNAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAYgBnAEIAdgBBAEgAWQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAegBBAEgAUQBBAFkAUQBCADAAQQBIAE0AQQBMAHcAQgBoAEEARwA0AEEAYgB3AEIAMgBBAEcARQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAaABBAEcANABBAGIAdwBCADIAQQBHAEUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEcARQBBAGMAQQBCAGgAQQBGADgAQQBjAEEAQgB5AEEARwBrAEEAYgBnAEIAMABBAEMAZwBBAEsAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARAB3AEEAWQBRAEEAZwBBAEcAZwBBAGMAZwBCAGwAQQBHAFkAQQBQAFEAQQBpAEEARwBnAEEAZABBAEIAMABBAEgAQQBBAGMAdwBBADYAQQBDADgAQQBMAHcAQgB5AEEARwBRAEEAYwBnAEIAeQBBAEMANABBAGEAUQBCAHYAQQBDADgAQQBjAEEAQgByAEEARwBjAEEATAB3AEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQB2AEEARwAwAEEAWQBRAEIAdQBBAEMAOABBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgB3AEEASABJAEEAYQBRAEIAdQBBAEgAUQBBAEwAZwBCAG8AQQBIAFEAQQBiAFEAQgBzAEEAQwBJAEEAUABnAEIAdwBBAEcARQBBAGMAQQBCAGgAQQBHAG8AQQBZAFEAQQA2AEEARABvAEEAWQBRAEIAdwBBAEcARQBBAFgAdwBCAHcAQQBIAEkAQQBhAFEAQgB1AEEASABRAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQATQBBAE8AZwBBAGcAQQBGAEkAQQBaAFEAQgB3AEEARwA4AEEAYwBnAEIAMABBAEcAawBBAGIAZwBCAG4AQQBDAEEAQQBUAEEAQgBwAEEARwA0AEEAWgBRAEIAaABBAEgASQBBAEkAQQBCAE4AQQBHADgAQQBaAEEAQgBsAEEARwB3AEEAYwB3AEEAZwBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBJAEEAQgBSAEEASABVAEEAWQBRAEIAeQBBAEgAUQBBAGIAdwBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAEUAQQBjAEEAQgBoAEEARgA4AEEAZABBAEIAaABBAEcASQBBAGIAQQBCAGwAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBZAFEAQgB3AEEARwBFAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHcAQQBHAEUAQQBjAEEAQgBoAEEARwBvAEEAWQBRAEEANgBBAEQAbwBBAFkAUQBCAHcAQQBHAEUAQQBYAHcAQgAwAEEARwBFAEEAWQBnAEIAcwBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAFoAdwBCAG4AQQBIAEEAQQBiAEEAQgB2AEEASABRAEEATQBnAEEAdQBBAEgAUQBBAGEAUQBCAGsAQQBIAGsAQQBkAGcAQgBsAEEASABJAEEAYwB3AEIAbABBAEMANABBAGIAdwBCAHkAQQBHAGMAQQBMAHcAQgB5AEEARwBVAEEAWgBnAEIAbABBAEgASQBBAFoAUQBCAHUAQQBHAE0AQQBaAFEAQQB2AEEARwBFAEEAZABRAEIAMABBAEcAOABBAGMAQQBCAHMAQQBHADgAQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBHAGMAQQBaAHcAQgB3AEEARwB3AEEAYgB3AEIAMABBAEQASQBBAE8AZwBBADYAQQBHAEUAQQBkAFEAQgAwAEEARwA4AEEAYwBBAEIAcwBBAEcAOABBAGQAQQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWQB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAegBBAEQAbwBBAEkAQQBCAFMAQQBHAFUAQQBjAEEAQgB2AEEASABJAEEAZABBAEIAcABBAEcANABBAFoAdwBBAGcAQQBFAHcAQQBhAFEAQgB1AEEARwBVAEEAWQBRAEIAeQBBAEMAQQBBAFQAUQBCAHYAQQBHAFEAQQBaAFEAQgBzAEEASABNAEEASQBBAEIAMwBBAEcAawBBAGQAQQBCAG8AQQBDAEEAQQBVAFEAQgAxAEEARwBFAEEAYwBnAEIAMABBAEcAOABBAFAAQQBCAGkAQQBIAEkAQQBQAGcAQQB3AEEARABVAEEATwBnAEEAZwBBAEUAMABBAGQAUQBCADAAQQBHAEUAQQBkAEEAQgBsAEEAQwBBAEEAWQBRAEIAdQBBAEcAUQBBAEkAQQBCAFQAQQBIAFUAQQBiAFEAQgB0AEEARwBFAEEAYwBnAEIAcABBAEgATQBBAFoAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAEEAQgBoAEEASABNAEEAYwB3AEEAbwBBAEMAawBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQA4AEEARwBFAEEASQBBAEIAbwBBAEgASQBBAFoAUQBCAG0AQQBEADAAQQBJAGcAQgBvAEEASABRAEEAZABBAEIAdwBBAEgATQBBAE8AZwBBAHYAQQBDADgAQQBjAGcAQgBrAEEASABJAEEAYwBnAEEAdQBBAEcAawBBAGIAdwBBAHYAQQBIAEkAQQBMAHcAQgBpAEEARwBFAEEAYwB3AEIAbABBAEMAOABBAFkAdwBCAHMAQQBHAEUAQQBjAHcAQgB6AEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBZAHcAQgBzAEEARwBFAEEAYwB3AEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBHAE0AQQBiAHcAQgB1AEEASABRAEEAWQBRAEIAcABBAEcANABBAGMAdwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAZABBAEIAcABBAEcAUQBBAGUAUQBCAHoAQQBHAFUAQQBiAEEAQgBsAEEARwBNAEEAZABBAEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgB5AEEASABRAEEAYwB3AEIAZgBBAEgAYwBBAGEAUQBCADAAQQBHAGcAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAGsAQQBIAEEAQQBiAEEAQgA1AEEASABJAEEATwBnAEEANgBBAEcATQBBAGIAdwBCAHUAQQBIAFEAQQBZAFEAQgBwAEEARwA0AEEAYwB3AEEAbwBBAEMAawBBAFAAQQBBAHYAQQBHAEUAQQBQAGcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAQQBBAE4AUQBBADYAQQBDAEEAQQBUAFEAQgAxAEEASABRAEEAWQBRAEIAMABBAEcAVQBBAEkAQQBCAGgAQQBHADQAQQBaAEEAQQBnAEEARgBNAEEAZABRAEIAdABBAEcAMABBAFkAUQBCAHkAQQBHAGsAQQBjAHcAQgBsAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAMQBBAEgAUQBBAGEAUQBCAHMAQQBIAE0AQQBMAHcAQgBrAEEARwBFAEEAZABBAEIAaABBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWgBBAEIAaABBAEgAUQBBAFkAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAWgB3AEIAcwBBAEcARQBBAGIAZwBCAGoAQQBHAFUAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAYwBBAFoAUQBCAHUAQQBHAFUAQQBjAGcAQgBwAEEARwBNAEEAYwB3AEEAdQBBAEgASQBBAEwAUQBCAHMAQQBHAGsAQQBZAGcAQQB1AEEARwA4AEEAYwBnAEIAbgBBAEMAOABBAGMAZwBCAGwAQQBHAFkAQQBaAFEAQgB5AEEARwBVAEEAYgBnAEIAagBBAEcAVQBBAEwAdwBCAG4AQQBHAHcAQQBZAFEAQgB1AEEARwBNAEEAWgBRAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwBJAEEAYwBnAEIAdgBBAEcAOABBAGIAUQBBADYAQQBEAG8AQQBaAHcAQgBzAEEARwBFAEEAYgBnAEIAagBBAEcAVQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEgASQBBAFoAQQBCAHkAQQBIAEkAQQBMAGcAQgBwAEEARwA4AEEATAB3AEIAeQBBAEMAOABBAFkAZwBCAGgAQQBIAE0AQQBaAFEAQQB2AEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBMAGcAQgBvAEEASABRAEEAYgBRAEIAcwBBAEMASQBBAFAAZwBCAHMAQQBHAGsAQQBZAGcAQgB5AEEARwBFAEEAYwBnAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBQAEEAQgBpAEEASABJAEEAUABnAEEAdwBBAEQAUQBBAE8AZwBBAGcAQQBFAFkAQQBhAFEAQgBzAEEASABRAEEAWgBRAEIAeQBBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBADgAQQBHAEkAQQBjAGcAQQArAEEARABBAEEATgBRAEEANgBBAEMAQQBBAFQAUQBCADEAQQBIAFEAQQBZAFEAQgAwAEEARwBVAEEASQBBAEIAaABBAEcANABBAFoAQQBBAGcAQQBGAE0AQQBkAFEAQgB0AEEARwAwAEEAWQBRAEIAeQBBAEcAawBBAGMAdwBCAGwAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBiAEEAQgB0AEEAQwBnAEEASwBRAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAHcAQQBZAFEAQQBnAEEARwBnAEEAYwBnAEIAbABBAEcAWQBBAFAAUQBBAGkAQQBHAGcAQQBkAEEAQgAwAEEASABBAEEAYwB3AEEANgBBAEMAOABBAEwAdwBCAHkAQQBHAFEAQQBjAGcAQgB5AEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAZwBBAHYAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdgBBAEcAdwBBAGIAUQBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEcAdwBBAGIAUQBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBBAEIAdABBAEYASQBBAGIAdwBCAGkAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBBAEIAcgBBAEcAYwBBAEwAdwBCAHkAQQBHADgAQQBZAGcAQgAxAEEASABNAEEAZABBAEEAdgBBAEcAMABBAFkAUQBCAHUAQQBDADgAQQBiAEEAQgB0AEEARgBJAEEAYgB3AEIAaQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEcASQBBAGQAUQBCAHoAQQBIAFEAQQBPAGcAQQA2AEEARwB3AEEAYgBRAEIAUwBBAEcAOABBAFkAZwBBAG8AQQBDAGsAQQBQAEEAQQB2AEEARwBFAEEAUABnAEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBEAEEAQQBNAHcAQQA2AEEAQwBBAEEAVQBnAEIAbABBAEgAQQBBAGIAdwBCAHkAQQBIAFEAQQBhAFEAQgB1AEEARwBjAEEASQBBAEIATQBBAEcAawBBAGIAZwBCAGwAQQBHAEUAQQBjAGcAQQBnAEEARQAwAEEAYgB3AEIAawBBAEcAVQBBAGIAQQBCAHoAQQBDAEEAQQBkAHcAQgBwAEEASABRAEEAYQBBAEEAZwBBAEYARQBBAGQAUQBCAGgAQQBIAEkAQQBkAEEAQgB2AEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEATAB3AEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAYgBRAEIAbABBAEcARQBBAGIAZwBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBiAFEAQgBsAEEARwBFAEEAYgBnAEEAdQBBAEcAZwBBAGQAQQBCAHQAQQBHAHcAQQBJAGcAQQArAEEARwAwAEEAWgBRAEIAaABBAEcANABBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAEUAQQBPAGcAQQBnAEEARQBrAEEAYgBnAEIAMABBAEYASQBBAGIAdwBCAGsAQQBIAFUAQQBZAHcAQgAwAEEARwBrAEEAYgB3AEIAdQBBAEgATQBBAEkAQQBCAEoAQQBEAHcAQQBZAGcAQgB5AEEARAA0AEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB0AEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAFgAdwBCAHcAQQBHAEUAQQBjAGcAQgBoAEEARwAwAEEAWgBRAEIAMABBAEcAVQBBAGMAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAbABBAEcARQBBAGMAdwBCADUAQQBIAE0AQQBkAEEAQgBoAEEASABRAEEAYwB3AEEAdQBBAEcAYwBBAGEAUQBCADAAQQBHAGcAQQBkAFEAQgBpAEEAQwA0AEEAYQBRAEIAdgBBAEMAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEYAOABBAGMAQQBCAGgAQQBIAEkAQQBZAFEAQgB0AEEARwBVAEEAZABBAEIAbABBAEgASQBBAGMAdwBBAHUAQQBHAGcAQQBkAEEAQgB0AEEARwB3AEEASQBnAEEAKwBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAE8AZwBBADYAQQBHADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAZgBBAEgAQQBBAFkAUQBCAHkAQQBHAEUAQQBiAFEAQgBsAEEASABRAEEAWgBRAEIAeQBBAEgATQBBAEsAQQBBAHAAQQBEAHcAQQBMAHcAQgBoAEEARAA0AEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBAHcAQQBEAE0AQQBPAGcAQQBnAEEARgBJAEEAWgBRAEIAdwBBAEcAOABBAGMAZwBCADAAQQBHAGsAQQBiAGcAQgBuAEEAQwBBAEEAVABBAEIAcABBAEcANABBAFoAUQBCAGgAQQBIAEkAQQBJAEEAQgBOAEEARwA4AEEAWgBBAEIAbABBAEcAdwBBAGMAdwBBAGcAQQBIAGMAQQBhAFEAQgAwAEEARwBnAEEASQBBAEIAUgBBAEgAVQBBAFkAUQBCAHkAQQBIAFEAQQBiAHcAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEARwA0AEEAYQBRAEIAagBBAEcAVQBBAFgAdwBCADAAQQBHAEUAQQBZAGcAQgBzAEEARwBVAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAEwAZwBCAHkAQQBHAFUAQQBiAFEAQgBwAEEAQwAwAEEAZABBAEIAbwBBAEcAVQBBAGMAZwBCAHAAQQBHAEUAQQBkAFEAQgBzAEEASABRAEEATABnAEIAagBBAEcAOABBAGIAUQBBAHYAQQBIAEkAQQBaAFEAQgBtAEEARwBVAEEAYwBnAEIAbABBAEcANABBAFkAdwBCAGwAQQBDADgAQQBiAGcAQgBwAEEARwBNAEEAWgBRAEIAZgBBAEgAUQBBAFkAUQBCAGkAQQBHAHcAQQBaAFEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAEkAQQBaAFEAQgB0AEEASABBAEEAYwB3AEIANQBBAEcATQBBAE8AZwBBADYAQQBHADQAQQBhAFEAQgBqAEEARwBVAEEAWAB3AEIAMABBAEcARQBBAFkAZwBCAHMAQQBHAFUAQQBLAEEAQQBwAEEARAB3AEEATAB3AEIAaABBAEQANABBAEkAQQBBADgAQQBDADgAQQBkAEEAQgBrAEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQQB3AEEARABNAEEATwBnAEEAZwBBAEYASQBBAFoAUQBCAHcAQQBHADgAQQBjAGcAQgAwAEEARwBrAEEAYgBnAEIAbgBBAEMAQQBBAFQAQQBCAHAAQQBHADQAQQBaAFEAQgBoAEEASABJAEEASQBBAEIATgBBAEcAOABBAFoAQQBCAGwAQQBHAHcAQQBjAHcAQQBnAEEASABjAEEAYQBRAEIAMABBAEcAZwBBAEkAQQBCAFIAQQBIAFUAQQBZAFEAQgB5AEEASABRAEEAYgB3AEEAZwBBAEQAdwBBAEwAdwBCADAAQQBHAFEAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAHkAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEIAMABBAEgASQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEgAQQBBAGEAUQBCAGoAQQBHAHMAQQBLAEEAQQBwAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAFAAQQBCAGgAQQBDAEEAQQBhAEEAQgB5AEEARwBVAEEAWgBnAEEAOQBBAEMASQBBAGEAQQBCADAAQQBIAFEAQQBjAEEAQgB6AEEARABvAEEATAB3AEEAdgBBAEcAUQBBAGMAQQBCAHMAQQBIAGsAQQBjAGcAQQB1AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGQAZwBCAGwAQQBIAEkAQQBjAHcAQgBsAEEAQwA0AEEAYgB3AEIAeQBBAEcAYwBBAEwAdwBCAHkAQQBHAFUAQQBaAGcAQgBsAEEASABJAEEAWgBRAEIAdQBBAEcATQBBAFoAUQBBAHYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAEEAQQBhAFEAQgBqAEEARwBzAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgBrAEEAQwBBAEEAYwB3AEIAMABBAEgAawBBAGIAQQBCAGwAQQBEADAAQQBJAGcAQgAwAEEARwBVAEEAZQBBAEIAMABBAEMAMABBAFkAUQBCAHMAQQBHAGsAQQBaAHcAQgB1AEEARABvAEEAYgBBAEIAbABBAEcAWQBBAGQAQQBBADcAQQBDAEkAQQBQAGcAQQBnAEEASABJAEEAYgB3AEIAMQBBAEcANABBAFoAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAYwBnAEIAawBBAEgASQBBAGMAZwBBAHUAQQBHAGsAQQBiAHcAQQB2AEEASABJAEEATAB3AEIAaQBBAEcARQBBAGMAdwBCAGwAQQBDADgAQQBVAGcAQgB2AEEASABVAEEAYgBnAEIAawBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAYwBnAEIAdgBBAEgAVQBBAGIAZwBCAGsAQQBDAGcAQQBLAFEAQQA4AEEAQwA4AEEAWQBRAEEAKwBBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBNAEEAQQB4AEEARABvAEEASQBBAEIASgBBAEcANABBAGQAQQBCAFMAQQBHADgAQQBaAEEAQgAxAEEARwBNAEEAZABBAEIAcABBAEcAOABBAGIAZwBCAHoAQQBDAEEAQQBTAFEAQQA4AEEARwBJAEEAYwBnAEEAKwBBAEQAQQBBAE0AdwBBADYAQQBDAEEAQQBVAGcAQgBsAEEASABBAEEAYgB3AEIAeQBBAEgAUQBBAGEAUQBCAHUAQQBHAGMAQQBJAEEAQgBNAEEARwBrAEEAYgBnAEIAbABBAEcARQBBAGMAZwBBAGcAQQBFADAAQQBiAHcAQgBrAEEARwBVAEEAYgBBAEIAegBBAEMAQQBBAGQAdwBCAHAAQQBIAFEAQQBhAEEAQQBnAEEARgBFAEEAZABRAEIAaABBAEgASQBBAGQAQQBCAHYAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEASABJAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBjAGcAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBjAGcAQgB2AEEASABjAEEAVABRAEIAbABBAEcARQBBAGIAZwBCAHoAQQBDAGcAQQBLAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAawBBAEMAQQBBAGMAdwBCADAAQQBIAGsAQQBiAEEAQgBsAEEARAAwAEEASQBnAEIAMABBAEcAVQBBAGUAQQBCADAAQQBDADAAQQBZAFEAQgBzAEEARwBrAEEAWgB3AEIAdQBBAEQAbwBBAGIAQQBCAGwAQQBHAFkAQQBkAEEAQQA3AEEAQwBJAEEAUABnAEEAZwBBAEQAdwBBAFkAUQBBAGcAQQBHAGcAQQBjAGcAQgBsAEEARwBZAEEAUABRAEEAaQBBAEcAZwBBAGQAQQBCADAAQQBIAEEAQQBjAHcAQQA2AEEAQwA4AEEATAB3AEIAeQBBAEcAUQBBAGMAZwBCAHkAQQBDADQAQQBhAFEAQgB2AEEAQwA4AEEAYwBnAEEAdgBBAEcASQBBAFkAUQBCAHoAQQBHAFUAQQBMAHcAQgBqAEEARwA4AEEAYgBBAEIAVABBAEgAVQBBAGIAUQBCAHoAQQBDADQAQQBhAEEAQgAwAEEARwAwAEEAYgBBAEEAaQBBAEQANABBAGMAZwBCAHYAQQBIAGMAQQBUAFEAQgBsAEEARwBFAEEAYgBnAEIAegBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAegBBAEcAUQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABJAEEAWgBBAEIAeQBBAEgASQBBAEwAZwBCAHAAQQBHADgAQQBMAHcAQgB5AEEAQwA4AEEAYwB3AEIAMABBAEcARQBBAGQAQQBCAHoAQQBDADgAQQBjAHcAQgBrAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBjAHcAQgBrAEEAQwBnAEEASwBRAEEAOABBAEMAOABBAFkAUQBBACsAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEATQBBAEEAMQBBAEQAbwBBAEkAQQBCAE4AQQBIAFUAQQBkAEEAQgBoAEEASABRAEEAWgBRAEEAZwBBAEcARQBBAGIAZwBCAGsAQQBDAEEAQQBVAHcAQgAxAEEARwAwAEEAYgBRAEIAaABBAEgASQBBAGEAUQBCAHoAQQBHAFUAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgB6AEEARwBVAEEAYgBBAEIAbABBAEcATQBBAGQAQQBBAG8AQQBDAGsAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAOABBAEcARQBBAEkAQQBCAG8AQQBIAEkAQQBaAFEAQgBtAEEARAAwAEEASQBnAEIAbwBBAEgAUQBBAGQAQQBCAHcAQQBIAE0AQQBPAGcAQQB2AEEAQwA4AEEAWgBBAEIAdwBBAEcAdwBBAGUAUQBCAHkAQQBDADQAQQBkAEEAQgBwAEEARwBRAEEAZQBRAEIAMgBBAEcAVQBBAGMAZwBCAHoAQQBHAFUAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAbwBBAEgAUQBBAGIAUQBCAHMAQQBDAEkAQQBQAGcAQgBrAEEASABBAEEAYgBBAEIANQBBAEgASQBBAE8AZwBBADYAQQBIAE0AQQBaAFEAQgBzAEEARwBVAEEAWQB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBADEAQQBEAG8AQQBJAEEAQgBOAEEASABVAEEAZABBAEIAaABBAEgAUQBBAFoAUQBBAGcAQQBHAEUAQQBiAGcAQgBrAEEAQwBBAEEAVQB3AEIAMQBBAEcAMABBAGIAUQBCAGgAQQBIAEkAQQBhAFEAQgB6AEEARwBVAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAGMAZwBBACsAQQBBAG8AQQBJAEEAQQBnAEEARAB3AEEAZABBAEIAeQBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQBvAEEAQwBrAEEASQBBAEEAOABBAEMAOABBAGQAQQBCAGsAQQBEADQAQQBDAGcAQQBnAEEAQwBBAEEASQBBAEEAOABBAEgAUQBBAFoAQQBBAGcAQQBIAE0AQQBkAEEAQgA1AEEARwB3AEEAWgBRAEEAOQBBAEMASQBBAGQAQQBCAGwAQQBIAGcAQQBkAEEAQQB0AEEARwBFAEEAYgBBAEIAcABBAEcAYwBBAGIAZwBBADYAQQBHAHcAQQBaAFEAQgBtAEEASABRAEEATwB3AEEAaQBBAEQANABBAEkAQQBBADgAQQBHAEUAQQBJAEEAQgBvAEEASABJAEEAWgBRAEIAbQBBAEQAMABBAEkAZwBCAG8AQQBIAFEAQQBkAEEAQgB3AEEASABNAEEATwBnAEEAdgBBAEMAOABBAGMAZwBCAGsAQQBIAEkAQQBjAGcAQQB1AEEARwBrAEEAYgB3AEEAdgBBAEgASQBBAEwAdwBCAHoAQQBIAFEAQQBZAFEAQgAwAEEASABNAEEATAB3AEIAMABBAEMANABBAGQAQQBCAGwAQQBIAE0AQQBkAEEAQQB1AEEARwBnAEEAZABBAEIAdABBAEcAdwBBAEkAZwBBACsAQQBIAFEAQQBMAGcAQgAwAEEARwBVAEEAYwB3AEIAMABBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHgAQQBEAG8AQQBJAEEAQgBKAEEARwA0AEEAZABBAEIAUwBBAEcAOABBAFoAQQBCADEAQQBHAE0AQQBkAEEAQgBwAEEARwA4AEEAYgBnAEIAegBBAEMAQQBBAFMAUQBBAGcAQQBEAHcAQQBMAHcAQgAwAEEARwBRAEEAUABnAEEASwBBAEMAQQBBAEkAQQBBADgAQQBDADgAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBIAEkAQQBQAGcAQQBLAEEAQwBBAEEASQBBAEEAZwBBAEQAdwBBAGQAQQBCAGsAQQBDAEEAQQBjAHcAQgAwAEEASABrAEEAYgBBAEIAbABBAEQAMABBAEkAZwBCADAAQQBHAFUAQQBlAEEAQgAwAEEAQwAwAEEAWQBRAEIAcwBBAEcAawBBAFoAdwBCAHUAQQBEAG8AQQBiAEEAQgBsAEEARwBZAEEAZABBAEEANwBBAEMASQBBAFAAZwBBAGcAQQBIAFEAQQBhAFEAQgBrAEEASABrAEEASwBBAEEAcABBAEMAQQBBAFAAQQBBAHYAQQBIAFEAQQBaAEEAQQArAEEAQQBvAEEASQBBAEEAZwBBAEMAQQBBAFAAQQBCADAAQQBHAFEAQQBJAEEAQgB6AEEASABRAEEAZQBRAEIAcwBBAEcAVQBBAFAAUQBBAGkAQQBIAFEAQQBaAFEAQgA0AEEASABRAEEATABRAEIAaABBAEcAdwBBAGEAUQBCAG4AQQBHADQAQQBPAGcAQgBzAEEARwBVAEEAWgBnAEIAMABBAEQAcwBBAEkAZwBBACsAQQBDAEEAQQBQAEEAQgBoAEEAQwBBAEEAYQBBAEIAeQBBAEcAVQBBAFoAZwBBADkAQQBDAEkAQQBhAEEAQgAwAEEASABRAEEAYwBBAEIAegBBAEQAbwBBAEwAdwBBAHYAQQBHAGMAQQBaAFEAQgB1AEEARwBVAEEAYwBnAEIAcABBAEcATQBBAGMAdwBBAHUAQQBIAEkAQQBMAFEAQgBzAEEARwBrAEEAWQBnAEEAdQBBAEcAOABBAGMAZwBCAG4AQQBDADgAQQBjAGcAQgBsAEEARwBZAEEAWgBRAEIAeQBBAEcAVQBBAGIAZwBCAGoAQQBHAFUAQQBMAHcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMANABBAGEAQQBCADAAQQBHADAAQQBiAEEAQQBpAEEARAA0AEEAWQBnAEIAeQBBAEcAOABBAGIAdwBCAHQAQQBEAG8AQQBPAGcAQgAwAEEARwBrAEEAWgBBAEIANQBBAEMAZwBBAEsAUQBBADgAQQBDADgAQQBZAFEAQQArAEEAQwBBAEEAUABBAEEAdgBBAEgAUQBBAFoAQQBBACsAQQBBAG8AQQBJAEEAQQBnAEEAQwBBAEEAUABBAEIAMABBAEcAUQBBAEkAQQBCAHoAQQBIAFEAQQBlAFEAQgBzAEEARwBVAEEAUABRAEEAaQBBAEgAUQBBAFoAUQBCADQAQQBIAFEAQQBMAFEAQgBoAEEARwB3AEEAYQBRAEIAbgBBAEcANABBAE8AZwBCAHMAQQBHAFUAQQBaAGcAQgAwAEEARABzAEEASQBnAEEAKwBBAEMAQQBBAE0AQQBBAHoAQQBEAG8AQQBJAEEAQgBTAEEARwBVAEEAYwBBAEIAdgBBAEgASQBBAGQAQQBCAHAAQQBHADQAQQBaAHcAQQBnAEEARQB3AEEAYQBRAEIAdQBBAEcAVQBBAFkAUQBCAHkAQQBDAEEAQQBUAFEAQgB2AEEARwBRAEEAWgBRAEIAcwBBAEgATQBBAEkAQQBCADMAQQBHAGsAQQBkAEEAQgBvAEEAQwBBAEEAVQBRAEIAMQBBAEcARQBBAGMAZwBCADAAQQBHADgAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAYwBnAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBEAHcAQQBkAEEAQgB5AEEARAA0AEEAQwBnAEEAZwBBAEMAQQBBAEkAQQBBADgAQQBIAFEAQQBaAEEAQQBnAEEASABNAEEAZABBAEIANQBBAEcAdwBBAFoAUQBBADkAQQBDAEkAQQBkAEEAQgBsAEEASABnAEEAZABBAEEAdABBAEcARQBBAGIAQQBCAHAAQQBHAGMAQQBiAGcAQQA2AEEARwB3AEEAWgBRAEIAbQBBAEgAUQBBAE8AdwBBAGkAQQBEADQAQQBJAEEAQgAzAEEARwBnAEEAWgBRAEIAeQBBAEcAVQBBAEsAQQBBAHAAQQBDAEEAQQBQAEEAQQB2AEEASABRAEEAWgBBAEEAKwBBAEEAbwBBAEkAQQBBAGcAQQBDAEEAQQBQAEEAQgAwAEEARwBRAEEASQBBAEIAegBBAEgAUQBBAGUAUQBCAHMAQQBHAFUAQQBQAFEAQQBpAEEASABRAEEAWgBRAEIANABBAEgAUQBBAEwAUQBCAGgAQQBHAHcAQQBhAFEAQgBuAEEARwA0AEEATwBnAEIAcwBBAEcAVQBBAFoAZwBCADAAQQBEAHMAQQBJAGcAQQArAEEAQwBBAEEAUABBAEIAaABBAEMAQQBBAGEAQQBCAHkAQQBHAFUAQQBaAGcAQQA5AEEAQwBJAEEAYQBBAEIAMABBAEgAUQBBAGMAQQBCAHoAQQBEAG8AQQBMAHcAQQB2AEEASABRAEEAYQBRAEIAawBBAEgAawBBAGMAdwBCAGwAQQBHAHcAQQBaAFEAQgBqAEEASABRAEEATABnAEIAeQBBAEMAMABBAGIAQQBCAHAAQQBHAEkAQQBMAGcAQgB2AEEASABJAEEAWgB3AEEAdgBBAEgASQBBAFoAUQBCAG0AQQBHAFUAQQBjAGcAQgBsAEEARwA0AEEAWQB3AEIAbABBAEMAOABBAGQAdwBCAG8AQQBHAFUAQQBjAGcAQgBsAEEAQwA0AEEAYQBBAEIAMABBAEcAMABBAGIAQQBBAGkAQQBEADQAQQBaAEEAQgB3AEEARwB3AEEAZQBRAEIAeQBBAEQAbwBBAE8AZwBCADMAQQBHAGcAQQBaAFEAQgB5AEEARwBVAEEASwBBAEEAcABBAEQAdwBBAEwAdwBCAGgAQQBEADQAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAawBBAEQANABBAEMAZwBBAGcAQQBDAEEAQQBJAEEAQQA4AEEASABRAEEAWgBBAEEAZwBBAEgATQBBAGQAQQBCADUAQQBHAHcAQQBaAFEAQQA5AEEAQwBJAEEAZABBAEIAbABBAEgAZwBBAGQAQQBBAHQAQQBHAEUAQQBiAEEAQgBwAEEARwBjAEEAYgBnAEEANgBBAEcAdwBBAFoAUQBCAG0AQQBIAFEAQQBPAHcAQQBpAEEARAA0AEEASQBBAEEAdwBBAEQAVQBBAE8AZwBBAGcAQQBFADAAQQBkAFEAQgAwAEEARwBFAEEAZABBAEIAbABBAEMAQQBBAFkAUQBCAHUAQQBHAFEAQQBJAEEAQgBUAEEASABVAEEAYgBRAEIAdABBAEcARQBBAGMAZwBCAHAAQQBIAE0AQQBaAFEAQQBnAEEARAB3AEEATAB3AEIAMABBAEcAUQBBAFAAZwBBAEsAQQBDAEEAQQBJAEEAQQA4AEEAQwA4AEEAZABBAEIAeQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBpAEEARwA4AEEAWgBBAEIANQBBAEQANABBAEMAZwBBADgAQQBDADgAQQBkAEEAQgBoAEEARwBJAEEAYgBBAEIAbABBAEQANABBAAoAcwB1AGYAZgBpAHgAOgA=:31b8e172-b470-440e-83d8-e6b185028602"
  },
  {
    "objectID": "tutorials/index/quick_ref.html#index-of-topics",
    "href": "tutorials/index/quick_ref.html#index-of-topics",
    "title": "Quick Reference",
    "section": "Index of Topics",
    "text": "Index of Topics\nIf you’re looking for a particular section of a tutorial, use this handy summary to jump straight to the section you want.\n\n\n\n\n\n\n\nTutorial\nJump to Section\n\n\n\n\n01: IntRoductions I\n[Making Mistakes](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#making-mistakes)\n\n\n[GlossoRlia](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#glossorlia)\n\n\n\n[Types of Data](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#types-of-data)\n\n\n\n[Numeric](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#numeric)\n\n\n\n[Character](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#character)\n\n\n\n[Logical](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#logical)\n\n\n\n[Class and Coercion](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#class-and-coercion)\n\n\n\n[Objects](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#objects)\n\n\n\n[Creating an Object](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#creating-an-object)\n\n\n\n[Calling an Object](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#calling-an-object)\n\n\n\n[Using Objects](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#using-objects)\n\n\n\n[Important: Overwriting Objects](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#important:-overwriting-objects)\n\n\n\n[Functions](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#functions)\n\n\n\n[Basics and Help](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#basics-and-help)\n\n\n\n[Arguments](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#arguments)\n\n\n\n[Using Functions](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#using-functions)\n\n\n\n[Let’s Get Testing](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#let’s-get-testing)\n\n\n\n[Comparing Groups with *t*-test](tutorials/psychrlogy/01_fundRmentals/01_intro.qmd#comparing-groups-with-*t*-test)\n\n\n\n02: Datasets\n[The Pipe](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#the-pipe)\n\n\n[Datasets](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#datasets)\n\n\n\n[Reading In](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#reading-in)\n\n\n\n[Viewing](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#viewing)\n\n\n\n[Arranging](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#arranging)\n\n\n\n[Overall Summaries](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#overall-summaries)\n\n\n\n[Variables](tutorials/psychrlogy/01_fundRmentals/02_datasets.qmd#variables)\n\n\n\n03: Reporting Linear Models with Quarto\n[The Linear Model](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#the-linear-model)\n\n\n[Data and Codebook](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#data-and-codebook)\n\n\n\n[One Predictor](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#one-predictor)\n\n\n\n[Hierarchial Models](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#hierarchial-models)\n\n\n\n[Assumptions Checks](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#assumptions-checks)\n\n\n\n[Quarto](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#quarto)\n\n\n\n[Getting Started](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#getting-started)\n\n\n\n[Creating a Code Chunk](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#creating-a-code-chunk)\n\n\n\n[Headings and Text](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#headings-and-text)\n\n\n\n[Dynamic Reporting](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#dynamic-reporting)\n\n\n\n[Rendering](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#rendering)\n\n\n\n[Well done!](tutorials/psychrlogy/01_fundRmentals/03_lm.qmd#well-done!)\n\n\n\n04: Filter and Select\n[Setting Up](tutorials/psychrlogy/02_essentials/04_filter.qmd#setting-up)\n\n\n[Filter](tutorials/psychrlogy/02_essentials/04_filter.qmd#filter)\n\n\n\n[Multiple Conditions](tutorials/psychrlogy/02_essentials/04_filter.qmd#multiple-conditions)\n\n\n\n[Data Cleaning](tutorials/psychrlogy/02_essentials/04_filter.qmd#data-cleaning)\n\n\n\n[Select](tutorials/psychrlogy/02_essentials/04_filter.qmd#select)\n\n\n\n[`&lt;tidyselect&gt;`](tutorials/psychrlogy/02_essentials/04_filter.qmd#`&lt;tidyselect&gt;`)\n\n\n\n05: Mutate and Summarise\n[Setting Up](tutorials/psychrlogy/02_essentials/05_changes.qmd#setting-up)\n\n\n[Mutate](tutorials/psychrlogy/02_essentials/05_changes.qmd#mutate)\n\n\n\n[Composite Scores](tutorials/psychrlogy/02_essentials/05_changes.qmd#composite-scores)\n\n\n\n[Conditionals](tutorials/psychrlogy/02_essentials/05_changes.qmd#conditionals)\n\n\n\n[Iteration](tutorials/psychrlogy/02_essentials/05_changes.qmd#iteration)\n\n\n\n[Summarise](tutorials/psychrlogy/02_essentials/05_changes.qmd#summarise)\n\n\n\n[By Group](tutorials/psychrlogy/02_essentials/05_changes.qmd#by-group)\n\n\n\n[Iteration](tutorials/psychrlogy/02_essentials/05_changes.qmd#iteration)\n\n\n\n[Next Steps](tutorials/psychrlogy/02_essentials/05_changes.qmd#next-steps)"
  },
  {
    "objectID": "quick_ref.html",
    "href": "quick_ref.html",
    "title": "Quick Reference",
    "section": "",
    "text": "Looking for a function you can’t quite remember how to use? You’re in the right place! The table below is arranged alphabetically by function name, and the linked full name (including relevant package calls) will take you to the help documentation.\n\n\n\n\n\nFunction Name\n\n\nLink to Help Documentation\n\n\nUsed In…\n\n\n\n\n\n\nacross()\n\n\ndplyr::across()\n\n\n05: Mutate and Summarise\n\n\n\n\nanova()\n\n\nanova()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\napa_print()\n\n\npapaja::apa_print()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\napa_table()\n\n\npapaja::apa_table()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nautoplot()\n\n\nggplot2::autoplot()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nc()\n\n\nc()\n\n\n01: IntRoductions I03: Reporting Linear Models with Quarto05: Mutate and Summarise\n\n\n\n\nclass()\n\n\nclass()\n\n\n01: IntRoductions I\n\n\n\n\ncontains()\n\n\ndplyr::contains()\n\n\n05: Mutate and Summarise\n\n\n\n\ndata()\n\n\ndata()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nglance()\n\n\nbroom::glance()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nlibrary()\n\n\nlibrary()\n\n\n03: Reporting Linear Models with Quarto04: Filter and Select05: Mutate and Summarise\n\n\n\n\nlm()\n\n\nlm()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nlmRob()\n\n\nrobust::lmRob()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nmean()\n\n\nmean()\n\n\n01: IntRoductions I05: Mutate and Summarise\n\n\n\n\nmodel_parameters()\n\n\nparameters::model_parameters()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nnice_table()\n\n\nrempsyc::nice_table()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\npick()\n\n\ndplyr::pick()\n\n\n05: Mutate and Summarise\n\n\n\n\nround()\n\n\nround()\n\n\n01: IntRoductions I03: Reporting Linear Models with Quarto\n\n\n\n\nrowMeans()\n\n\nrowMeans()\n\n\n05: Mutate and Summarise\n\n\n\n\nsd()\n\n\nsd()\n\n\n05: Mutate and Summarise\n\n\n\n\nselect()\n\n\ndplyr::select()\n\n\n05: Mutate and Summarise\n\n\n\n\nt.test()\n\n\nt.test()\n\n\n01: IntRoductions I\n\n\n\n\ntidy()\n\n\nbroom::tidy()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nwhere()\n\n\ndplyr::where()\n\n\n05: Mutate and Summarise"
  },
  {
    "objectID": "quick_ref.html#index-of-functions",
    "href": "quick_ref.html#index-of-functions",
    "title": "Quick Reference",
    "section": "",
    "text": "Looking for a function you can’t quite remember how to use? You’re in the right place! The table below is arranged alphabetically by function name, and the linked full name (including relevant package calls) will take you to the help documentation.\n\n\n\n\n\nFunction Name\n\n\nLink to Help Documentation\n\n\nUsed In…\n\n\n\n\n\n\nacross()\n\n\ndplyr::across()\n\n\n05: Mutate and Summarise\n\n\n\n\nanova()\n\n\nanova()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\napa_print()\n\n\npapaja::apa_print()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\napa_table()\n\n\npapaja::apa_table()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nautoplot()\n\n\nggplot2::autoplot()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nc()\n\n\nc()\n\n\n01: IntRoductions I03: Reporting Linear Models with Quarto05: Mutate and Summarise\n\n\n\n\nclass()\n\n\nclass()\n\n\n01: IntRoductions I\n\n\n\n\ncontains()\n\n\ndplyr::contains()\n\n\n05: Mutate and Summarise\n\n\n\n\ndata()\n\n\ndata()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nglance()\n\n\nbroom::glance()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nlibrary()\n\n\nlibrary()\n\n\n03: Reporting Linear Models with Quarto04: Filter and Select05: Mutate and Summarise\n\n\n\n\nlm()\n\n\nlm()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nlmRob()\n\n\nrobust::lmRob()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nmean()\n\n\nmean()\n\n\n01: IntRoductions I05: Mutate and Summarise\n\n\n\n\nmodel_parameters()\n\n\nparameters::model_parameters()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nnice_table()\n\n\nrempsyc::nice_table()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\npick()\n\n\ndplyr::pick()\n\n\n05: Mutate and Summarise\n\n\n\n\nround()\n\n\nround()\n\n\n01: IntRoductions I03: Reporting Linear Models with Quarto\n\n\n\n\nrowMeans()\n\n\nrowMeans()\n\n\n05: Mutate and Summarise\n\n\n\n\nsd()\n\n\nsd()\n\n\n05: Mutate and Summarise\n\n\n\n\nselect()\n\n\ndplyr::select()\n\n\n05: Mutate and Summarise\n\n\n\n\nt.test()\n\n\nt.test()\n\n\n01: IntRoductions I\n\n\n\n\ntidy()\n\n\nbroom::tidy()\n\n\n03: Reporting Linear Models with Quarto\n\n\n\n\nwhere()\n\n\ndplyr::where()\n\n\n05: Mutate and Summarise"
  },
  {
    "objectID": "quick_ref.html#index-of-topics",
    "href": "quick_ref.html#index-of-topics",
    "title": "Quick Reference",
    "section": "Index of Topics",
    "text": "Index of Topics\nIf you’re looking for a particular section of a tutorial, use this handy summary to jump straight to the section you want.\n\n\n\n\n\nTutorial\n\n\nJump to Section\n\n\n\n\n\n\n01: IntRoductions I\n\n\nMaking Mistakes\n\n\n\n\nGlossoRlia\n\n\n\n\nTypes of Data\n\n\n\n\nNumeric\n\n\n\n\nCharacter\n\n\n\n\nLogical\n\n\n\n\nClass and Coercion\n\n\n\n\nObjects\n\n\n\n\nCreating an Object\n\n\n\n\nCalling an Object\n\n\n\n\nUsing Objects\n\n\n\n\nImportant: Overwriting Objects\n\n\n\n\nFunctions\n\n\n\n\nBasics and Help\n\n\n\n\nArguments\n\n\n\n\nUsing Functions\n\n\n\n\nLet’s Get Testing\n\n\n\n\nComparing Groups with t-test\n\n\n\n\n02: Datasets\n\n\nThe Pipe\n\n\n\n\nDatasets\n\n\n\n\nReading In\n\n\n\n\nViewing\n\n\n\n\nArranging\n\n\n\n\nOverall Summaries\n\n\n\n\nVariables\n\n\n\n\n03: Reporting Linear Models with Quarto\n\n\nThe Linear Model\n\n\n\n\nData and Codebook\n\n\n\n\nOne Predictor\n\n\n\n\nHierarchial Models\n\n\n\n\nAssumptions Checks\n\n\n\n\nQuarto\n\n\n\n\nGetting Started\n\n\n\n\nCreating a Code Chunk\n\n\n\n\nHeadings and Text\n\n\n\n\nDynamic Reporting\n\n\n\n\nRendering\n\n\n\n\nWell done!\n\n\n\n\n04: Filter and Select\n\n\nSetting Up\n\n\n\n\nFilter\n\n\n\n\nMultiple Conditions\n\n\n\n\nData Cleaning\n\n\n\n\nSelect\n\n\n\n\n&lt;tidyselect&gt;\n\n\n\n\n05: Mutate and Summarise\n\n\nSetting Up\n\n\n\n\nMutate\n\n\n\n\nComposite Scores\n\n\n\n\nConditionals\n\n\n\n\nIteration\n\n\n\n\nSummarise\n\n\n\n\nBy Group\n\n\n\n\nIteration\n\n\n\n\nNext Steps"
  }
]