{
  "hash": "21e84c3971fc440c974ae3c1680cc69f",
  "result": {
    "markdown": "---\ntitle: \"05: Mutate and Summarise\"\nformat: \n  html:\n    toc: true\n    code-annotations: below\n    code-link: true\neditor: visual\nself-contained: true\nexecute:\n  warning: false\n  error: false\n---\n\n\n::: callout-note\n\n## Overview\n\nThis tutorial covers two essential `dplyr` functions: `mutate()` and `summarise()`. Very similar in structure, the two functions primarily differ in output. `mutate()` makes changes within a given dataset, whereas `summarise()` uses the information in a given dataset to create a new, separate summary dataset.\n\n:::\n\n## Getting Started\n\n### Using This Tutorial\n\n### Setting Up\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Mutate\n\nThe `mutate()` function is one of the most essential functions from the `dplyr` package. Its primary job is to easily and transparently make changes within a dataset - in particular, a `tibble`.\n\n### Basic Structure\n\nTo make a single, straightforward change to a tibble, use the general format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |>\n  dplyr::mutate(\n    variable_name = instructions_for_creating_the_variable\n  )\n```\n:::\n\n\n`variable_name` is the name of the variable that will be added to the dataset by `mutate()`. This can be any name that follow's R's object naming rules. There are two main options for this name:\n\n1.  If the dataset does **not** already contain a variable called `variable_name`, a new variable will be added to the dataset.\n2.  If the dataset **does** already contain a variable called `variable_name`, the new variable will silently[^1] replace (i.e. overwrite) the existing variable with the same name.\n\n[^1]: Here, \"silently\" means that R overwrites the existing variable without flagging that it is doing this or asking you if you are sure, so it's important to be aware of this behaviour (and to know what variables already exist in your dataset).\n\n#### Usage\n\n::: callout-tip\n\nAlthough creating or modifying variables will likely be the most frequent way you use `mutate()`, it has other handy features such as:\n\n- Deleting variables\n- Deciding where newly created variables appear in the dataset\n- Deciding which variables appear in the output, depending on which you've used\n\nSee the help documentation for more by running `help(mutate)` or `?mutate` in the Console.\n:::\n\n### Composite Scores\n\n> Row-wise magic is good magic. -Hadley Wickham\n\nA very common `mutate()` task is to create a composite score from multiple variables - for example, an overall anxiety score from a questionnaire with ten items on anxiety. Imagine we wanted to create an overall score that is the mean of the ratings on each of those ten items, for each participant.\n\nTo do this, we must use a method that ensures that each score is calculated separately for each participant. There are a variety of ways to accomplish this, but a robust and reasonably straightforward way uses the purpose-built function `dplyr::rowwise()`.\n\n::: callout-important\nThe code below assumes a dataset structured so that each participant has data on a **single row only**\n\nIf your data is tidy with observations from the same participants on multiple rows, you will need to reshape your data or adapt the code to suit your data structure.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> # <1>\n  dplyr::rowwise() |> # <2>\n  dplyr::mutate( # <3>\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")), # <3>\n                        na.rm = TRUE) # <3>\n  ) |>  # <3>\n  dplyr::ungroup() # <4>\n```\n:::\n\n\n1.  Take the dataset, and then,\n2.  Group the dataset by row - and because each row is a participant, by participant. This means that any subsequent calculations will be done for each row separately.\n3.  Create the new `anxiety_mean` variable. The new function `c_across()` works quite similar to `c()` - namely, creating a vector of variables to take the mean of. However, it has the advantage of allowing `<tidyselect>` for choosing the variables, instead of having to type them out one by one.\n4.  Remove the grouping that was created by `rowwise()`. Otherwise, all other subsequent operations on this dataset will continue to be performed within each row. (This isn't typically the desired behaviour for this task, but it can be quite useful in other scenarios!)\n\n::: callout-tip\n\nFor lots more details and examples on `rowwise()` and rowwise operations with `dplyr` - including which other scenarios in which a row-wise dataset would be useful - run `vignette(\"rowwise\")` in the Console.\n:::\n\n::: callout-note\n#### Practice Tasks\n\n1.  What would the above code produce without the `rowwise()...ungroup()` steps (i.e. with only the `mutate()` command)? Make a prediction, then try it and find out if you were right.\n2.  The above code is definitely not the only way to obtain the same output. Try producing the the same `anxiety_mean` variable with the following methods. What are the benefits and drawbacks of each methods? *Hint:* Use `vignette(\"rowwise\")` to help if you get stuck.\n3.  Using a dedicated by-row function, `rowMeans()`\n4.  Using the basic structure of `mutate()` only\n\n::: {.callout-note collapse=\"true\"}\n##### Solutions\n\n1.  We can see what happens without `rowwise()...ungroup()` just by commenting them out of the pipe. To do this, either type `#` before each line, or highlight them and press CTRL/CMD + SHIFT + C.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  # dplyr::rowwise() |> \n  dplyr::mutate(\n    anxiety_mean = mean(c_across(starts_with(\"anxiety\")), na.rm = TRUE)\n  ) # |> don't forget to comment out this pipe or you'll get an error\n  # dplyr::ungroup()\n```\n:::\n\n\nThis code still runs successfully, but the result isn't what we wanted. Have a look at the `anxiety_mean` variable: all the values are the same. Instead of calculating the mean for each person, this code instead calculated the *overall* mean of all of the anxiety variables, and then assigned that single value to the `anxiety_mean` variable. Not what we wanted in this case - but it could be useful in other scenarios!\n\n2.  If we wanted to avoid, or didn't remember, the `rowwise()...ungroup()` sequence, there are other options to produce the same result, but neither are easier to read or implement.\n\n*1. Using `rowMeans`*\n\nThe `base` function `rowMeans()` calculates the mean of each row without any additional jiggery pokery to worry about. The problem is specifying which variables to include, especially because we have ten in this example to work with.\n\nHowever, `rowMeans()` is an independent function who doesn't need no `dplyr`, and as such does not work the same way, for instance, `mean()` does, with no straightforward workaround.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Reasonable but just doesn't work!\nmy_tibble |> \n  dplyr::mutate(\n    anxiety_mean = rowMeans(c(anxiety_1, anxiety_2, anxiety_3..., anxiety_10))\n  )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dplyr::mutate(my_tibble, anxiety_mean = rowMeans(c(anxiety_1, : object 'my_tibble' not found\n```\n:::\n:::\n\n\nThis is because `rowMeans()` is expecting a whole dataset, not just a subset of columns. You can solve this by `select()`ing within the `rowMeans()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::mutate(\n    anxiety_mean = rowMeans(dplyr::select(my_tibble, anxiety_1, anxiety_2...))\n  )\n```\n:::\n\n\n...which has the major issue that if you update the name of your dataset, you must update it in TWO places - at the start of the pipe and inside `rowMeans()`, along with just being a huge mess.\n\nAlternatively, you can use `dplyr::pick()` with `<tidyselect>` semantics to make this less, well, terrible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::mutate(\n    anxiety_mean = rowMeans(pick(contains(\"anxiety\")))\n  )\n```\n:::\n\n\n...which didn't seem fair because we haven't talked about `pick()`, and also defeated the purpose of using `rowMeans()` to avoid having to learn new `dplyr` functions. So, `dplyr` wins this one either way.\n\nIf you're keen to never have to learn a jot more `dplyr` than absolutely necessary (I bet you are *not* having a good time so far!), [this Stack Overflow post](https://stackoverflow.com/questions/33401788/dplyr-using-mutate-like-rowmeans) offers some other, non-`dplyr` solutions...that also depend on using the magrittr pipe `%>%`! Sorry.\n\n*2. Use basic `mutate()`*\n\nThe most straightforward method - although perhaps not the most obvious - is to express the calculation you want as arithmetic using the relevant variables. In this instance, to calculate a mean, we sum the scores together and then divide by the number of scores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::mutate(\n    anxiety_mean = (anxiety_1 + anxiety_2 + ... + anxiety_10)/10\n  )\n```\n:::\n\n\nThis method, although very transparent, has some critical downsides.\n\n-   **It's clunky and prone to error.** This style works best for 2-3 variables contributing to the composite. For more variables, we end up with a lot of repetitive typing, which also means increased likelihood of typos, accidental omissions, or other errors - especially with a large number of variables, as we have here.\n-   **It's not robust.** Imagine that, on review of the anxiety scale, we find that `anxiety_9` is a badly worded/unreliable item and decide to drop it from our analysis. We then either have to (remember to) manually update our code both to remove `anxiety_9` *and* to change the denominator from 10 to 9 (not a good time), or debug the resulting error if we don't remember.\n\nWe **do teach this method to UGs** specifically to reduce the number of functions they have to learn, but for real-life usage, in most cases, the `rowwise()` solution is likely preferable.\n:::\n:::\n\n### Recoding and Conditionals\n\nThere are many functions out there for recoding variables, but the following method, using `dplyr::case_when()`, is recommended because it is so versatile. It can be used to recode the values from one variable into new one, but it can also combine information across variables to create a new one. It allows a series of if-else statements without having to actually have lots of if-else statements!\n\nThe generic format of `case_when()` can be stated as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::mutate(\n    new_variable = dplyr::case_when(\n      logical_assertion ~ value,\n      logical_assertion ~ value,\n      .default = value_to_use_for_cases_with_no_matches\n    )\n  )\n```\n:::\n\n\n#### Usage\n\nWithin `case_when()`, each line contains a formula, written above as `logical_assertion ~ value`. This can be read as follows:\n\n> \"For the cases where `logical_assertion` returns `TRUE`, assign `value` to the `new_variable`.\n\nThese assertions are evaluated sequentially and the first match determines the value. This means that the assertions **must** be ordered from most specific to least specific.\n\n::: {.callout-tip title=\"Testing Assertions\" collapse=\"true\"}\n\nThe assertions for `case_when()` are the same as the ones we used previously in `filter()`. In fact, if you need to test the assertion you are writing to ensure that your code will work as you want, you can try the same assertion in `filter()` to check whether the cases it returns are only and exactly the once you want to change.\n\n:::\n\nLet's look at two examples of how `dplyr::case_when()` might come in handy.\n\n##### One-Variable Input\n\nWe've created our composite `anxiety_mean` variable previously, and now we may want to change this continuous score into a categorical variable indicating whether or not participants display clinical levels of anxiety. So, we can use `case_when()` to recode `anxiety_mean` into a new `anxiety_cat` variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanxiety_cutoff <- 35 # <1>\n\nmy_tibble |> # <2>\n  dplyr::mutate( # <3>\n    anxiety_cat = dplyr::case_when( # <4>\n      anxiety_mean >= anxiety_cutoff ~ 1, # <5>\n      anxiety_mean < anxiety_cutoff ~ 0, # <6>\n      .default = NA # <7>\n    )\n  )\n```\n:::\n\n\n1. Create a new object, `anxiety_cutoff`, containing the threshold value for separating clinical from non-clinical anxiety. This one is from REFERENCE.\n2. Take the dataset, and then\n3. Make a change to it as follows\n4. Create a new variable, `anxiety_cat`, by applying the following rules\n5. For cases where the value of `anxiety_mean` is greater than or equal to `anxiety_cutoff`, assign a value of 1 to `anxiety_cat`\n6. For cases where the value of `anxiety_mean` is less than  `anxiety_cutoff`, assign a value of 0 to `anxiety_cat`\n7. For cases that don't match any of the preceding criteria, assign `NA` to `anxiety_cat`\n\n::: {.callout-tip title=\"Why the new `anxiety_cutoff` object?\" collapse=\"true\"}\n\nIn the code above, the cutoff value is stored in a new object, `anxiety_cutoff`, which is then used in the subsequent `case_when()` conditions. Why take this extra step?\n\nThis is a matter of style, since the output of this code would be entirely identical if I wrote the cutoff value into the `case_when()` assertions directly (e.g. `anxiety_mean >= 35`). I have done it this way for a few reasons:\n\n1. The threshold value is easy to find, in case I need to remind myself which one I used, and it's clearly named, so I know what it represents.\n1. Most importantly, it's easy to change, in case I need to update it later. I would only have to change the value in the object once, at the beginning of the code chunk, and all of the subsequent code using that object would be similarly updated.\n\nIn short, it makes the code easier to navigate, more resilient to later updates, and more transparent in its meaning.\n\n:::\n\n##### Multi-Variable Input\n\nWe might also like to create a useful coding variable to help keep track of the number of cases we've removed, and for what reasons. We can draw on input from multiple variables to create this single new variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |>  # <1>\n  dplyr::mutate(  # <1>\n    remove = dplyr::case_when( # <1>\n      distribution == \"Preview\" ~ \"preview\", # <2>\n      info_consent != \"Yes\" ~ \"no_consent\", # <3>\n      age < 18 ~ \"age_young\", # <4>\n      is.na(age) | age > 100 ~ \"age_bad\", # <5>\n      !grepl(\"eng\", tolower(fluent_lang)) ~ \"english_no\", # <6>\n      .default = \"keep\" # <7>\n    )\n  )\n```\n:::\n\n\n1. Take the dataset `my_tibble` and make a change to it by a creating a new variable, `remove`, by applying the following rules\n1. For cases where the `distribution` variable contains exactly and only \"Preview\", assign the value `\"preview\"`. This is a common task for Qualtrics surveys to remove practice runs.\n1. For cases where the `info_consent` variable does NOT contain exactly and only the value \"Yes\", assign the value `\"no_consent\"`. This includes anyone who did not actively consent - both people who chose options OTHER than \"Yes\" (e.g. \"No\"), and people who did not respond.\n1. For cases where the numerical value in `age` is less than 18, assign the value `\"age_young\"`.\n1. For cases where the value is `age` is `NA`, or is greater than 100, assign the value `\"age_bad\"`.\n1. For cases where the value in `fluent_lang`, once converted to lowercase, does NOT contain the letters \"engl\", assign the value `\"english_no\"`. This searches open text responses to a question like \"What languages do you speak fluently?\" for the string \"engl\".\n1. For cases that don't match any of the preceding criteria, assign the value `\"keep\"`.\n\nBecause the first match for each case is the value it is assigned, each case will receive only one value, even if they match multiple criteria. For example, if you had a participant who gave their age as 17 and their fluent languages as Finnish and German, they would be coded as `age_young` rather than `english_no` because the assertion about age comes before the assertion about language. (This is sensible behaviour, because being 18 or older is an ethical requirement, whereas speaking English fluently likely isn't.)\n\nFrom here, you can easily use this variable to summarise exclusions, and to filter out excluded cases for your final dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> # <1>\n  dplyr::count(remove) # <1>\n\nfinal_tibble <- my_tibble |> # <2>\n  dplyr::filter(remove == \"keep\") # <2>\n```\n:::\n\n\n1. Take `my_tibble` and count the number of times each unique value occurs in the `remove` variable.\n1. Create a new object, `final_tibble`, by taking `my_tibble` and then retaining only the cases for which the `remove` variable has only and exactly the value `\"keep\"` - effectively dropping all other cases.\n\n::: {.callout-tip title=\"Recoding Factors\" collapse=\"true\"}\n\nWhat about recoding or relabeling factors? For example, imagine a dataset where gender has been collected as 1, 2, and 3, with 1 corresponding to \"Female\", 2 to \"Male\", and 3 to \"Nonbinary/third gender\". You \n\n:::\n\n### Across Multiple Variables\n\n::: callout-warning\n\nThis material isn't covered in the Beginner Series live workshops. It's included here for reference because it's extremely useful in real R analysis workflows, but it won't be essential for any of the Beginner Series tasks.\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::mutate(\n    dplyr::across(<tidyselect>, function_to_apply)\n  )\n```\n:::\n\n\n## Summarise\n\n### Basic Structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n```\n:::\n\n\n::: callout-important\n\nYou may notice that the basic structure of summarise looks identical to the basic structure of mutate, above. The difference is that mutate creates or replaces variables within the **same** dataset, while summarise creates a **new** summary dataset without changing the original.\n\n:::\n\n#### Usage\n\n### Grouped Summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tibble |> \n  dplyr::group_by(group) |> \n  dplyr::summarise(\n    variable_name = instructions_for_creating_the_variable\n  )\n```\n:::\n\n\n### Ready-Made Summaries\n\n\n### Across Multiple Variables\n\n::: callout-warning\n\nThis material isn't covered in the Beginner Series live workshops. It's included here for reference because it's extremely useful in real R analysis workflows, but it won't be essential for any of the Beginner Series tasks.\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}