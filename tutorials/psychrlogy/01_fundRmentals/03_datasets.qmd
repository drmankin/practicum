---
title: "03: Datasets"
execute:
  error: true
---

-   Libraries
-   Reading in, viewing and summarising datasets
-   Subsetting with \`\$\`, \`pull()\`
-   Useful verbs: count, tally, mean, sd, min, max, etc.
-   Quarto: chunk options, inline code, automatic numbering, rendering
-   Base R visualisations

## Overview

This tutorial is focused on working with datasets. It covers key functions and tips for reading in, viewing, summarising, and working with datasets, and then walks through the process of setting up and producing a Quarto report, including how to dynamically report results and render a final document to a variety of formats.

## Setup

In each session, we will always follow the same steps to set up. We'll walk through the key elements here in detail and then provide a brief summary in future tutorials.

::: {.callout-tip title="Setup Steps"}
1. Create or open a [project in RStudio](03_datasets.qmd#projects)
1. Create or open a [document to work in](03_datasets.qmd#creating-documents)
1. [Load the necessary packages](03_datasets.qmd#loading-packages)
:::

### Projects

Projects are the main way that RStudio organises related files and information. Projects are associated with a working directory; everything in that directory, including all the sub-folders, are part of the same project.

It is **highly recommended** that you create a new project for each separate thing you want to work on in R. Among other advantages, it makes navigating folders much easier (see [Reading In](03_datasets.qmd#reading-in)), allows you to easily pick up work from where you left off, and retain all the settings and options you have set each time you work on the same project.

::: {.callout-tip title="Creating a Project" collapse="false"}

On Posit Cloud, you don't really have a choice in the matter - you must create or open a project in the Cloud workspace in order to do anything.

On a desktop installation, you can create a new directory as a project or associate a project file with an existing directory.

See [Posit's Using RStudio Projects](https://support.posit.co/hc/en-us/articles/200526207-Using-RStudio-Projects) guide or Andy Field's [video guide to RStudio Desktop](https://www.youtube.com/watch?v=EA7JW2SfKSY) for more information.

:::

### Creating Documents

As we discussed [in the previous tutorial](01_02_intro.qmd), one of the key strengths of doing your work using R (or any other programming language) is reproducibility - in other words, every step of the process from raw file to output is documented and replicable. However, this is only the case if you do in fact write your code down somewhere! To do that, you'll need to create some kind of document to record your code. There are two main types of documents you might consider using: a script or a Quarto document. 

#### Quarto documents

Quarto documents contain a combination of both non-code text and code. The main strength of these documents is that they can be **rendered** to some other output format, such as HTML, PDF, or Word, by executing all of the code and combining it with the text to create a nicely formatted document.

We will investigate the options for Quarto documents in depth in [the next tutorial](04_lm.qmd#quarto). For now, use the Quarto document in your project on Posit Cloud for your work in this tutorial.

#### Scripts

Scripts are text files that RStudio knows to read as R code. They have a .R file extension and can ONLY contain code. They are very useful for running code behind the scenes, so to speak, but not great for reviewing or presenting results.

::: {.callout-tip title="Quarto or Script?"}

When deciding what kind of document to create, think about what you want to do with the output of your work.

- Use **Quarto** if the document needs to contain any amount of text, or will be used to share the output of your code in a presentable way, such as notes for yourself, reports, articles, websites, etc.
- Use a **script** if the document only needs to contain code and has a solely functional purpose, such as cleaning a dataset, manipulating files, defining new functions, etc.

In this series, we will almost always use Quarto documents, but scripts are an essential part of the development side of R.
:::

### Installing and Loading Packages

[In the previous tutorial](01_02_intro.qmd#functions), we saw how the main way that R does anything is via functions. All functions belong to a package, which are extensions to the R language. Packages can contain functions, documentation for those functions, datasets, sample code, and more. Some packages, like the {base} and {stats} packages that contain the `mean()` and `t.test()` functions that we saw previously, are included by default when R starts. However, you will often want to use functions from packages that aren't included by default, so you must do this explicitly.

In order to utilise the functions in a package, you must do two things:

1. Install the package (only **once** per device, or to update the package) using `install.packages("package_name")` **in the Console**
1. Load the package (every time you want to use it) using `library(package_name)` **at the beginning of each new document**

:::{.callout-important}
If you are working on these tutorials on the Posit Cloud workspace, **all of the packages you need have been installed already**. Please do not try to install any packages, as this could cause unexpected conflicts or errors.
:::

:::{.callout-tip title="More About Installing vs Loading Packages" collapse="true"}

When you install R and RStudio for the first time on a device, this is like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. Most likely, though, you want to use other apps that don’t come with the phone - like WhatsApp, or Facebook. Let’s say you’ve just got a new phone and you want to use WhatsApp. To do this, you’ll need to:

1. Go to your phone’s app store and download WhatsApp (only **once** per device, or to update the app)
1. Open the app (every time you want to use it)

As you can see, these steps correspond almost exactly to the installing vs loading steps described above. In order to use a package that doesn’t come pre-installed with R, you have to do both of these things.
:::

:::: {.callout-note appearance="minimal" title="Exercise"}

Load the {tidyverse} package in your Quarto document.

::: {.callout-note collapse="true" title="Solution"}

```{r}
library(tidyverse)
```

:::
::::

## Datasets

Now that we've completed our core setup, we're ready to get stuck in working with datasets. For the purposes of practicing, we're going to use some real, open-source data 

### Reading In

- here::here()
- readr::read_csv()

### Viewing



### Arranging

#### Arranging Manually


#### Arranging with Code

## The Pipe

In this and the previous tutorial, we've seen some examples of "nested" code - functions nested within functions, as below.

To read this code, you have to start at the innermost level of nesting and work outwards. For one or two levels of nesting, this is still legible, but can quickly become very difficult to track.

One solution is to use the **pipe operator, \|\>**. The pipe "chains" commands one after the other by taking the output of the preceding command and "piping it into" the next command, allowing a much more natural and readable sequence of steps - sequentially, rather than nested. The pipe version of the above might look like this:

::: {.callout-tip title="Definition: Pipe"}
The pipe operator may appear in two formats.

-   **The native pipe, \|\>**. This is the pipe we will use throughout these tutorials. It is called the "native" pipe because it is inbuilt into R and doesn't require any specific package to use.
-   **The {magrittr} pipe, %\>%**. This pipe comes from {tidyverse}, and in particular requires the {magrittr} package to use. You will very commonly see this pipe in scripts, Stack Overflow posts, from ChatGPT, etc. as until the native pipe was introduced to R in 2022, the {magrittr} pipe was "the pipe" for R.

In most use-cases, including almost all of the code we will learn in these tutorials, the two pipes are interchangeable and will result in the same output.

Conceptually, the pipe works by putting whatever is put into it into the first argument of whatever comes after it. Many functions - both packages and functions from the {tidyverse} and not - are already set up so that the first argument is the data, and {tidyverse} functions are explicitly designed this way in order to work best with the pipe.

For functions where this is not the case, you can explicitly determine where the piped-in object should go using a "placeholder".The most noticeable difference is that the native pipe placeholder is `_`, while the magrittr pipe placeholder is `.`.

::: {.callout-tip title="Pipe Example" collapse="true"}
Imagine we wanted to bake a Victoria sponge cake using R. Translating the steps into R, we might get something like this:

```{r}
ingredients |> 
  mix(order = c("wet", "dry")) |> 
  pour(shape = "round", number = 2, lining = TRUE) |> 
  bake(temp = 190, time = 20) |> 
  cool() |> 
  assemble(filling = c("buttercream", "jam"), topping = "icing_sugar") |> 
  devour()
```

At each step, `|>` takes whatever the previous step produces and passes it on to the next step. So, we begin with `ingredients` - presumably an object that contains our flour, sugar, eggs, etc - which is "piped into" the `mix()` function. The output of that function might be all our ingredients mixed together in a bowl, which is then piped into the `pour()` function, and so on.

Notice for example, the function `cool()`, which doesn't appear to have anything in it. It actually does: the `cool()` function would work with whatever the output of the `bake()` function was above it.
:::
:::

## Overall Summaries

### Base R

The quickest and easiest check for a whole dataset is the base R function `summary()`. This function doesn't do anything fancy (*at all*) but it does give you a very quick look at how all the variables have been read in, and an early indication if there's anything wonky going on.

#### Example

```{r}
#| eval: false

summary(my_tibble)
```

Here, for example, notice the `age` variable. This should be a numeric variable, but clearly something has gone pear-shaped, because it instead seems like a character variable. Compare this to, for example, OTHER EXAMPLE, which has some descriptive information about the distribution of values in the variable, which indicates that it *has* been successfully read as numeric.

We will ignore the `age` issue for now until we cover how to make changes to the dataset [in Tutorial 5](..\02_essentials\07_changes.qmd#mutate)

### {datawizard}

Besides the basic summary, there are many ready-made options in various packages to quickly produce summary tables. At the UG level, students are introduced `datawizard::describe_distribution()`, which is one such function. To use it, simply put the name of the dataset object inside the brackets.

::: callout-tip
Besides its default settings, the output can be further customised to add or remove particular statistics; see the help documentation.
:::

#### Example

```{r}
#| eval: false

datawizard::describe_distribution(my_tibble)
```

## Variables

Once we've had a look at the whole dataset, it's time to drill down into individual variables. We may want to calculate quick descriptives or investigate what's going on with particular variables that seem to have issues (as we saw with `age` above). For any of these tasks, we'll look at variables one at a time by subsetting or otherwise pulling them out of the dataset, then calculating some information about them.

#### Subsetting

#### Counting

#### Descriptives

#### Visualisations
