---
title: "02: IntRoduction II"
---

<!-- UPDATE: We need to do something fun and interactive in this session otherwise it's mostly talking. Maybe writing a very simple reproducible script? Does Reny have a checklist of good practice for reproducible code? -->

## Setup

In each session, we will always follow the same steps to set up. We'll walk through the key elements here in detail and then provide a brief summary in future tutorials.

::: {.callout-tip title="Setup Steps"}
1.  Create or open a [project in RStudio](#projects)
2.  Create or open a [document to work in](#creating-documents)
3.  [Load the necessary packages](#packages)
:::

### Projects

Projects are the main way that RStudio organises related files and information. Projects are associated with a working directory; everything in that directory, including all the sub-folders, are part of the same project.

It is **highly recommended** that you create a new project for each separate thing you want to work on in R. Among other advantages, it makes navigating folders much easier (see [Reading In](03_datasets.qmd#reading-in)), allows you to easily pick up work from where you left off, and retain all the settings and options you have set each time you work on the same project.

::: {.callout-tip title="Creating a Project" collapse="false"}
On Posit Cloud, you don't really have a choice in the matter - you must create or open a project in the Cloud workspace in order to do anything.

On a desktop installation, you can create a new directory as a project or associate a project file with an existing directory.

See [Posit's Using RStudio Projects](https://support.posit.co/hc/en-us/articles/200526207-Using-RStudio-Projects) guide or Andy Field's [video guide to RStudio Desktop](https://www.youtube.com/watch?v=EA7JW2SfKSY) for more information.
:::

### Documents

As we discussed [in the previous tutorial](01_02_intro.qmd), one of the key strengths of doing your work using R (or any other programming language) is reproducibility - in other words, every step of the process from raw file to output is documented and replicable. However, this is only the case if you do in fact write your code down somewhere! To do that, you'll need to create some kind of document to record your code. There are two main types of documents you might consider using: a script or a Quarto document.

#### Quarto documents

Quarto documents contain a combination of both non-code text and code. The main strength of these documents is that they can be **rendered** to some other output format, such as HTML, PDF, or Word, by executing all of the code and combining it with the text to create a nicely formatted document.

We will investigate the options for Quarto documents in depth in [the next tutorial](04_lm.qmd#quarto). For now, use the Quarto document in your project on Posit Cloud for your work in this tutorial.

#### Scripts

Scripts are text files that RStudio knows to read as R code. They have a .R file extension and can ONLY contain code. They are very useful for running code behind the scenes, so to speak, but not great for reviewing or presenting results.

::: {.callout-tip title="Quarto or Script?"}
When deciding what kind of document to create, think about what you want to do with the output of your work.

-   Use **Quarto** if the document needs to contain any amount of text, or will be used to share the output of your code in a presentable way, such as notes for yourself, reports, articles, websites, etc.
  -   The page you're reading now is (or was!) a Quarto document.
-   Use a **script** if the document only needs to contain code and has a solely functional purpose, such as cleaning a dataset, manipulating files, defining new functions, etc.
  -   I use a script to process all of the tutorial documents and generate the [Quick Reference](../../../quick_ref.qmd) page.

In this series, we will almost always use Quarto documents, but scripts are an essential part of the development side of R.
:::

## Packages

In this tutorial, we'll see how the main way that R does anything is via functions. All functions belong to a **package**, which are extensions to the R language. Packages can contain functions, documentation for those functions, datasets, sample code, and more. Some packages, like the {base} and {stats} packages that contain the `mean()` and `t.test()` functions that we saw previously, are included by default with R. However, you will often want to use functions from packages that aren't included by default, so you must do this explicitly.

In order to utilise the functions in a package, you must do two things:

1.  Install the package (only **once** per device, or to update the package) using `install.packages("package_name")` **in the Console**
2.  Load the package (every time you want to use it) using `library(package_name)` **at the beginning of each new document**

::: callout-important
If you are working on these tutorials on the Posit Cloud workspace, **all of the packages you need have been installed already**. Please do not try to install any packages unless directed by the lead, as this could cause unexpected conflicts or errors.
:::

::: {.callout-tip title="MoRe About: Installing vs Loading Packages" collapse="true"}
When you install R and RStudio for the first time on a device, this is like buying a new mobile phone. When you get a new phone, it comes with some apps pre-installed, like a messaging app, a camera, a calculator, etc. If you only ever wanted to take pictures and do basic maths with your phone, you could probably leave it at that. In the same way, when you install R it already comes with some basic packages for doing some operations.

Most likely, though, you'll want to use other apps that don't come with your new phone - like WhatsApp, or ~~Twitter~~ ~~X~~ Bluesky. Let's say you've just got a new phone and you want to use WhatsApp. To do this, you'll need to:

1.  Go to your phone's app store and download WhatsApp (only **once** per device, or to update the app)
2.  Open the app (every time you want to use it)

As you can see, these steps correspond almost exactly to the installing vs loading steps described above. In order to use a package that doesn't come pre-installed with R, you have to do both of these steps.
:::

### Loading tidyverse

One of the core packages we use for UG teaching is [{tidyverse}](https://www.tidyverse.org/). This isn't actually a single package, but rather a convenient shorthand to install and load a suite of interconnected packages all together. We will be using {tidyverse} packages throughout this training series, so loading {tidyverse} straightaway is a good habit to get into!

::: {.callout-note appearance="minimal" title="Exercise"}
Load the {tidyverse} package in your workbook.

*Note*: If you are on the Cloud workspace, {tidyverse} will already be installed. If not, you may need to install it first.

::: {.callout-note collapse="true" title="Solution"}
```{r}
#| message: true
library(tidyverse)
```
:::
:::

When you load {tidyverse} for the first time, quite a lot of extra stuff gets printed along with it. All this output looks alarming, but these aren't errors or warnings - they're just *messages*. Messages are like warnings, but neutral: they just contain information that you might find helpful.

The usual {tidyverse} message contains two parts:

- **`Attaching core tidyverse packages`** tells you which packages have just been loaded. Essentially, `library(tidyverse)` is a shortcut for loading all of these packages individually. Somewhat confusingly, installing {tidyverse} *installs* more packages than are in this list (for example, {magrittr} and {rlang}), many of which other {tidyverse} packages rely on to function. If you want to load them, you can use `library()` to do this - but you don't need to unless you're using those packages explicitly. For our purposes now, just the default {tidyverse} packages are fine.

- **`Conflicts`** tells you about any package conflicts as a result of loading the packages.

What are conflicts? Consider that there are lots and *lots* of packages for R. At the time of this writing, CRAN (the repository for R packages) contains [just shy of 20,000](https://cran.r-project.org/web/packages/) R packages, with many, many more on Github and elsewhere. Although people generally try to avoid it, it is necessarily the case that sometimes, people give the same name to two different functions from two different packages. 

So, if you have those packages both loaded, how does R know which one to use? This situation is called a *conflict*.

::: {.callout-important title="Resolving Conflicts"}

**Method 1: Recency**

In the absence of any other information, R will use the function from the package that was loaded most recently. This is exactly what's happening in the {tidyverse} message above.

There are two conflicts mentioned. one of which reads:

```
x dplyr::filter() masks stats::filter()
```

{stats}, you might remember, is a package that is always installed with R and is loaded by default. So, the {stats} package has a function called `filter()` that is already loaded to begin with. When we loaded {tidyverse}, one of the new packages, {dplyr}, also contains a function called `filter()`. Because {dplyr} has been loaded more recently, if you write a bit of code using `filter()`, the one you will get is `dplyr::filter()`[^pkgfx]. In other words, the more recently loaded `dplyr::filter()` covers over, steps in front of, or (in R terminology) "masks" `stats::filter()`.

[^pkgfx]: You can read this notation as "the filter function from the dplyr package", or just "dplyr filter". As for how to pronounce "dplyr", the [official pronunciation](https://twitter.com/hadleywickham/status/925313165554012160?s=20) is "dee-ply-er", with "plier" like the tool [for which it's named](https://dplyr.tidyverse.org/). I have heard other people say "dipler". Since code is always a bit tricky to read aloud, just go with whatever sounds good to you.

Now, what if you actually want to use `filter()` from {stats} instead? Well, in that case you might want to use...

**Method 2: Explicit style**

Above we saw several examples of the `package::function()` notation, called "explicit" or "verbose" coding style. With explicit style, there isn't actually a conflict between `stats::filter()` and `dplyr::filter()` anymore, because their package calls are clearly stated so R doesn't have to guess which `filter()` you want. So, if you had loaded {tidyverse}, you could write `stats::filter()` in your code, and you would still get the function from the {stats} package even with {dplyr} loaded.

Another, secret benefit of explicit style is that as long as you have a package *installed*, you can use a function from that package without having to load it. Imagine I start a new project (so I have `stats::filter()` already loaded by default). If I only want to quickly use `dplyr::filter()`, I can use explicit style to use that function without having to run `library(tidyverse)`.
:::

The style you'll see in these tutorials is a pretty devotedly explicit style: that is, I'll always write `dplyr::filter()` instead of just `filter()`. I only leave out the package name in a few situations:

1. When the function is from a default-loaded package, like {base} or {stats} (so I write `mean()` instead of `base::mean()`). This is mostly just convenience!
1. When there are lots of functions from the same package in row, all of which have very distinctive names, that would make reading the code very difficult and writing the code very repetitive. This is the case, for example, with {ggplot2}, which we will encounter later on in the course. For cases like this, I make sure to load the relevant package and then leave off the package name.

I like explicit style because I never have to deal with package conflicts; I rarely have to load packages; and it helps me understand better how my code works. You don't have to use it, and most of the time it won't make *that* much difference, so do what makes sense to you. Just to be safe, though, we'll load {tidyverse} regularly.

\ 

## Functions

Functions are like verbs in the R language. We've already started using a few functions: `c()`, `class()`, `mean()`, and `as.numeric()`. As we've seen, these functions perform some operation using the input inside their brackets, and produce the output of that operation. So, functions are the main way that R *does* anything.

In this section, we'll take a systematic look at the process of using a new function - in particular, functions that take multiple inputs, or *arguments*. As we go, we'll look at how to "translate" the command you want to give R into a verb (function) it can understand.

### Basics and Help

Let's look at an example of how this translation might work. For this example, I'd like to round the mean of four numbers 45.34, 23.001, 7.3, and 16.9820 to two decimal places - a common task for reporting results in APA style.

```{r}
mean_to_round <- mean(c(45.34, 23.001, 7.3, 16.9820))
mean_to_round
```

If we want R to do this for us, we have to write a command that represents the operation we want R to perform. First, we need to know what R function corresponds to that operation. We're lucky in this case: the function in R is also called `round()`.

We know that we're looking at a function in R because functions often have a name followed by brackets (and nothing else in R does). That is, they have the general form `function_name()`. Inside the brackets, we can add more information to the function to complete our command, although not all functions require any more information.

::: {.callout-note appearance="minimal" title="Exercise"}
Try running the `round()` function.

::: {.callout-note collapse="true" title="Solution"}
```{r}
round()
```

Unsurprisingly, R has given us an error. This is an **informative** error, though - that is, the error gives of some sort of intelligible clue about what's gone wrong. Namely, it tells us that `round()` can't just work without additional information (i.e. "required arguments").
:::
:::

What we want to do, "Round the number `r mean_to_round` to two decimal places", has two more important pieces of information that we need to tell R: what number we want to round (`r mean_to_round`) and how many decimal places we want to round it to (2). So, how do we say this in R? To find out, let's look at the help documentation.

::: {.callout-note appearance="minimal" title="Exercise"}
Open the help documentation for the `round()` function by running `?round()` or `help(round)` **in the Console**.
:::

::: {.callout-tip title="Definition: Help Documentation"}
Help documentation is information, like instruction manuals, built into R about how individual functions work. Function documentation varies wildly in helpfulness and completeness, but it's a useful place to check first if you want to find out what a function does. You can access the help documentation in a few different ways: by running `?function_name` or `help(function_name)` in the Console, or by clicking on the "Help" tab in the Files section of RStudio and using the Find box to search for the function.
:::

The first section, "Description", varies quite a bit in intelligibility, depending on how complex the function is. Here, if we ignore the information about the other function included in this document, we can see that we have a useful description of `round()` that tells us that it rounds numbers (that's a good sign) to a certain number of decimal places. That's exactly what we want, so how do we use it?

Let's scroll down to "Usage", which gives examples of what the function looks like. You can see that the basic structure of this function is `round(x, digits = 0)`. It seems like we need to add some more information in the brackets of our function - but how do we interpret `x` and `digits = 0`?

### Arguments

The information inside a function's brackets, which gives it the information it needs to work, are called **arguments**. Each argument in a function is separated by a comma, so we can see from `round(x, digits = 0)` that the `round()` function can take two arguments. How many arguments a function has depends on the function; some (like `Sys.Date()`) don't need any arguments to run. One of the most useful parts of a function's help documentation is the "Arguments" section, which tells you what each of the function's arguments are and how to use them.

When referring to arguments, you will hear the terms "named" and "unnamed" arguments. This can be a bit confusing, because all arguments have a name - they have to, otherwise we couldn't refer to them![^oops] The named vs unnamed distinction doesn't refer to the arguments themselves, but rather how the person using the function chooses to write them out. There are some conventions around which arguments are named or not, so let's have a look at that now.

[^oops]: In fact, a previous version of this tutorial very confidently gave the wrong definitions! Sorry...

The **first argument** to `round()` is simply `x`. Just like in maths, `x` is a placeholder for some number or numbers (a "numeric vector", which should sound familiar now) that the function will work on. This is common notation in many functions: `x`, often the first argument in a function, typically denotes the placeholder for the information you want to use the function on. In our case, we just have one number we want to round, so that's what we should replace with `x`.

It's important to note here that this argument `x` has no **default value**. In other words, we must minimally provide some information `x` to this function or it won't be able to run. We know this because `x` appears on its own as an argument; arguments that *do* have a default value have an `=` sign followed y their default value (see the next paragraphs on `digits = 0`!). Because we always have to provide additional information, `x` and similar arguments containing the values or data to work on are frequently *unnamed* when we use them. That means that instead of `r paste0("round(x = ", mean_to_round,"...)")` we can just write `r paste0("round(", mean_to_round,"...)")`. They are also frequently the first argument in the function[^first]. So, when you see reference to the "first unnamed argument" - especially important in {tidyverse} functions designed to work with the pipe operator, which we'll meet next week - that simply means, "the first argument in the function for which the programmer hasn't specifed a name", which is often, but not always or necessarily, the "data" or "information to work on" argument.

[^first]: Again, not necessarily - the base-R string-manipulation functions `grep()` and friends, for example, have `x` as their *third* argument. I know all the irregularities can be confusing, but remember that R is a massive collaborative project across decades and millions of users, so some quirks are inevitable!

The **second argument** of `round()` is `digits`. You can think of arguments like this as settings that change the way a function works, often with only certain allowable values.

The help documentation tells us that `digits` should be an "integer indicating the number of decimal places...to be used." We can also see in "Usage" that this argument has a default value, `digits = 0`. That means that if we don't explicitly include the argument `digits` when we use the function, by default the `round()` function will round the number you give it to 0 decimal places. Arguments frequently, but not always, have a default, and it's important to check so the function doesn't quietly do something unexpected.

Default values of arguments are really useful, because the default is often the most frequently used or safest[^7] setting. It means you don't have to specify every single aspect of a function every time you use it, as long as you want the function to work according to its defaults. In our case, we actually wanted `round()` to round to two decimal places, not 0. So, in our command, we should change the `digits` setting from the default, `0`, to `2`.

[^7]: By "safest" setting, I mean that the function makes the fewest assumptions about what you intended.

### Using Functions

Now that we know what both of these arguments mean, we can change them to actually translate the sentence "Round the number `r mean_to_round` to two decimal places" into a command that R can work with. We'll explicitly write out the name of each argument so we know what they are doing.

::: {.callout-note appearance="minimal" title="Exercise"}
Use the `round()` function to round `r mean_to_round` to two decimal places.

If you prefer, you can do this with one of the means you calculated for your own scores earlier.

::: {.callout-note collapse="true" title="Solution"}
```{r}
## Using the actual value from my earlier calculation
round(x = 23.15575, digits = 2)

## Using a nested function - that is, calculating the mean and then rounding it!
round(x = mean(c(45.34, 23.001, 7.3, 16.9820)), digits = 2)
```
:::
:::

::: {.callout-important title="MoRe About: Order and Naming of Arguments" collapse="true"}
If you want to, you can achieve the same result by changing the order of the arguments, as long as you pay careful attention to which argument(s) you have named. 

If we have written the names of both arguments, R can still do what we want it to do with the order of arguments reversed:

```{r}
round(digits = 2, x = 23.15575)
```

We can also, to some degree, drop the names of the arguments, as long as R can still understand what we're trying to do. In this case, the "first unnamed argument" is still `x`! Even though it's not the first argument we've written in the function, it's the first one that doesn't have an explicit name.

```{r}
round(digits = 2, 23.15575)
```

Although I left out the `x =`, R can still understand this because `round()` only takes two arguments, and we explicitly told it what value belongs to `digits`, so it assumes the second number must be `x`.

If more than one, or all, of the arguments are unnamed, then order becomes critical:

```{r}
round(23.15575, 2)
```

This time I dropped both argument names. R can still understand this because when you don't specify which input goes with which argument, R will assume they should go in the default order given in the help documentation. So, R has automatically assigned 23.15575 to `x` and 2 to `digits`.

As I use R more and more, I find that I name arguments *more* consistently, even though I know how the function works and dropping them is more efficient (at least in terms of typing). That's because when I come back from lunch, or the next day, or six months later to revisit the same code, it's much easier to recall what it all means when it's well-annotated. So, I strongly recommend getting in the habit of including argument names in your code as a favour to your future self, and to avoid situations like this:

```{r}
## uh oh!
round(2, 23.15575)
```

Here, since we left all the arguments unnamed, R assumed that 2 was the number we wanted to round. This isn't what we wanted - but R has no way of knowing this. It always assumes that what we typed was precisely what we intended to ask R to do.
:::

#### Passing Multiple Values to Arguments

A last important aspect of using functions is that **each argument in a function can only take a single object or value as input**. For example, we saw above that we put the single value 23.15575 into the `x` argument of `round()`. But what if we wanted to round more than one number? We don't want to have to write a new `round()` command for every number, even though we could do this if we particularly enjoyed doing a lot of tedious and repetitive typing:

```{r}
round(23.15575, digits = 2)
round(59.5452, digits = 2)
round(0.198, digits = 2)
```

::: {.callout-note appearance="minimal" title="Exercise"}
Before you go on, have a go using a single `round()` command to round 23.15575, 59.5452, and 0.198 using a single `round()` command.

*Hint*: Refer to [Vectors](#vectors).
:::

So what happens if we try to put all of those numbers into `round()`? We might first try this:

```{r}
round(23.15575, 59.5452, 0.198, 2)
```

Once again, R tells us that this doesn't work by throwing an error. R has tried to do what we wanted, but the `round()` function only allows a max of two arguments, and we've given it four. Behind the scenes, R has tried to run `round(x = 23.15575, digits = 59.5452...` and can't proceed from there because it doesn't know what to do with the last two numbers. So, what we need to do is find a way to put all three numbers that we want to round into the first `x` argument together. If only there was a way to **c**oncatenate them together...

You may have guessed where this is going: one method we could use would be to put the three numbers we want to round into a vector, and then use that vector in `round()` as the `x` argument. We already saw that we can combine any number of things together into a single vector using the `c()` function.

::: {.callout-note title="Solution" collapse="true"}
```{r}
## Create an intermediate object to contain the numbers
numbers <- c(23.15575, 59.5452, 0.198)
round(numbers, digits = 2)

## Put the vector of numbers into round() directly
round(c(23.15575, 59.5452, 0.198), digits = 2)
```
:::

Here we can see a good example of a function inside another function. You can stack, or "nest", functions inside each other like this as much as you like, although it can become difficult to read the code or keep track of what it's doing. (There's a great solution to this problem that we'll encounter in the next tutorial: the pipe operator.)

That's looking like some proper R code! Very nicely done.

::: {.callout-tip title="Help Documentation, Revisited"}
Before we leave the `round()` function altogether, let's take a look at two more useful sections of the help documentation. Depending on what you are trying to do, the "Details" section can tell you more about how exactly the function works - how it behaves in certain situations, or how it handles unusual or difficult cases. If a function isn't doing what you expect it to, this is a good place to look for an explanation.

Finally, at the end of the documentation you can find the "Examples" section. If you are learning to use a new function, this section can give you a template for writing your own commands. You can also click the "Run examples" link, which will run the code in the Examples section for you so you can see what the function will do.
:::

## Packages, redux

We just had an in-depth look at the `round()` function, but say we weren't happy with the way this function does rounding in particular situations. For instance, we might want to round a *p*-value to three decimal places with no leading 0 (as we teach UGs to report *p*), but that's not how `round()` rolls:

```{r}
round(.00793, digits = 3)
```

So, instead, we might look for a different function that does the rounding as we want, with no leading 0, for example [the `rd()` function linked here](https://rdrr.io/cran/weights/man/rd.html). Looks great!

::: {.callout-note appearance="minimal" title="Exercise"}
Round the number .00793 to three decimal places using the `rd()` function.

::: {.callout-note collapse="true" title="Solution"}
```{r}
rd(.00793, digits = 3)
```
:::
:::

Well, that didn't go to plan!

There are two main reasons this "could not find function" error usually appears:

1. You've misspelt the function name. This isn't the case here (it's only two letters!).
2. The package that the function belongs to isn't installed and/or loaded.

So, this function does exist, but in order to use it, we need to install and then load it. 

### Installing Packages

According to the documentation linked above, the package that this function belongs to is called {weights}, so let's install it first.

::: {.callout-note appearance="minimal" title="Exercise"}
Install the {weights} package. Replace `function_name` in the example command below and run this command **in the Console** only.

```{r}
#| eval: false

install.packages("function_name")
```

*Note*: As mentioned above, please don't regularly install packages if you're on the Posit Cloud workspace - but in this specific case, it's good to get the practice!

::: {.callout-note collapse="true" title="Solution"}
Remember to run this command **in the CONSOLE** and *not* in a code chunk!

```{r}
#| eval: false

install.packages("weights")
```
:::

You should see a good bit of chat from R in (alarming) red text. Don't worry unless you see the actual word "ERROR". You should soon see the message `package ‘weights’ successfully unpacked and MD5 sums checked`, which means all is well. 

Now that we know we have the package installed, let's give it another go.

::: {.callout-note appearance="minimal" title="Exercise"}
Round the number .00793 to three decimal places using the `rd()` function.

::: {.callout-note collapse="true" title="Solution"}
```{r}
rd(.00793, digits = 3)
```
:::
:::

Still no dice!

### Loading Packages

We know that we have the right package installed - but as you may have guessed, we haven't also loaded the package. We can actually fix this error in one of two ways:

1. Load the {weights} package using the `library()` function. We can then use the function as written above.
1. Use verbose style, e.g. `weights::rd()`, when writing our command. In this case we don't need to load the package as long as we have it installed.

Alright, third time lucky!

::: {.callout-note appearance="minimal" title="Exercise"}
Round the number .00793 to three decimal places using the `rd()` function, using either method to access the function in the {weights} package.

::: {.callout-note collapse="true" title="Solution"}
Using verbose style, before loading the package:

```{r}
weights::rd(.00793, digits = 3)
```

First loading the package, then using the function without the package call:

```{r}
library(weights)

rd(.00793, digits = 3)
```

:::
:::

