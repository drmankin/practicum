---
title: "07: Visualisations"
---

- Mapping + geom + tweaks
- Histogram, barplot, raincloud plot, scatterplot with LM line

## Overview

This tutorial focuses on creating data visualisations using the {ggplot2} package. It covers the conceptual grammar of {ggplot} and a variety of examples of common plots and tweaks. 

::: {.callout-tip title="Giddy for ggplot"}

If you're really keen on data visualisation with {ggplot2}, check out [Tidy Tuesdays](https://www.tidytuesday.com/). Each week, there's a new dataset released, and people build and share beautiful visualisations, along with the code and frequently their process!

There's also a fantastic how-to called [Data visualisation using R, for researchers who donâ€™t use R](https://psyteachr.github.io/introdataviz/) from the brilliant team at PsychTeachR at Glasgow, that provides a very friendly, start-to-finish walkthrough of the whole process of data reading, manipulation, and plot-building.

:::

## Setup

### Packages

We will be relying heavily on the {ggplot2} package, naturally, which is part of {tidyverse}. You can load {ggplot2} by itself, but since we will also make use of some other {tidyverse} functions, it's probably most efficient to simply load {tidyverse}.

We will also be using {ggrain} for raincloud plots.

::: {.callout-note appearance="minimal" title="Exercise"}

Load the {tidyverse}, {GGally}, and {ggrain} packages.

::: {.callout-note collapse="true" title="Solution"}

```{r}
library(tidyverse)
library(ggrain)
```
:::
:::

::: {.callout-tip title="Non-Explicit Function Calls" collapse="true"}
You may notice that I will abandon my usual explicit function style for {ggplot2} functions - so, for example, instead of `ggplot2::ggplot(ggplot2::aes(...))` I'll just write `ggplot(aes())`. In this case, it is *much* easier to simply load the {ggplot2} package and drop the package call, than to type the same package name over and over *and over*. It also makes the chonky {ggplot2} code a lot easier to read!

:::

### Data

Today we're continuing to work with the dataset courtesy of fantastic Sussex colleague [Jenny Terry](https://www.jennyterry.co.uk/). This dataset contains real data about statistics and maths anxiety. For these latter two tutorials, I've created averaged scores for each subscale, and dropped the individual items.

::: {.callout-note appearance="minimal" title="Exercise"}
Read in the dataset and save it in a new object, `anx_score_data`.

On the Cloud, you can read in this dataset from the `data` folder using `here::here()`.

Elsewhere, you can download the dataset, or copy the dataset URL, from the [Data and Workbooks page](../../../data_workbooks.qmd).

::: {.callout-note collapse="true" title="Solution"}
Read in from file:

```{r}
anx_scores_data <- readr::read_csv(here::here("data/anx_scores_data.csv"))
```

Read in from URL:

```{r}
#| eval: false

anx_data <- readr::read_csv("https://raw.githubusercontent.com/drmankin/practicum/master/data/anx_scores_data.csv")
```
:::
:::

#### Codebook

There's quite a bit in this dataset, so you will need to refer to the codebook below for a description of all the variables.

::: {.callout-tip title="Dataset Info Recap" collapse="true"}
This study explored the difference between maths and statistics anxiety, widely assumed to be different constructs. Participants completed the Statistics Anxiety Rating Scale ([STARS](https://explore.bps.org.uk/content/bpsptr/24/2/101)) and Maths Anxiety Rating Scale - Revised ([R-MARS](https://journals.sagepub.com/doi/10.1177/001316448204200218)), as well as modified versions, the STARS-M and R-MARS-S. In the modified versions of the scales, references to statistics and maths were swapped; for example, the STARS item "Studying for an examination in a statistics course" became the STARS-M item "Studying for an examination in a maths course"; and the R-MARS item "Walking into a maths class" because the R-MARS-S item "Walking into a statistics class".

Participants also completed the State-Trait Inventory for Cognitive and Somatic Anxiety ([STICSA](https://www.cambridge.org/core/journals/behavioural-and-cognitive-psychotherapy/article/abs/distinguishing-cognitive-and-somatic-dimensions-of-state-and-trait-anxiety-development-and-validation-of-the-statetrait-inventory-for-cognitive-and-somatic-anxiety-sticsa/78FDDC5BCDE9D4164434AC10E83DCEF3?utm_campaign=shareaholic&utm_medium=copy_link&utm_source=bookmark)). They completed the state anxiety items twice: once before, and once after, answering a set of five MCQ questions. These MCQ questions were either about maths, or about statistics; each participant only saw one of the two MCQ conditions.
:::

::: callout-important
For learning purposes, I've randomly generated some additional variables to add to the dataset containing info on distribution channel, consent, gender, and age. Especially for the consent variable, don't worry: all the participants in this dataset did consent to the original study. I've simulated and added this variable in later to practice removing participants.
:::

```{r}
#| echo: false

readr::read_csv(here::here("data/anx_scores_codebook.csv")) %>%
  kableExtra::kbl(
    col.names = stringr::str_to_title(names(.)),
    html = TRUE
  ) |> 
  kableExtra::kable_styling()
```

If you have some experience with R, you are welcome to instead use another dataset that you are familiar with or are keen to explore. However, remember that anything you upload to Posit Cloud is visible to all workspace admins, so keep GDPR in mind.

## Grammar of Graphics

THe {ggplot} package is a bit of a universe in its own right. Like R itself, it's extremely powerful and versatile, and that also means there are a near-endless variety of things you could do and different ways to do them.

What we'll cover in this tutorial is the core structure of building data visualisations in {ggplot2}, so that you have a solid base to build your own designs on. No matter what you're trying to do, there's nearly always a blog post, help document, or Stack Overflow post titled "How to do [whatever] in ggplot" to point you in the right direction!

### Layers

Plots in {ggplot2} are built in layers. Each layer adds to or changes something about the plot; these can be big elements, like determining the type of plot to create, to small details like editing axis labels or changing colours. In {ggplot2}, each layer is a function.

If it helps, you can think of layers like [different colours in a linocut print](https://www.instagram.com/reel/CpTb7oCJ5da/?utm_source=ig_web_button_share_sheet). Each additional layer of colour adds a bit more to the overall picture, building up from big blocks of colour to small details.

To build a visualisation in {ggplot2}, it's a good idea to build your plot in the same way, from big picture to small detail. As we'll see, I ususlly build plots layers like this:

```r
dataset |> 
  choose_variables_to_visualise +
  choose_type_of_plot +
  add_more_elements +
  edit_labels_or_colours +
  apply_a_theme
```
These are guidelines[^rules], but the general => specific flow is for a good reason: **layers are evaluated from top to bottom**. So, it's best to get the big pieces in place first, then fine-tune, than to have those fiddly bits overwritten by a major change at the end of the code.

[^rules]: ![](https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaHkyNWtraTM2dm5xY2J1bGYzb3hmMmhubHp4dWM1MXl6bmpxcnY3NCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/uXUmaREltwja1dEqXi/giphy.gif)

Notice as well that **layers are added to a plot object with `+` and NOT with `|>`**. This is specific to {ggplot2} (AFAIK!) and is easy to forget, but don't worry - it's such a common thing to mistake that {ggplot2} has a very friendly built-in recommendation for fixing it.

::: {.callout-warning title="Error Watch: `mapping` must be created by `aes()`" collapse="true"}

The actual error that pops up when you use a pipe instead of `+` isn't super transparent. However, there is a very friendly reminder directly underneath to nudge you in the right direction. It's a good reason to always read the error message in full!

```{r}
#| error: true

anx_scores_data |> 
  ggplot(aes(x = mcq_sum)) |> 
  geom_histogram()
```
:::

### Mapping

As we saw in the error just above, mapping is created with `aes()`. This little function defines the *aes*thetics of the plot - in other words, this is how you tell R what data you want it to plot. I'll use the following general format to set up a plot:

```r
dataset_name |> 
  ggplot(aes(x = variable_on_x_axis, y = variable_on_y_axis, ...))
```

The `...` takes additional arguments to add things like colour and fill. 

### Geoms, etc.

So, how do we actually add layers? There are several common types of functions with shared prefixes that do particular things. We'll meet lots of examples of them just below, but as a quick reference for some of the more common function types:

- `geom_*()`: Draw *geom*etric objects to represent the data. 
- `stat_*()`: Add elements to the plot calculated with *stat*istical functions.
- `scale_*()`, `labs()`, and `lims()`: Adjust the appearance of the axes (labels, title, limits, etc.) or quickly adjust the *lab*els or *lim*its only
- `guide_*()`: Make adjustments to the scales or to other interpretational elements of the plot (such as legends for categories)
- `theme_*()`: Apply a pre-made theme to the entire plot

::: {.callout-tip}

See the [{ggplot} reference documentation](https://ggplot2.tidyverse.org/reference/) for a comprehensive list and detailed guide to these functions and more.

:::

Right, the best way to get a handle on these functions is to start building plots! So let's jump in.

## Histograms and Density Plots

Let's start with a histogram, a very common type of visualisation that represents the frequency of each value in a variable. We're going to first create a histogram of the `mcq_score` variable in the `anx_scores_data` dataset.

For a basic histogram, we need three elements. First, pipe in the data; then, set the aesthetics; then, use `geom_histogram()` to draw the plot.

```{r}
#| message: true

anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram()
```

Hooray! The downside is... that's pretty ugly. For a quick glance this isn't really any better than `hist()`. So - let's make it better by doing the following:

  1. Adjusting the binwidth (and colours if necessary) to present the values more sensibly 
  2. Adjusting the axis labels and tick marks.
  3. Applying a theme.

::: callout-tip

If you haven't yet, you might want to pull up the help documentation for `geom_histogram()` to get a look at the options available.

:::

#### Adjusting Binwidth

The message from the previous output gave us a helpful tip to deal with those weird bins:

```
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

So, let's use `binwidth =` to choose a more appropriate value for this data. Because these are the summed MCQ scores, the values can only be **whole numbers** between 0 and 5. So, let's try setting the binwidth to 1.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1)
```

This is better, but now we've got some new problems: one, the automatically generated axis now only has 0, 2, and 4, when it would be better to have 0 - 5; and the histogram now looks like quite a shapeless lump. Let's work on the colour first.

#### Colour and Fill

It's not obvious from the help documentation unfortunately (just mentioned in passing under the `...` argument) but this function, and most `geom_*()` functions!, will take the arguments `colour` and `fill`. For this, we give each argument a string with a colour name in it. You can just guess at colour names until you find one you like, or you can refer to this [massive list of R colour names]() to pick one.

Here's an example of how that looks with some very boring colours, that's a bit easier on the eyes than the dark grey lump above.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1, colour = "black", fill = "lightgray")
```

This would be fine for formal reporting, but we're going to be all about the aesthetics today and those colours are downright dreary. Let's instead borrow from the [Sussex official colour palette](https://www.sussex.ac.uk/brand/designers/colour) to set custom colours. I'm choosing "Sussex Flint"[^flint] for the outline colour and "Deep Aquamarine" for the fill, but feel free to choose whatever you like. You could also use [an online colour picker like this one](https://www.google.com/search?q=colour+picker) to choose any hex code for any colour you can dream of to use!

[^flint]: You may notice a certain commonality to the colour theme of this website!

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1, colour = "#003b49", fill = "#007a78")
```

With that sorted, let's move onto the axis and ticks.

You can use the `labs()` shortcut to adjust labels easily, but personally I prefer to go the long way round (surprise lol) and use the `scale_*()` family instead. These functions have specific names depending on which axis scale you want to adjust, and the way that data is measured. In this case I want to adjust the *x*-axis and the data is continuous[^cont], so the function I need is `scale_x_continuous()`.

[^cont]: Yes, this is arguably not *technically* true because the values can only be whole numbers between 0 and 5, but what matters here is that *R* thinks this is continuous data.

The advantage of going through the extra trouble to use the `scale_*()` functions is that they allow you to adjust everything about that scale at once. So, I can use the arguments for `scale_x_continous()` to change the axis label with `name =`, the breaks with `breaks =`, the limits with `limits =` - well, I'm sure you get the idea!

I can also do the same with the *y* axis, using (as you might have guessed) `scale_y_continous()`.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1, colour = "#003b49", fill = "#007a78") +
  scale_x_continuous(name = "Total MCQ Score (out of 5)",
                     breaks = c(0:5)) +
  scale_y_continuous(name = "Frequency",
                     breaks = seq(from = 0, to = 120, by = 20),
                     limits = c(0, 120))
```

If you have a look at the argument to `breaks` and `limits`, you can see why we took some time early on learning about numeric vectors. `breaks` requires a vector of values where the breaks should be, and `limits` requires a vector of two values, one for the minimum limits and the other for the maximum limit.

I've also used a new function, `seq()`, to create the *y*-axis breaks. This handy little base-R function generates a *seq*uence of values, given the first and last values in the sequence and how much you want to increment by. I've asked it to start at 0, end at 120, and increment by 20 each time, instead of typing `c(0, 20, 40, ...)` myself.

That's actually looking pretty snazzy at this point. The last thing we might want to do for now is to apply a theme. The default is `theme_grey()`, which I'm not a fan of. If you type `theme_` into a code chunk, you'll get a list of options to try out and find one you like. I'm going with a clean and simple favourite, `theme_minimal()`.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1, colour = "#003b49", fill = "#007a78") +
  scale_x_continuous(name = "Total MCQ Score (out of 5)",
                     breaks = c(0:5)) +
  scale_y_continuous(name = "Frequency",
                     breaks = seq(from = 0, to = 120, by = 20),
                     limits = c(0, 120)) +
  theme_minimal()
```
  
There you have it! That's looking pretty nice I think.

::: {.callout-warning collapse="false"}

### Facet Wrap

*Note*: This gets a bit into the weeds, so if you'd like to skip this section, you can collapse it to get to the next type of plot.

Before we move on, a useful option here would be to visualise the MCQ scores for the two MCQ groups side by side, since this was our independent manipulation. To do this, we can first use the `facet_wrap()` function to split our single plot into two based on a grouping variable - here, `mcq`. I've also changed the settings on the *y*-axis to adjust to the new scale.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score)) +
  geom_histogram(binwidth = 1, colour = "#003b49", fill = "#007a78") +
  scale_x_continuous(name = "Total MCQ Score (out of 5)",
                     breaks = c(0:5)) +
  scale_y_continuous(name = "Frequency",
                     breaks = seq(from = 0, to = 70, by = 10),
                     limits = c(0, 70)) +
  facet_wrap(~mcq) +
  theme_minimal()
```

There are a few more things I'd like to tweak about this plot. First, I'd love to have the maths and stats groups in different colours to differentiate them visually. Second, I want to format the "maths" and "stats" labels at the top of the plot.

To do the first, I'm going to actually go back up to the `aes()` mapping function and add `mcq` as the variable that determines both colour and fill, and drop the `color` and `fill` arguments from `geom_histogram()`.

Next, I'm going to add a vector of names and values to the `labeller = as_labeller(...)` argument of `facet_wrap()`, which adds nice labels above each mini-plot.

Finally, I use two more `scale_*()` functions to set the colour and fill, with the order of the colours in the same order as the values of the `mcq` variable. The `guide = "none"` argument removes the automatically generated legend, which I didn't need because I added the labels.

Whew! That's it - here's the final product.

```{r}
anx_scores_data |> 
  ggplot(aes(x = mcq_score, colour = mcq, fill = mcq)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(name = "Total MCQ Score (out of 5)",
                     breaks = c(0:5)) +
  scale_y_continuous(name = "Frequency",
                     breaks = seq(from = 0, to = 70, by = 10),
                     limits = c(0, 70)) +
  facet_wrap(~mcq, labeller = as_labeller(c(`maths` = "Maths MCQs",
                                          `stats` = "Stats MCQs"))) +
  scale_color_manual(values = c("#003b49", "#1b365d"), guide = "none") +
  scale_fill_manual(values = c("#007a78", "#7da1c4"), guide = "none") +
  theme_minimal()
```

:::

If you've got all this down, let's next have a go at creating a density plot with a different variable to lock it in.

::: {.callout-note appearance="minimal" title="Exercise"}

Create a density plot of the `rmars_s_test_score` variable (or another continuous variable in the dataset of your choosing). For a finished plot, make sure you:

- Choose colours for your plot.
- Adjust the labels, breaks, and limits as necessary.
- Add a theme.

::: {.callout-note collapse="true" title="Solution"}

We can start the same way we did above, just switching out our previous variable in `aes()` for the new one and changing `geom_histogram()` to `geom_density()`. I've left the colours in because they work the same way (and look nice!).

```{r}
anx_scores_data |> 
  ggplot(aes(x = rmars_s_test_score)) +
  geom_density(binwidth = 1, colour = "#003b49", fill = "#007a78")  +
  scale_x_continuous(name = "Mean Score on the R-MARS-S Test Subscale",
                     breaks = c(0:5)) +
  scale_y_continuous(name = "Probability Density",
                     limits = c(0, .5)) +
  theme_minimal()
```

From here we might want to do a bit more tweaking to get the axes right, using the same functions as we did for the histogram.

```{r}
anx_scores_data |> 
  ggplot(aes(x = rmars_s_test_score)) +
  geom_density(binwidth = 1, colour = "#003b49", fill = "#007a78")
```

:::
:::
  
## Violin and Raincloud Plots

For this section, we'll look briefly at creating violin plots, but focus on making nice raincloud plots, which we teach repeatedly in UG year 1. For both of these plots, we're going to expand our {ggplot} vocab by explicitly including a *y*-axis variable.

Let's start by producing violin plots comparing trait anxiety scores between our four gender categories, to start. This structure should start to look familiar now.

```{r}
anx_scores_data |> # <1> 
  ggplot(aes(x = gender, y = sticsa_trait_score)) +  # <2> 
  geom_violin()  # <3> 
```

1. Take the dataset `anx_scores_data`, *and then*
2. Set up a plot, mapping `gender` to the *x*-axis and `sticsa_trait_score` to the *y*-axis, *plus*
3. Draw a violin plot.

With no other details, this is pretty uninspiring. One option is to add means and CIs on top of the violin plots, to help us interpret them.

### Calculating Stats

To add means and CIs to our plot, we'll need to calculate them. There's no need to create a summary first - we can use a `stat_*()` function to calculate the necessary statistics inside our plot.

In this case, we can use `stat_summary()` to produce some summary statistics. To really make it quick, we're going to quote the function `mean_cl_boot`, which calculates means and bootstrapped CIs. That's it - just that one line does all the maths and adds the result to the plot.

```{r}
anx_scores_data |> # <1> 
  ggplot2::ggplot(aes(x = gender, y = sticsa_trait_score)) +  # <2> 
  geom_violin() +  # <3> 
  stat_summary(fun.data = "mean_cl_boot")  # <4> 
```

1. Take the dataset `anx_scores_data`, *and then*
2. Set up a plot, mapping `gender` to the *x*-axis and `sticsa_trait_score` to the *y*-axis, *plus*
3. Draw a violin plot, *plus*
4. Calculate means and bootstrapped CIs and add them to the plot.

### Raincloud Plots

### Customisation

- Adding colour
- splitting on a grouping variable

## Reshaping with `pivot_*()`

### Bivariate

#### Scatterplots

#### Heatmaps

#### Interaction Plots