---
title: "10: Qualtrics and Labelled Data"
---

## Overview

This tutorial will focus on efficient, transparent, and user-friendly techniques for working with data specifically gathered using the [Qualtrics survey platform](https://www.qualtrics.com/). We will cover how to import and work with labelled data from Qualtrics and how to reduce data management headaches down the line by setting up a well-structured and thoroughly labelled Qualtrics survey from the outset.

### Acknowledgements

This tutorial was co-conceived and co-created with two brilliant PhD researchers, [Hanna Eldarwish](mailto:haie20@sussex.ac.uk) and [Josh Francis](Joshua.Francis@sussex.ac.uk), who contributed invaluable input throughout the process of developing the tutorial. This included collecting commonly asked questions and issues with Qualtrics data analysis; discussing the topics to cover and how best to cover them; and testing code and solutions. Hanna Eldarwish also provided the basis for the dataset, collected during her undergraduate dissertation at Sussex under the supervision of [Dr Vlad Costin](https://profiles.sussex.ac.uk/p323096-vlad-costin).

## Setup

### Packages

As usual, we will be using {tidyverse}. When {tidyverse} is installed, it also installs the {haven} package, which we will use for data importing. However, {haven} isn't loaded as part of the core {tidyverse} group of packages, so let's load it separately. Finally, we will also need the {labelled} package to work with labelled data.

::: {.callout-note appearance="minimal" title="Exercise"}
Load the packages.

::: {.callout-note collapse="true" title="Solution"}
```{r}
library(tidyverse)
library(haven)
library(labelled)
library(sjlabelled)
library(sjPlot)
```
:::
:::

### Data

Today's dataset focuses on various aspects of meaning in life (MiL), and has been randomly generated based on a real dataset kindly contributed by Hanna Eldarwish and Vlad Costin. All variables have been randomly generated, but they are based on the patterns in the original dataset. The original, bigger dataset will be made available alongside article publication in the future, so keep an eye out for it!

::: {.callout-tip title="New File Type"}
You might notice that instead of the familiar `readr::read_csv()`, today we have `haven::read_sav()`. That's because the file I've prepared is a SAV file, associated with the SPSS statistical analysis programme. The next section explains *why* we are using this data type, but otherwise, there's nothing new about these commands.
:::

```{r}
mil_data <- here::here("data/mil_data.sav") |> haven::read_sav()
```

#### Codebook

This codebook is intentionally sparse, because we'll be generating our own from the dataset in just a moment. This table covers only the questionnaire measures to help you understand the variables.

\ 

## Qualtrics Data

[Qualtrics](https://www.sussex.ac.uk/its/services/software/qualtrics) is a survey-building tool very commonly used for questionnaire-type studies, as well as some experimental work. The University of Sussex has an institutional licence for Qualtrics, so all staff and students can log in with their Sussex details and easily construct and collaborate on surveys.

For help using Qualtrics itself, the [Qualtrics support pages](https://www.qualtrics.com/support/survey-platform/my-projects/my-projects-overview/) are generally excellent. This tutorial will only briefly touch on the options within Qualtrics itself, primarily in the [Setting Up Qualtrics](10_qtrics.qmd#setting-up-qualtrics) section at the end.

Once the study is complete and responses have been collected, you will need to [export your data from Qualtrics](https://www.qualtrics.com/support/survey-platform/data-and-analysis-module/data/download-data/export-data-overview/) so that you can analyse it. Qualtrics offers a variety of export data types, including our familiar CSV type. However, we're going to instead explore a new option: SAV data.

### SAV Data

The `.sav` file type is associated with [SPSS](https://www.ibm.com/products/spss-statistics), a widely used statistical analysis programme. So, why are we using SPSS files when working in R?

Importing via `.sav` has two key advantages. First, it results in a much cleaner import format. If you try importing the same data via `.csv` file, you'll find that you need to do some very fiddly and pointless cleanup first. For instance, the `.csv` version of the same dataset will introduce some empty rows that have to be deleted with `dplyr::slice()` or similar. The `.sav` version of the dataset doesn't have any comparable formatting issues.

Most importantly, however, importing `.sav` file types into R with particular packages like {haven} gets us a dataset with a special type of data: namely, labelled data. The labels allow us to preserve important information about the questions asked and response options in Qualtrics, and to (mostly) painlessly create codebooks for datasets. We will explore these features in depth in this tutorial

### Exporting from Qualtrics

If you'd like to work with your own study data, you will need to export your data in SAV format from Qualtrics first. To do this, open your Qualtrics survey and select the "Data & Analysis" tab along the top, just under the name of your survey.

In the Data Table view, look to the right-hand side of the screen. Click on the drop-down menu labelled "Export & Import", then select the first option, "Export Data..."

![](/images/qtrics_export.png){fig-alt="A screenshot the Qualtrics Data & Analysis screen with red boxes indicating the steps to take to export data: Data & Analysis tab, Export & Import menu, and Export Data... option."}

In the "Download a data table" menu, choose "SPSS" from the choices along the top. Make sure "Download all fields" is ticked, then click "Download".

![](/images/qtrics_spss.png){fig-alt="A screenshot the Qualtrics Download a Data Table screen with red boxes indicating the steps to take to export SPSS data: SPSS tab, Download button."}

The dataset will download automatically to your computer's Downloads folder. From there, you should rename it to something sensible and move it into a `data` folder within your project folder. From there, you can read it in using the `here::here() |> haven::read_sav()` combo that we saw in the Data section previously.

::: {.callout-tip title="Sensible Naming Conventions and Folder Structure" collapse="false"}
I know it may not seem like something anyone should care about, but sensible file and folder names will make your life so much easier for working in R (and generally).

For folder structure, make sure you do the following:

-   Always always *ALWAYS* use an R Project for working in R.
-   Have a consistent set of folders for each project: for example, `images`, `data`, and `docs`.
-   Use sub-folders where necessary, but consider using sensible naming conventions instead.

For naming conventions, your file name should make it obvious what information it contains and when it was created, *especially* for datasets like this. Personally, I would prefer longer and more explicit file names over brevity; this is because I prefer to navigate files using R, and that's *much* easier using explicit file names than it is with file metadata.

So, for a download like this, I'd probably name it something like `qtrics_diss_2023_11_08.sav`. The `qtrics` tells me it's a Qualtrics export, the `diss` tells me it's a dissertation project, and the last bit is the full date in easily machine-readable format. Imagine if I continue to recruit participants and download a new dataset later, say a month from now, and name it `qtrics_diss_2023_12_08.sav`. I could easily distinguish which dataset was which by the date, but also see that they are different versions of the same thing by their shared prefix.

This is a much more reliable system than calling them, say, `Qualtrics output.sav` and `Dissertation FINAL REAL.sav`. This kind of naming "convention" contains no information about which is which or when they were exported, or even that they're two versions of the same study dataset! It might seem like a small detail at the time, but Future You trying to figure out which dataset to use weeks or months later will feel the difference.
:::

### Importing SAV Data

Next we need to import, or read in, the data into an object in R as before. However, we can't use `readr::read_csv()`, because we don't have CSV data. We'll go with the {tidyverse} option (surprise), which uses the `read_sav()` function from the {haven} package instead. Otherwise, everything about this command is just like we've seen before.

::: {.callout-note appearance="minimal" title="Exercise"}

Read in the `mil_data.sav` object from the data folder, or alternatively from Github via URL, as you prefer.

::: {.callout-note collapse="true" title="Solution"}

From a folder:

```{r}
mil_data <- here::here("data/mil_data.sav") |> haven::read_sav()
```

From URL:

```{r}
#| eval: false
#| 
mil_data <- haven::read_sav("https://raw.githubusercontent.com/drmankin/practicum/master/data/mil_data.sav")
```

:::
:::

\ 

## The Plan

Our workflow for this dataset will be slightly different than previously. We'll start by doing some basic cleanup of the dataset, and produce a codebook, or "data dictionary", drawing on the label metadata in the SAV file. For the purpose of practice, we'll also have a look at how to work with those labels, and manage different types of missing values.

As useful as labels are, they will get in the way when we want to work with our dataset further. So, we'll convert the variables in the dataset into either factors, for categorical data, or numeric. From that point forward, we can work with the dataset using the techniques and functions we've learned thus far.

\ 

## Cleanup and Data Dictionary

::: callout-tip
Most of the following examples are drawn from the ["Introduction to labelled" vignette](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) from the {labelled} package. If you want to do something with labelled data that isn't covered here, that's a good place to start!
:::

Let's start off by having a look at the dataset. As usual, you can call the dataset or use `View()` on it directly, but we're going to take advantage of the new data type to get a more helpful summary, that emulates the "Variable View" in SPSS.

::: {.callout-note appearance="minimal" title="Exercise"}

Use the `generate_dictionary()` function from the {labelled} packages to create a data dictionary for `mil_dict`, then pipe it into `View()`.

::: {.callout-note collapse="true" title="Solution"}

```{r}
#| eval: false
mil_data |> 
  labelled::generate_dictionary() |>
  View()
```

```{r}
#| echo: false

mil_data |> 
  labelled::generate_dictionary() |> 
  tibble::as_tibble() |> 
  dplyr::rowwise() |> 
  dplyr::mutate(
    value_labels = dplyr::case_when(
      is.null(value_labels) ~ "",
      !is.null(value_labels) ~ unlist(value_labels) |> names() |> paste0(collapse = ", ")
    )
  ) |> 
  dplyr::ungroup()
```

:::
:::

What we get is a new summary dataset that contains some useful information about each of the variables in `mil_data`. Along with the actual variable name in the dataset, which we see under `variable`, we also get the actual question that participants saw in Qualtrics under `label`, and the response options - where applicable - in `value_labels`. We'll come back to these in a moment, but we're first going to address two minor issues that commonly come up with Qualtrics data.

### Renaming Variables

If you inspected the dataset closely, you might have noticed that one of the items has a strange name: `coherence_42`, right between `coherence_1` and `coherence_3`. 

This wasn't intentional - in the process of creating the questionnaire in Qualtrics, this variable came out with a weird name. It happens more easily than you think! The best-case option would be to update the Qualtrics questionnaire itself before exporting the data, but you may not be able (or want) to do this, so instead, let's have a quick look at how to rename variables.

As (almost) always, there's a friendly {dplyr} function to help us with our data wrangling. This time it's sensibly-named `dplyr::rename()`, which renames variables using `new_name = old_name` arguments. 

::: {.callout-note appearance="minimal" title="Exercise"}

Rename `coherence_42` to `coherence_2`. Don't forget to save this change to the dataset!

::: {.callout-note collapse="true" title="Solution"}

```{r}
mil_data <- mil_data |> 
  dplyr::rename(coherence_2 = coherence_42)
```

:::
:::

::: callout-tip

Do you have lots of variables to rename? Do you like writing functions, or using regular expressions? Check out `rename()`'s flashier cousin `rename_with()`, which uses a function to rename variables.

:::

### Separating Columns

The second thing I'd like to do doesn't concern the main dataset, but rather the data dictionary we've generated. For the single-item questions, the `label` column is reasonably helpful. However, the items with a shared prefix all come from the same matrix scale in Qualtrics, and their labels have two parts: the "question text" that usually contains directions about how to respond, and the actual item text for each individual item. 

As an example, the label for `belonging_1` reads:

```{r}
#| echo: false
#| 
b1_text <- labelled::generate_dictionary(mil_data) |> 
  dplyr::filter(variable == "belonging_1") |> 
  dplyr::pull(label)
```

> `r b1_text`

Which corresponds to this in Qualtrics:

![](/images/b1.png){fig-alt="A screenshot of a Qualtrics matrix table of Likert responses, with 'Please rate the extent to which these statements apply to you' at the top, and a single item, 'When I am with others, I feel included' and a rating scale from strongly disagree to strongly agree."}

To make the labels more readable, let's split the question text, which is repeated for all items on the same subscale and not very useful, and the item text, which contains the specific text of each item. The good news is that the two pieces are defined, or delimited, by the " - " symbol that Qualtrics automatically adds to link them.

Since we want to separate the `labels` column into two - making the dataset wider - using a delimiter, the `separate_wider_delim()` function from the {tidyr} package should do the trick!

```{r}
mil_data |> #<1>
  labelled::generate_dictionary() |> #<2>
  tidyr::separate_wider_delim( #<3>
    cols = label, #<4>
    delim = " - ", #<5>
    names = c("label", "item_label"), #<6>
    too_few = "align_start" #<7>
  )
```

1. Take the data, *and then*
1. Generate the data dictionary, *and then*
1. Separate wider by delimiter as follows:
1. Separate the `label` column
1. At the " - " delimiter
1. Into two new columns called "label" and "item_label" respectively
1. If there are two few pieces (that is, for the rows where there is no delimiter), fill in values from the start.

The result isn't perfect, but it'll do for our purposes - namely, to have a quick reference for the variables in our dataset.

::: {.callout-note appearance="minimal" title="Exercise"}

Save the final (for now) data dictionary in a new object, `mil_dict`, so we can refer to it as needed.

::: {.callout-note collapse="true" title="Solution"}
```{r}
mil_dict <- mil_data |> 
  labelled::generate_dictionary() |> 
  tidyr::separate_wider_delim(
    cols = label,
    delim = " - ",
    names = c("label", "item_label"),
    too_few = "align_start"
  )
```

:::
:::

## Labelled Data

As we've just seen in the data dictionary, the SAV data we're using has a special property: labels. Labelled data has a number of features, all of which we will explore in depth throughout this tutorial:

-   [**Variable labels**](10_qtrics.qmd#variable-labels). The label associated with a whole variable will contain the text of the item that the participants responded to. This is analogous to the "Label" column of the Variable View in SPSS.

-   [**Value labels**](10_qtrics.qmd#value-labels). The label associated with individual values within a variable will contain the text associated with individual choices, for instance the points on a Likert scale or the options on a multiple-choice question. This is analogous to the "Values" column of the Variable View in SPSS.

-   [**Missing values**](10_qtrics.qmd#missing-values). Within value labels, you can designate particular values as indicative of missing responses, refusal to respond, etc. This is analogous to the "Missing" column of the Variable View in SPSS.

::: callout-important
These features will work optimally *only* if you have set up your Qualtrics questionnaire appropriately. Make sure to refer to the [Setting Up Qualtrics](10_qtrics.qmd#setting-up-qualtrics) section of this tutorial to get the most out of your labelled data and save yourself data cleaning and wrangling headaches later.
:::

### Variable Labels

#### Getting Labels

```{r}
labelled::var_label(mil_data$gender)
```

#### Searching Labels

```{r}
labelled::look_for(mil_data, "family") |> 
  tibble::as_tibble()
```


#### Creating/Updating Labels

### Value Labels

#### Getting  Labels

```{r}
val_labels(mil_data$gender)
```

```{r}
val_label(mil_data$gender, 1)
```

### Missing Values

```{r}
labelled::val_labels(mil_data$english_fluency_1)

labelled::na_values(mil_data$english_fluency_1) <- 3:4

mil_data$english_fluency_1
```


## Converting Variables

### Factor



### Numeric



### Conditional Conversion



## Setting Up Qualtrics

### Labelling Variables

### Labelling Values

### Other Considerations

### Questionnaire Template


duplicated
```{r}
mil_data |> 
 dplyr::mutate(
   n_miss = rowSums(is.na(mil_data)),
   .keep = "used"
 )


```

